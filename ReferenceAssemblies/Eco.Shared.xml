<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eco.Shared</name>
    </assembly>
    <members>
        <member name="T:Eco.Shared.Authentication.AnonymousDeveloperAppAuthenticator">
            <summary>Debug mode only app authenticator which has no identity, but provides Developer level <see cref="T:Eco.Shared.Authentication.AppIdentity"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Authentication.AppAuthentication">
            <summary>Current app authentication (both for client and server). May be used for different features which requires authorization.</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.AppAuthentication.Authenticate(System.Collections.Generic.IEnumerable{Eco.Shared.Authentication.IAppAuthenticator})">
            <summary>Authenticates app trying <paramref name="authenticators"/> until first succeed.</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.AppAuthentication.SetIdentity(Eco.Shared.Authentication.AppIdentity)">
            <summary>Authenticates app using <paramref name="appIdentity"/>. If null then uses anonymous identity.</summary>
        </member>
        <member name="T:Eco.Shared.Authentication.AppAuthenticationResult">
            <summary>App authentication result returned by <see cref="M:Eco.Shared.Authentication.IAppAuthenticator.Authenticate"/>. May be skipped, failed or successful. If <see cref="P:Eco.Shared.Authentication.AppAuthenticationResult.IsSuccessful"/> then <see cref="F:Eco.Shared.Authentication.AppAuthenticationResult.Identity"/> contains auth info.</summary>
        </member>
        <member name="T:Eco.Shared.Authentication.AuthResult">
            <summary>A mirror of AuthSucceedResult and AuthFailedResult from AuthServer combined</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.AuthResult.Valid">
            <summary>Flag determining if this <see cref="T:Eco.Shared.Authentication.AuthResult"/> instance is valid.</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.AuthResult.ConvertToLoginSession(System.String,System.String)">
            <summary>Converts the <see cref="T:Eco.Shared.Authentication.AuthResult"/> instance into a <see cref="T:Eco.Shared.Authentication.LoginSession"/> instance. Primarly used by external platform based authentication.</summary>
            <param name="authTokenType">Optional auth_token_type parameter to supply.</param>
            <param name="authTokenId">Optional auth_token_id parameter to supply.</param>
            <returns>Converted <see cref="T:Eco.Shared.Authentication.LoginSession"/> instance.</returns>
        </member>
        <member name="M:Eco.Shared.Authentication.AuthResult.ConvertToLoginSession">
            <inheritdoc cref="M:Eco.Shared.Authentication.AuthResult.ConvertToLoginSession(System.String,System.String)"/>
        </member>
        <member name="T:Eco.Shared.Authentication.CommandLineAppAuthenticator">
            <summary>App authenticator based on pair of -user and -passwordOrToken command line arguments.</summary>
        </member>
        <member name="T:Eco.Shared.Authentication.IAppAuthenticator">
            <summary>Interface for authenticator which may authenticate current app with <see cref="T:Eco.Shared.Authentication.AppIdentity"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.IAppAuthenticator.Authenticate">
            <summary>Tries to authenticate app. Returns <c>null</c> if fails to authenticate.</summary>
        </member>
        <member name="T:Eco.Shared.Authentication.AccountTiers">
            <summary> Key account tiers from the accounts database. There are multiple versions of tiers so use >= to compare for a specific tier. </summary>
        </member>
        <member name="T:Eco.Shared.Authentication.LoginSession">
            <summary>Represents a verified/authenticated account's gameplay session.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.username">
            <summary>Session's associated account Username</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.auth_token">
            <summary>Session's associated authentication token type. Used to verify accounts with servers.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.login_token">
            <summary>Used to login without requiring password (user by the client and SLG service only)</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.user_id">
            <summary>The associated account's SLG id returned from verify.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.steam_id">
            <summary>The associated account's Steam id returned from verify if found.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.twitch_id">
            <summary>The associated account's Twitch id returned from verify if found.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.citizen">
            <summary>The associated account's Citizen status. Value will represent 1 if the user is a Citizen account.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.error">
            <summary>Login error message if any.</summary>
        </member>
        <member name="P:Eco.Shared.Authentication.LoginSession.Valid">
            <summary>Flag determining if this <see cref="T:Eco.Shared.Authentication.LoginSession"/> instance is valid.</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.LoginSession.IsSameUser(Eco.Shared.Authentication.LoginSession)">
            <summary>Compares two <see cref="T:Eco.Shared.Authentication.LoginSession"/> instances to check if they are the same user.</summary>
            <param name="other"><see cref="T:Eco.Shared.Authentication.LoginSession"/> to compare.</param>
            <returns>True if the two <see cref="T:Eco.Shared.Authentication.LoginSession"/> instances refer to the same account.</returns>
        </member>
        <member name="T:Eco.Shared.Authentication.UserAuthentication">
            <summary>Static interface class for talking to Eco's auth server instance</summary>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.AuthRequestAsync``1(System.Net.Http.HttpMethod,System.String,System.Net.Http.HttpContent)">
            <summary>Performs an authentication server api request.</summary>
            <typeparam name="TModel">Exepcted result model from auth server</typeparam>
            <param name="method">HttpMethod to use for this request</param>
            <param name="url">Version/Controller/Method on the auth server to invoke</param>
            <param name="content">Content to send to the AuthServer endpoint</param>
            <returns>Tuplle containing the decoded model provided by <typeparamref name="TModel"/> if succesful and any associated localized error message.</returns>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.AuthenticateUserAsync(System.String,System.String)">
            <summary>Performs a user authentication call with the Auth Server.</summary>
            <param name="username">Username of the user being authenticated.</param>
            <param name="passwordOrLoginToken">Password or login token of the user being authenticated.</param>
            <returns>Tuple containing the <see cref="T:Eco.Shared.Authentication.LoginSession"/> instance and a <see cref="T:System.String"/> with any errors that occured during the HTTP request process.</returns>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.AuthenticateUser(System.String,System.String)">
            <summary>Blocking variant of <see cref="M:Eco.Shared.Authentication.UserAuthentication.AuthenticateUserAsync(System.String,System.String)"/>. Performs a user authentication call with the Auth Server.</summary>
            <inheritdoc cref="M:Eco.Shared.Authentication.UserAuthentication.AuthenticateUserAsync(System.String,System.String)"/>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.AuthenticatePlatformUserAsync(System.String,System.String,System.String,System.String,System.String)">
            <summary>Performs a platform user authentication call with the Auth Server.</summary>
            <param name="token">Platform token string to authenticate with.</param>
            <param name="tokenId">Id of the platform token being processed.</param>
            <param name="tokenType">Type of platform token being processed.</param>
            <param name="username">Platform username of the user being authenticated.</param>
            <param name="serverId">Optional server id to specify with the <see cref="M:Eco.Shared.Authentication.UserAuthentication.VerifyTokenAsync(System.String,System.String,System.String)"/> request.</param>
            <returns>Tuple containing the <see cref="T:Eco.Shared.Authentication.LoginSession"/> instance and a <see cref="T:System.String"/> with any errors that occured during the HTTP request process.</returns>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.AuthenticatePlatformUser(System.String,System.String,System.String,System.String,System.String)">
            <summary>Blocking variant of <see cref="M:Eco.Shared.Authentication.UserAuthentication.AuthenticatePlatformUserAsync(System.String,System.String,System.String,System.String,System.String)"/>. Performs a platform user authentication call with the Auth Server.</summary>
            <inheritdoc cref="M:Eco.Shared.Authentication.UserAuthentication.AuthenticateUserAsync(System.String,System.String)"/>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.VerifyTokenAsync(System.String,System.String,System.String)">
            <summary>async used on servers to verify that users are who they say they are</summary>
            <param name="serverId"></param>
            <param name="token"></param>
            <param name="tokenType"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Authentication.UserAuthentication.VerifyToken(System.String,System.String,System.String)">
            <summary>Blocking varient of <see cref="M:Eco.Shared.Authentication.UserAuthentication.VerifyTokenAsync(System.String,System.String,System.String)"/>.</summary>
            <inheritdoc cref="M:Eco.Shared.Authentication.UserAuthentication.VerifyTokenAsync(System.String,System.String,System.String)"/>
        </member>
        <member name="T:Eco.Shared.Authentication.VoiceJoinTokenRequest">
            <summary>Used to group together voice paramters when requesting a token.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.BatchedSet`1">
            <summary>
            Batched queue which allows to process queued objects by batches of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/>.
            It should be provided with <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> which will perform fetching of new objects to the queue either incremental or with full re-fetch way.
            In case of full re-fetch it will replace current queue content with new data. For incremental fetch it will add fetched items to end of the queue.
            You can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/> separate or you can use <see cref="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)"/> which combines these two methods calls.
            This class isn't thread-safe!
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.FetchNextBatch(System.Boolean)">
            <summary> Combines call to <see cref="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)"/> and <see cref="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.GetNextBatch">
            <summary> Returns next batch of max size <see cref="F:Eco.Shared.Collections.BatchedSet`1.batchSize"/> from pre-fetched objects. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.BatchedSet`1.Fetch(System.Boolean)">
            <summary>
            Fetches data using <see cref="F:Eco.Shared.Collections.BatchedSet`1.fetcher"/> and adds it to end of the queue.
            If <paramref name="incremental"/> is <c>false</c> then it will clear the queue and replace it with fetched data.
            </summary>
        </member>
        <member name="T:Eco.Shared.Collections.EquatableArray`1">
            <summary>Equatable Array is a way to create equatable version of array which may be used as Dictionary key or for other hash/equals aware collections or operations.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.IScopeAwareEnumerable`1">
             <summary>
             Interface for scope aware enumerable. Some methods may not consume enumerable immediately and may want to save enumerable reference.
             In that case if enumerable isn't scoped then it may just save reference to enumerable otherwise it need to make a copy, because enumerable is only valid for the scope
             (i.e. it may be modified when leaves scope or use inside LINQ references to objects which may become invalid after leaving scope - disposed or replaced).
             This approach helps to safely pass enumerable to such methods with explicit scope control.
             Usually you should either assume enumerable unscoped and just save reference to it, in other cases it may be only valid in the scope and you need to copy it.
             You must follow rules to avoid problems and errors and most safe way is to always copy, but it is an expensive approach.
             But using <see cref="T:Eco.Shared.Collections.IScopeAwareEnumerable`1"/> you may explicitly say if enumerable is only valid within a scope and then decide if you need to copy it or not when want to save reference.
             This pattern inspired by C# 11 <c>scoped</c> keyword for references (https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters#scope-of-references-and-values).
             <example><code language="CSharp"><![CDATA[
             var l = new List<string> { "Hello", "World" };
             Call(l.Unscoped()); // error, because `l` modified outside of scope (Clear call bellow) and can't be considered valid if leaves scope inside Call method
             Call(l.Scoped());   // ok, if `l` have to leave scope inside of `Call` then it will be a copy of original list and won't be impacted by Clear call bellow
             l.Clear();
             Call(new List<string> { "Hello", "World" }.Unscoped());             // ok, because you don't have other references to List and it guaranteed to not be modified
             Call(Enumerable.Range(1, 10).Select(i => i.ToString()).Unscoped()); // ok, because this enumerable doesn't depend on any shared state and may be safely resolved outside of scope
             var db = new DB();
             Call(Enumerable.Range(1, 10).Select(i => db.GetString(i)).Unscoped()); // error, because this enumerable depends on `db` which then disposed and if enumerable leaves scope of Call method and we will try to use it later then it will fail with error trying to access `db` object
             db.Dispose();
            
             void Call(IScopedEnumerable<string> enumerable)
             {
                 IEnumerable<string> unscoped = enumerable.IsScoped ? enumerable.ToUnscopedCollection() : enumerable;
                 Task.Run(() => foreach (var item in unscoped) { Console.WriteLine(item); });
             }
             ]]></code></example>>
             </summary>
        </member>
        <member name="M:Eco.Shared.Collections.IScopeAwareEnumerable`1.ToUnscopedCollection">
            <summary>Returns unscoped collection which may be safely used outside of local scope. Makes defensive copy for scoped enumerable.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.LRUCache`2">
            <summary>
            Fixed size cache. When overflows then removes least-recently used (LRU) items.
            Significantly faster than classic LRU implementation on linked list (2.5 times on AddOrUpdate operation) and allocation free (0 bytes vs 72 000 bytes for 1000 inserts).
            </summary>
            <remarks>It isn't thread safe!</remarks>
        </member>
        <member name="P:Eco.Shared.Collections.LRUCache`2.Count">
            <summary>Number of cached items.</summary>
        </member>
        <member name="P:Eco.Shared.Collections.LRUCache`2.Keys">
            <summary>Collection of all keys used to store items in this cache.</summary>
        </member>
        <member name="P:Eco.Shared.Collections.LRUCache`2.Values">
            <summary>All cached items.</summary>
            <remarks>Accessing cached items via this property doesn't count as 'using' them in the context of how LRUCache works.</remarks>
        </member>
        <member name="M:Eco.Shared.Collections.LRUCache`2.TryGetValue(`0,`1@)">
            <summary>Tries to get cached <paramref name="value"/> by the <paramref name="key"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.LRUCache`2.AddOrUpdate(`0,`1)">
            <summary>Adds or updates cached <paramref name="value"/> by the <paramref name="key"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.LRUCache`2.Access(Eco.Shared.Collections.LRUCache{`0,`1}.Node@,System.Int32)">
            <summary>Access <paramref name="node"/> at <paramref name="index"/> to mark it more recently used. After access the node moves to the head and will be last node to remove (until another <see cref="M:Eco.Shared.Collections.LRUCache`2.Access(Eco.Shared.Collections.LRUCache{`0,`1}.Node@,System.Int32)"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Collections.LRUCache`2.Clear">
            <summary>Clears the cache.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.LRUCache`2.SetUpInsertOrder">
            <summary>Prepare cache for inserting new entries.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.LRUCache`2.Node">
            <summary>Node for cache array-based linked list.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1">
            <summary>
            RandomAccessQueue class is re-implementation of standard .NET Queue class, but with few additions for random access:
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Remove(`0)"/> allows to remove element from queue (for standard queue you can only remove first element with Dequeue)
            <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)"/> allows to add element at beginning of queue (not possible in standard queue).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds all <paramref name="newItems"/> to end of queue.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.RemoveAll``1(``0)">
            <summary>Removes all elements matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Enqueue(`0)">
            <summary>
            Add element to the end of queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.EnqueueFirst(`0)">
            <summary>
            Add element before first element in the queue.
            </summary>
            <param name="el">element to add.</param>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue">
            <summary>
            Remove and return first element from queue.
            </summary>
            <returns>First element in queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if queue is empty.</exception>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryDequeue(`0@)">
            <summary>
            Tries to <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Dequeue"/> element from queue. Safe version which returns <c>false</c> if no element instead of throwing exception.
            </summary>
            <param name="value">first element of queue if operation succeed, default value otherwise.</param>
            <returns><code>true</code> if element exists and outputted in <c>value</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.DequeueLast">
            <summary>
            Remove and return last element from queue.
            </summary>
            <returns>Last element in queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if queue is empty.</exception>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryDequeueLast(`0@)">
            <summary>
            Tries to <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.DequeueLast"/> element from queue. Safe version which returns <c>false</c> if no element instead of throwing exception.
            </summary>
            <param name="value">last element of queue if operation succeed, default value otherwise.</param>
            <returns><code>true</code> if element exists and outputted in <c>value</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryPeek(`0@)">
            <summary>Tries to Peek next element without dequeing it from the colletions.</summary>
            <returns><code>true</code> if collection is not empty, false otherwise</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryPeekLast(`0@)">
            <summary>Tries to Peek the last element without dequeing it from the colletions.</summary>
            <returns><code>true</code> if collection is not empty, false otherwise</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Contains(`0)">
            <summary>Performs search of given item in the collection.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Requeue">
            <summary>Requeue (take next element and put it back in the end of the queue) the next element and returns it</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Sort``1(``0)">
            <summary>Sorts queue with <paramref name="comparer"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryGetBuffer(System.ArraySegment{`0}@)">
            <summary>
            Tries to get queue buffer part with items (straighten it if needed to have contiguous array). The buffer only valid until next modification operation!
            May be used for optimized operations on whole array (i.e. modify every item and then sort).
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.TryGetBufferSpan(System.Span{`0}@)">
            <summary>
            Tries to get queue buffer part with items (straighten it if needed to have contiguous array). The buffer only valid until next modification operation!
            May be used for optimized operations on whole array (i.e. modify every item and then sort).
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.StraightenUnchecked">
            <summary>Straighten queue way when it have <see cref="F:Eco.Shared.Collections.RandomAccessQueue`1.head"/> before <see cref="F:Eco.Shared.Collections.RandomAccessQueue`1.tail"/> (unwrapped). Useful when we need to process all items at once by array/span function (like Sort).</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.IndexOf``1(``0)">
            <summary>Helper function. Returns fist of queue element matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.CutTail(System.Int32)">
            <summary>Cuts tail <paramref name="fromIndex"/> and sets new tail.</summary>
            <returns>Count of cut items.</returns>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.CountTrailingAndClearIfNeeded(System.Int32)">
            <summary>
            Clears trailing elements <paramref name="fromIndex"/> if needed (only for elements with managed references to release resources for GC) and returns number of trailing elements.
            Utility method for <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.CutTail(System.Int32)"/> and <see cref="M:Eco.Shared.Collections.RandomAccessQueue`1.Clear"/> methods.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.RandomAccessQueue`1.Reverse">
            <summary>Zero allocation and much faster alternative to <see cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1.ReverseEnumerable">
            <summary>Reverse view of <see cref="T:Eco.Shared.Collections.RandomAccessQueue`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.RandomAccessQueue`1.ReverseEnumerator">
            <summary>Reverse enumerator of <see cref="T:Eco.Shared.Collections.RandomAccessQueue`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.ScopedEnumerable`1">
            <summary>Implementation of <see cref="T:Eco.Shared.Collections.IScopeAwareEnumerable`1"/> for scoped enumerable. Scoped enumerable can't be safely referenced outside of current method scope and have to make defensive copy in such cases.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.ScopedEnumerableExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Collections.ScopedEnumerable`1"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ScopedEnumerableExtensions.Scoped``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Represents <paramref name="enumerable"/> as owned for methods with ownership awareness. If these methods need to save enumerable content they have to use <see cref="M:Eco.Shared.Collections.IScopeAwareEnumerable`1.ToUnscopedCollection"/> to make defensive copy.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.SingleValueOrList`1">
            <summary>
            Special kind of "collection" which may be either single value or list of values. May be useful when in most cases you have just a single value and in rare cases it may be a list.
            When it is a single value of reference type then there no allocations (but for value types there will be boxing).
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SingleValueOrList`1.AsList">
            <summary>Converts <see cref="T:Eco.Shared.Collections.SingleValueOrList`1"/> to list (if it wasn't).</summary>
        </member>
        <member name="T:Eco.Shared.Collections.SpinLockBuffer`1">
            <summary>
            A buffer that uses a SpinLock for locking
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.Add(`0)">
            <summary>
            Add an item to the internal buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.FlushTo(System.Collections.Generic.List{`0})">
            <summary>
            Copy the contents to the given list then clear the internal buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.FlushTo(Eco.Shared.Pools.Collections.PoolableListWrapper{`0})">
            <summary>
            Copy the contents to the given list then clear the internal buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.FlushTo(System.Collections.Generic.Queue{`0})">
            <summary>
            Copy the contents to the given queue then clear the internal buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.FlushTo(System.Collections.Generic.HashSet{`0})">
            <summary>
            Copy the contents to the given set then clear the internal buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.FlushToSnapshotAndPromiseToReturn(System.Collections.Generic.List{`0}@)">
            <summary>
            Flushes buffer content and outputs it as <paramref name="snapshot"/>.
            Returns a promise which should be disposed to return <paramref name="snapshot"/> back to pool.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.GetSnapshotAndClear">
            <summary>Returns snapshot of buffer and clears it.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockBuffer`1.Clear">
            <summary>
            Clear the internal buffer.
            </summary>
        </member>
        <member name="T:Eco.Shared.Collections.SpinLockUniqueBuffer`1">
            <summary>
            Unique thread-safe buffer for cases when multiple copies of same item may be added.
            It is optimized for scenarios with one or more producers and a single consumer.
            In such cases buffer returned from <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Flush"/> may be returned with <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.ReturnSet(System.Collections.Generic.HashSet{`0})"/> and reused (avoiding allocations).
            If multiple <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.ReturnSet(System.Collections.Generic.HashSet{`0})"/> used then it will only use first buffer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Add(`0)">
            <summary>Add an <paramref name="item"/> to buffer.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Remove(`0)">
            <summary>Remove an item from buffer.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Flush">
            <summary>Flushes buffer as set (which may be null if buffer is empty).</summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.ReturnSet(System.Collections.Generic.HashSet{`0})">
            <summary>Returns a set flushed with <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Flush"/> for reusing.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.FlushAndPromiseToReturn(System.Collections.Generic.HashSet{`0}@)">
            <summary>Same as <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.Flush"/> and then <see cref="M:Eco.Shared.Collections.SpinLockUniqueBuffer`1.ReturnSet(System.Collections.Generic.HashSet{`0})"/> when promise disposed.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.SpinLockUniqueBuffer`1.ReturnPromise">
            <summary>Flushed buffer return promise for disposable patterns.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.ThreadSafeLRUCache`2">
            <summary>Thread safe version of <see cref="T:Eco.Shared.Collections.LRUCache`2"/>.</summary>
            <remarks>This is a very simple implementation based on a lock that synchronizes all access to the internal cache.</remarks>
        </member>
        <member name="P:Eco.Shared.Collections.ThreadSafeLRUCache`2.Count">
            <summary>Number of cached items.</summary>
        </member>
        <member name="P:Eco.Shared.Collections.ThreadSafeLRUCache`2.Keys">
            <summary>List of all keys used to store items in this cache.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ThreadSafeLRUCache`2.TryGetValue(`0,`1@)">
            <summary>Tries to get cached <paramref name="value"/> by the <paramref name="key"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ThreadSafeLRUCache`2.AddOrUpdate(`0,`1)">
            <summary>Adds or updates cached <paramref name="value"/> by the <paramref name="key"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ThreadSafeLRUCache`2.Clear">
            <summary>Clears the cache.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ThreadSafeLRUCache`2.GetMatchingEntries(System.Func{`0,System.Boolean},System.Func{`1,System.Boolean})">
            <summary>Finds all entries where key and value match specified criteria.</summary>
            <param name="keyMatch">Function that receives key and returns true if it matches the search criteria.</param>
            <param name="valueMatch">Function that receives value and returns true if it matches the search criteria.</param>
        </member>
        <member name="T:Eco.Shared.Collections.UnboundedSPSCQueue`1">
            <summary>
            Unbounded Single Producer Single Consumer Queue.
            </summary>
            <remarks>
            It is safe to use in multi-threaded environment as long as only one thread is consuming and only one thead is producing.
            It may lead to unpredictable results otherwise.
            </remarks>
        </member>
        <member name="T:Eco.Shared.Collections.UniqueQueue`1">
            <summary>Thread-unsafe Unique Queue implementation. It only allows enqueueing unique elements. Duplicate elements are ignored.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueQueue`1.TryEnqueue(`0)">
            <summary>Enqueue new item. Item is ignored if already present in queue, and method returns false if that is the case.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.UniqueStack`1">
            <summary> Thread-unsafe Unique Stack implementation. It only allows to put unique elements. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.Push(`0)">
            <summary> Push new item . Item ignored if already present in stack and method returns false in this case. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.TryPop(`0@)">
            <summary> Tries to pop item from the stack (if any). Returns <c>true</c> and item output parameter, <c>false</c> otherwise. </summary>
        </member>
        <member name="M:Eco.Shared.Collections.UniqueStack`1.Clear">
            <summary> Clears whole stack. </summary>
        </member>
        <member name="T:Eco.Shared.Collections.UnscopedEnumerable`1">
            <summary>Implementation of <see cref="T:Eco.Shared.Collections.IScopeAwareEnumerable`1"/> for unscoped collection. Unscoped enumerable may be safely used outside of method scope (i.e. when you need to save reference to it for future usage) and don't need to make defensive copy in such cases.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.UnscopedEnumerableExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Collections.UnscopedEnumerable`1"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Collections.UnscopedEnumerableExtensions.Unscoped``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Represents <paramref name="collection"/> as unscoped for methods with scope awareness.</summary>
        </member>
        <member name="T:Eco.Shared.Comparers.FuncBasedEqualityComparer`1">
            <summary><see cref="T:System.Collections.Generic.IEqualityComparer`1"/> based on provided equality and hash functions. Useful when API only supports <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>, but you want to use lambda functions.</summary>
        </member>
        <member name="T:Eco.Shared.Comparers.ReferenceEqualityComparer">
            <summary><see cref="T:Eco.Shared.Comparers.ReferenceEqualityComparer"/> compares objects by reference.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.ConcurrentFlag">
            <summary>
            This class is implementation of thread-safe flag which can be atomically set to <c>true</c> with <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet"/> method.
            Once set the owning thread is responsible for call to <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.Reset"/> method with returns value to <c>false</c> if needed.
            If this flag used as publicly available property then ensure it exposed as <c>ref ConcurrentFlag Flag => ref this.flag</c> to avoid accidental struct copy
            (in this case it will modify state of copy, not of the original flag).
            </summary>
            <example>
            Typical usage is following:
            <code>
            ConcurrentFlag doingSomething;
            void DoSomething()
            {
                if (!doingSomething.TrySet())
                    return;
                Something();
                doingSomething.Reset();
            }
            </code>
            It is replacement for boolean flag, but with thread-safety support. Equivalent non thread-safe code will look like:
            <code>
            bool doingSomething;
            void DoSomething()
            {
                if (!doingSomething)
                    return;
                doingSomething = true;  // for multi-thread this flag may be already set by another thread here even if it wasn't in previous condition check
                Something();
                doingSomething = false;
            }
            </code>
            </example>
        </member>
        <member name="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet">
            <summary>Tries atomically set flag. If this flag already set by another thread then the method returns <c>false</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ConcurrentFlag.Reset">
            <summary>Resets flag to not set state. Should be called after successful <see cref="M:Eco.Shared.Concurrent.ConcurrentFlag.TrySet"/> method if needed to make this flag available to be set again.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphore">
            <summary>
            Very lightweight semaphore-like synchronization object based on <see cref="T:System.Threading.SpinWait"/>.
            It optimized for very-short write operations and concurrent read operations (short enough). It may spent lot of CPU cycles if you don't follow this rule.
            To achieve this internal state maintained which may be (-1 - for write operation in progress, 0 - for no operations, positive - for read operations). When positive it is equal to number of active read operations.
            <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.WaitWrite"/> should be used for write operations and it will await when <see cref="F:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.state"/> is 0 to switch state to -1. When write operation finished <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.ReleaseWrite"/> should be used to allow other write and read operations.
            <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.WaitRead"/> should be used for read operations and it will await until <see cref="F:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.state"/> is greater or equal to 0 (no write operations in progress) and then increases state value. When read operation finished <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.ReleaseRead"/> should be used to allow write operations.
            WARNING! Because this is a struct you should never ever copy it and always as an class field only. Read more in <see cref="T:System.Threading.SpinLock"/> documentation (https://docs.microsoft.com/en-us/dotnet/api/System.Threading.SpinLock?view=net-7.0).
            </summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.WaitRead">
            <summary>Waits for Read operation availability and modifies state to prevent concurrent write operations.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.ReleaseRead">
            <summary>Releases active Read operation. All Read operations should be released before any Write operation may start.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.WaitWrite">
            <summary>Waits for Write operation availability and modifies state to prevent other write and read operations.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphore.ReleaseWrite">
            <summary>Releases active Write operation. No other operation may happen until Write released.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions">
            <summary>Set of extension methods for <see cref="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphore"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.DisposableRead(Eco.Shared.Concurrent.ReadWriteSpinSemaphore@)">
            <summary>May be used to perform disposable Read operation (between the method call and Dispose of method result).</summary>
            <code><![CDATA[
            using (semaphore.DisposableRead())
                DoReadOperation();
            ]]></code>
        </member>
        <member name="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.DisposableWrite(Eco.Shared.Concurrent.ReadWriteSpinSemaphore@)">
            <summary>May be used to perform disposable Write operation (between the method call and Dispose of method result).</summary>
            <code><![CDATA[
            using (semaphore.DisposableWrite())
                DoWriteOperation();
            ]]></code>
        </member>
        <member name="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.ReadWriteSpinSemaphoreRead">
            <summary>Disposable Read operation for <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.DisposableRead(Eco.Shared.Concurrent.ReadWriteSpinSemaphore@)"/> method.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.ReadWriteSpinSemaphoreWrite">
            <summary>Disposable Write operation for <see cref="M:Eco.Shared.Concurrent.ReadWriteSpinSemaphoreExtensions.DisposableWrite(Eco.Shared.Concurrent.ReadWriteSpinSemaphore@)"/> method.</summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.SpinLockSection">
            <summary>
            Helper struct to avoid boilerplate with <see cref="T:System.Threading.SpinLock"/>. Only available for .NET 7.0+ and C# 11+.
            Normally you need to use following code:
            <code><![CDATA[
            bool lockTaken = false;
            try
            {
                spinLock.Enter(ref lockTaken);
                DoWithLock();
            }
            finally
            {
                if (lockTaken)
                    spinLock.Exit();
            }
            ]]></code>
            but using <see cref="T:Eco.Shared.Concurrent.SpinLockSection"/> can simplify to
            <code><![CDATA[
            using (spinLock.EnterDisposableLock())
                DoWithLock();
            ]]></code>
            </summary>
        </member>
        <member name="T:Eco.Shared.Concurrent.SpinLockSectionExtensions">
            <summary>Extension methods set for <see cref="T:Eco.Shared.Concurrent.SpinLockSection"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Debugging.ActionDebugger.DebugObjectActionWithReplayOnFail``1(``0,System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>
            Debugs object action with state snapshot before operation and if operation fails <paramref name="isValid"/> check then resets state before the operation and replays it for debugging.
            It may be useful when some complex operation changes object and puts it into invalid state. You may catch such case with validation check and then be
            able to execute same code in debug mode on unmodified object state.
            <example><code><![CDATA[
            chunks?.DebugObjectActionWithReplayOnFail(q => this.RemoveDeliveriesFromQueues(this.chunkQueues, command.Client, chunkColumns), q => q.All(x => x.Chunk != null!));
            ]]></code></example>
            </summary>
        </member>
        <member name="T:Eco.Shared.Debugging.IStateSnapshotSupport">
            <summary>
            Interface which may be used for debugging object state changes (i.e. with <see cref="M:Eco.Shared.Debugging.ActionDebugger.DebugObjectActionWithReplayOnFail``1(``0,System.Action{``0},System.Func{``0,System.Boolean})"/>.
            Object implementing the interface provides access to it's internal state via snapshots.
            </summary>
        </member>
        <member name="T:Eco.Shared.Extensions.ReadOnlySpanExtensions">
            <summary>Set of extension methods for <see cref="T:System.ReadOnlySpan`1"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Extensions.ReadOnlySpanExtensions.ToSet``1(System.ReadOnlySpan{``0})">
            <summary>Returns new <see cref="T:System.Collections.Generic.HashSet`1"/> containing all items from <paramref name="span"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Extensions.ReadOnlySpanExtensions.ToList``1(System.ReadOnlySpan{``0})">
            <summary>Returns new <see cref="T:System.Collections.Generic.List`1"/> containing all items from <paramref name="span"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Gameplay.RadPoint.Covers(Eco.Shared.Math.Vector2)">
            <summary>Returns true if this position is within the range of this point.</summary>
        </member>
        <member name="T:Eco.Shared.Gameplay.EditableOverlay">
            Basic implementation for IEntryOverlay. Used to sent/recieve data at map edit request.
            Note that this type is not a controller, but will be sent back and forth between both client and server, IE the client can edit it and send it back.
            For example, when a user requests to edit an overlay, the client will send this structure to the server after the edit, containing the changes. 
        </member>
        <member name="T:Eco.Shared.Gameplay.IListEntryObject">
            <summary> Used for objects that can be represented on client by ListEntry, to populate AutoUIListContainer. </summary>
        </member>
        <member name="M:Eco.Shared.Gameplay.Maps.PlotMapUtil.AssignDetectChanges``1(Eco.Shared.Utils.Array2D{``0},System.Func{Eco.Shared.Voxel.PlotPos,``0})">
            <summary>Assign values to the map using the given function, and return a list of any positions that were changed.</summary>
        </member>
        <member name="T:Eco.Shared.Gameplay.AvatarCustomizationData">
            <summary> Customization data for a player's avatar. Used to set up starting appearance. </summary>
            <remarks> Created by the player from the client and sent to the server on first Login.  </remarks>
        </member>
        <member name="T:Eco.Shared.Gameplay.AvatarSlotData">
            <summary> Data that represents an avatar's appearance slot. </summary>
            <remarks> Is consisted by the name and the color of the equipped item. </remarks>
        </member>
        <member name="P:Eco.Shared.Gameplay.AvatarSlotData.Name">
            <summary> For Client, this is the name of the asset, while for Server this is the item's Type. </summary>
            <remarks> Can be null or empty if the slot isn't filled. </remarks>
        </member>
        <member name="T:Eco.Shared.Gameplay.AvatarAppearanceSlots">
            <summary> Pretty much an enum, but with a property that returns all slots in a list. </summary>
        </member>
        <member name="T:Eco.Shared.Icons.HasEnumIconsAttribute">
            <summary>Use this attribute to mark an Enum if every name in it should be used as an Icon. E.g. <see cref="T:Eco.Shared.Icons.IconUtils.SymbolicIcons"/>. They will respectively appear in the Icon Scene with the Enum name or GroupName category.</summary>
        </member>
        <member name="T:Eco.Shared.Icons.IconUtils">
            <summary>Various shared things related to icons</summary>
        </member>
        <member name="T:Eco.Shared.Icons.IHasRequiredIcons">
            <summary>Use this interface if your class has any icons which are not exist as separate objects.
            E.g. achievements are stored in manager but we still need to make icons for them, so we tell that we want icons for all achievement through AchievementManager by adding this interface.
            After that we can create a list of icons we want to have from this class and also you can provide a nice category name with IconsCategoryName (that will make life easier for the Art Team as Icon scene will have this category name).</summary>
        </member>
        <member name="F:Eco.Shared.IoC.ServiceHolder`1.Obj">
            <summary>Service's current singleton instance.</summary>
        </member>
        <member name="M:Eco.Shared.IoC.ServiceHolder`1.CreateAndReplace``1">
            <summary> Creates new instance of <typeparamref name="TImpl"/> and replaces <see cref="F:Eco.Shared.IoC.ServiceHolder`1.Obj"/> with new value.</summary>
        </member>
        <member name="M:Eco.Shared.IoC.ServiceHolder`1.GetOrCreate``1">
            <summary>Gets existing instance of service or if not set then creates new instance of <typeparamref name="TImpl"/> type and sets it.</summary>
        </member>
        <member name="M:Eco.Shared.IoC.ServiceHolder`1.SetOrReplace``1(``0)">
            <summary>Sets or replaces an existing instance of service with a new value.</summary>
        </member>
        <member name="T:Eco.Shared.Items.InteractionInfo">
            <summary> Information about an interaction, calculated on the client. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.ID">
            <summary> ID used to rewind bad predictions. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Method">
            <summary> Method used to start the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Modifier">
            <summary> Any modifier key held down while triggering the interaction. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.TargetObject">
            <summary> The object being interacted with, if set. If this is set BlockPosition will be null. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.BlockPosition">
            <summary> The targeted block, if set. Will not be set at the same time as TargetObject. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Parameters">
            <summary> Custom interaction parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Distance">
            <summary> Distance to the interaction target. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.IsAirInteraction">
            <summary>Interact without a target is considered air interaction aka dropping block off a cliff. When true, Block Position is the position down the cliff.</summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Position">
            <summary> When TargetObject is not null, the position the interaction ray intersected with the target object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.Normal">
            <summary> The facing direction of the side of the selected block. This is the side any placed block will be. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionInfo.FacingDirection">
            <summary> The facing direction of the player when performing the action. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.TargetObject">
            <summary> Target object, if set. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.HitPosition">
            <summary> If TargetObject is set, the position the ray interacted with the object. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.Parameters">
            <summary> Custom parameters. </summary>
        </member>
        <member name="P:Eco.Shared.Items.InteractionQueryInfo.BlockPosition">
            <summary> The targeted blocks position, if TargetObject is not set. </summary>
        </member>
        <member name="T:Eco.Shared.Items.CacheAs">
            <summary>Defines different caching modes tooltip part can use.</summary>
        </member>
        <member name="F:Eco.Shared.Items.CacheAs.Disabled">
            <summary>Disable caching for tooltip part entirely (on server and on client).</summary>
            <remarks>When this flag is set all other flags should not be used.</remarks>
        </member>
        <member name="F:Eco.Shared.Items.CacheAs.Instance">
            <summary>Cache tooltip part for every instance of a type individually.</summary>
            <remarks>Can be combined with <see cref="F:Eco.Shared.Items.CacheAs.User"/> flag to also disable server-side cache.</remarks>
        </member>
        <member name="F:Eco.Shared.Items.CacheAs.User">
            <summary>Cache tooltip part for every user individually.</summary>
            <remarks>Disables caching for tooltip part on server causing it to only be cached on client.</remarks>
        </member>
        <member name="F:Eco.Shared.Items.CacheAs.Global">
            <summary>Create only one cache entry for tooltip part and use it for all instances and users.</summary>
            <remarks>When this flag is set all other flags should not be used.</remarks>
        </member>
        <member name="F:Eco.Shared.Items.CacheAs.SubType">
            <summary>Create separate cache entry for every type derived from the type that defines tooltip part and share those entries among instances of their respective types.</summary>
            <remarks>Can be combined with <see cref="F:Eco.Shared.Items.CacheAs.User"/> flag to also disable server-side cache. Can not be used with instance members or for extension methods.</remarks>
        </member>
        <member name="T:Eco.Shared.Items.SettlementType">
            <summary>Wrapper for working with SettlementType Tier, provides easy access methods like getting children/parents and Display name</summary>
        </member>
        <member name="P:Eco.Shared.Items.SettlementType.All">
            <summary>Returns each settlement type available.</summary>
        </member>
        <member name="P:Eco.Shared.Items.SettlementType.DisplayName">
            <Returns>Localized name taken from SettlementConfig.SettlementTypes based on the Tier</Returns>
        </member>
        <member name="M:Eco.Shared.Items.SettlementType.GetChild">
            <Returns>SettlementType of 1 tier lower if this settlement can have a child settlement I.E is not of first tier, otherwise null</Returns>
        </member>
        <member name="M:Eco.Shared.Items.SettlementType.GetParent">
            <Returns>SettlementType of 1 tier higher if this settlement can have parent settlement I.E is not of final tier, otherwise null</Returns>
        </member>
        <member name="T:Eco.Shared.Items.InitialData">
            <summary>Container for various data types that can be retrieved from the client on user login, managed by CachedPlayerDataUtil.cs on client</summary>
        </member>
        <member name="T:Eco.Shared.Items.TooltipPartCacheKey">
            <summary>
            Servers as a key for lookup in tooltip part cache on both server and client.
            Given this key, cached content of a tooltip part can be retrieved from cache, if it is present.
            </summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipPartCacheKey.PartId">
            <summary>ControllerID of tooltip part.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipPartCacheKey.ViewId">
            <summary>ControllerID of view for which tooltip part content was generated or 0, depending on the cache mode used.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipPartCacheKey.Origin">
            <summary><see cref="T:Eco.Shared.Items.TooltipOrigin"/> for which tooltip part content was generated.</summary>
        </member>
        <member name="M:Eco.Shared.Items.TooltipPartCacheKey.#ctor(System.Int32,System.Int32,Eco.Shared.Items.TooltipOrigin)">
            <param name="partId">ControllerID of tooltip part.</param>
            <param name="viewId">ControllerID of view for which tooltip part content was generated or 0, depending on the cache mode used.</param>
            <param name="origin"><see cref="T:Eco.Shared.Items.TooltipOrigin"/> for which tooltip part content was generated.></param>
        </member>
        <member name="M:Eco.Shared.Items.TooltipPartCacheKey.#ctor(System.Int32,System.Int32,Eco.Shared.Items.TooltipOrigin,Eco.Shared.Items.CacheAs)">
            <summary>Same as <see cref="M:Eco.Shared.Items.TooltipPartCacheKey.#ctor(System.Int32,System.Int32,Eco.Shared.Items.TooltipOrigin)"/>, but checks cache mode first to determine if viewId should be replaced with 0.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TooltipPartServerRequest">
            <summary>Represents a request for a single tooltip part's content.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TooltipServerRequest">
            <summary>Represents a request for contents of several tooltip parts.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerRequest.MainTargetControllerID">
            <summary>If request is sent because tooltip is being opened for some specific view this should contain this view's ControllerID. Otherwise should be 0.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerRequest.MainTargetTypeID">
            <summary>If request is sent because tooltip is being opened for some specific view this should contain this view type's ID. Otherwise should be 0.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerRequest.PartRequests">
            <summary>Requests for specific tooltip parts.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TooltipServerResponse">
            <summary>Packs data server sends to client in response to <see cref="T:Eco.Shared.Items.TooltipServerRequest"/></summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerResponse.ErrorTitle">
            <summary>If tooltip content can't be generated this error should be displayed as title instead.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerResponse.ErrorMessage">
            <summary>If tooltip content can't be generated this error message should be displayed as tooltip content instead.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerResponse.Parts">
            <summary>IDs and contents of requested tooltip parts.</summary>
        </member>
        <member name="F:Eco.Shared.Items.TooltipServerResponse.ChildrenParts">
            <summary></summary>
        </member>
        <member name="P:Eco.Shared.Items.TooltipServerResponse.IsSuccess">
            <summary>Returns false if tooltip content couldn't be generated.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TooltipPartData">
            <summary>Represents tooltip part with its content for specific instance.</summary>
            <remarks>Origin used to generate content should be inferred from context.</remarks>
        </member>
        <member name="T:Eco.Shared.Items.TooltipChildrenPartData">
            <summary>Represents tooltip children part with contained children for specific instance.</summary>
            <remarks>Origin used to get children should be inferred from context.</remarks>
        </member>
        <member name="T:Eco.Shared.Items.TTCat">
            <summary>Categories of tooltips.</summary>
        </member>
        <member name="T:Eco.Shared.Items.ButtonFlags">
            <summary>Flags for defining a button state in the UI.</summary>
        </member>
        <member name="M:Eco.Shared.Items.ContractStateExtensions.MarkedUpName(Eco.Shared.Items.ProposableState)">
            <summary>Return the state's localized name with some nice coloring.</summary>
        </member>
        <member name="T:Eco.Shared.Items.TutorialFlag">
            <summary> Shared with the client to indicate when an RPCs (tutorial related) is needed </summary>
        </member>
        <member name="T:Eco.Shared.Items.SimpleResult">
            <summary>Simple results from a vote.</summary>
        </member>
        <member name="T:Eco.Shared.Items.AvatarGender">
            <summary>Helps avoid tracking gender via strings</summary>
        </member>
        <member name="T:Eco.Shared.Localization.ConstLocs.ConstLocalizationAttribute">
            <summary>Attribute to signal for localization parser to extract const strings from class to be localized</summary>
        </member>
        <member name="T:Eco.Shared.Localization.FormattableStringExtensions">
            <summary>Extensions for <see cref="T:System.FormattableString"/> related to localization.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.FormattableStringExtensions.CanBeInlined(System.FormattableString)">
            <summary>Checks if <paramref name="fs"/> can be inlined (resolved to string without information lose). It may be inlined if all arguments can be inlined.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.FormattableStringExtensions.CanInlineAsArg(System.Object)">
            <summary>Checks if <paramref name="arg"/> may be inlined (resolved to string without information lose). <see cref="T:Eco.Shared.Localization.LocString"/> may be inlined if it wraps non-localized string, other types assumed to be inlinable.</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocalizationExtractionUtils">
            <summary>Utils for localization string extractions</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.TypesToExtract(System.Boolean)">
            <summary>Localization types to extract loc strings from</summary>
            <param name="excludeShared">Ignore shared namespace (so it doesn't get extracted twice)</param>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.ExtractLocalizedAttr(System.Type,System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData},Eco.Shared.Localization.LocalizedAttribute,System.Boolean)">
            <summary>Extract localization strings from classes or enums with <see cref="T:Eco.Shared.Localization.LocalizedAttribute"/></summary>
            From classes will extract properties and/or fields
            From enums will extract
            <param name="type">type with attribute</param>
            <param name="locData">list to add new localization data</param>
            <param name="localizedAttr">actual attribute</param>
            <param name="includeFields">should also include fields</param>
        </member>
        <member name="M:Eco.Shared.Localization.LocalizationExtractionUtils.GetTypeLocName(System.Type,Eco.Shared.Localization.LocalizedAttribute)">
            <summary>Extract loc display name of type from <see cref="P:Eco.Shared.Localization.LocalizedAttribute.CustomDisplayName"/> or RemoveCamelCase</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocalizedEnumConverter">
            <summary>
            Used to enable localized enum values in PropertyGrids.
            Can also be manually added to any enum to override the default behaviour when casting to a string.
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.PrependLocStr(System.String,Eco.Shared.Localization.LocString)">
            <summary>Localize a string as a prepend, then display the rest after a ':'. Ex: PrependLocStr("Room", room.Info) will return Localized "Room: {room.Info}" </summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.DoLineListLoc(System.FormattableString[])">
            <summary>Accepts a variable number of formattable strings, localzing them as lines and appending them.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.DoLineListLocStr(System.String[])">
            <summary>Accepts a variable number of formattable strings, localzing them as lines and appending them.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.DoLineList(Eco.Shared.Localization.LocString[])">
            <summary>Append a bunch of locstring together into a new locstring</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.StyledPluralUnsigned(System.String,System.Single)">
            <summary> Styles originally negative numbers in red (negative style) while removing the negative sign from the output.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.PluralNoNum(System.String,System.Single)">
            <summary>Pluralize when a float is involved.  IE, 1.0 should be 'not plural', 1.1 should be 'plural</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.A(Eco.Shared.Localization.LocString,System.Boolean)">
            <summary>Adds a/an based on the first letter of the given string, the given word shouldn't include tags.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.A_strip(Eco.Shared.Localization.LocString)">
            <summary>Adds a/an based on the first letter of the given string, safely excuted and strips tags if any.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.InitializeLanguage(Eco.Shared.Localization.SupportedLanguage)">
            <summary>Sets initial localizer language and invoke post initialize actions</summary>
            For things that get setup before localization, but must wait for localizer correct language
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.OnInitialized(System.Action)">
            <summary>Call action after initialization or instantly when already initialized</summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.AddIndefiniteArticle(Eco.Shared.Localization.LocString)">
            <summary> Adds "a" or "an" to the phrase depending on some common English rules E.g a user, an item </summary>
        </member>
        <member name="M:Eco.Shared.Localization.Localizer.GetIndefiniteArticle(System.String)">
            <summary> Returns "a" or "an" depending on some common English rules</summary>
        </member>
        <member name="M:Eco.Shared.Localization.TextLoc.ControlsLoc(System.String,System.String,System.String)">
            <summary>Creates <see cref="T:Eco.Shared.Localization.LocString"/> from <paramref name="text"/> surrounded with <paramref name="prefix"/> and <paramref name="suffix"/>. I.e. <c>ControlsLoc($"Click {buttonName}", "[", "]")</c> same as <c>Localizer.Do("Click {buttonName}").Wrap("[", "]").Style(Text.Styles.Controls)</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.TextLoc.ControlsLocStr(System.String,System.String,System.String)">
            <summary>Creates <see cref="T:Eco.Shared.Localization.LocString"/> from <paramref name="text"/> surrounded with <paramref name="prefix"/> and <paramref name="suffix"/>. I.e. <c>ControlsLocStr("Click here", "[", "]")</c> same as <c>Localizer.DoStr("Click here").Wrap("[", "]").Style(Text.Styles.Controls)</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.TextLoc.Table(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString}})">
            <summary> Creates localized text table with tags from 2D LocString IEnumerable </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.MutualTag(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Collections.Generic.HashSet{System.String})">
            <summary> Searches for the rarest tag that is present in every selected element. Can also determine if all elements of this tag have been selected. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionLoc.DescribeViews(System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.HashSet{System.String},System.String)">
            <summary> Tries to combine entries into groups. See SearchableListUI.UpdateSlots on the client side for a demo. </summary> // Handy converter for the client side.
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTags(Eco.Shared.View.ViewClassInfo)">
            <summary> Gets ViewClassInfo's display name and tags. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.DescriptionExtensinons.GetNamesAndTagsFromViews(System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Gets display name and tags of every ViewClassInfo in the collection. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocDescriptionCloneAttribute">
            <summary> Clones <see cref="T:Eco.Shared.Localization.LocDescriptionAttribute"/> of the provided property. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDescriptionAttribute.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.NotLocalizedDisplayNameAttribute">
            <summary>
            The standard DisplayNameAttribute doesn't support Enums + other types, so this is a useful extension.
            </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.LocDescription">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocCategoryDescription.Description">
            <summary> Localized description. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.LocDisplayName">
            <summary> Non-resolved <see cref="T:Eco.Shared.Localization.LocString"/> value for the display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.Name">
            <summary> Not localized display name. </summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocDisplayNameAttribute.DisplayName">
            <summary> Localized display name. </summary>
        </member>
        <member name="T:Eco.Shared.Localization.AutoContextCommentAttribute">
             <summary>
             Add context comment to Classes, Fields, Properties and Enums auto-localized via <see cref="T:Eco.Shared.Networking.EcoAttribute"/> or <see cref="T:Eco.Shared.Localization.LocalizedAttribute"/>
             e.g.:
             [Localized] class Player
             {
                 [AutoContextComment("Player Configuration")]
                 public Setting  Config { get; set; }
             }
            
             will extract "Config" loc string with context 'Player Configuration'
            
             </summary>
        </member>
        <member name="T:Eco.Shared.Localization.ContextCommentAttribute">
             <summary>
             For Classes, Fields, Properties, Methods and Enums to localize other attribute parameters
             e.g.:
             [Eco, LocDescription("Some description"), ContextComment(typeof(LocDescriptionAttribute), "Some description context")]
             public class CivicAction_AddElement
             {
                 [AutoContextComment("Player Configuration")]
                 public Setting  Config { get; set; }
             }
            
             will extract "Some description" loc string with context 'Some description context'
            
             </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayName(System.Enum,System.Boolean,System.Boolean)">
            <summary>Get FOLDOUT Loc Display name of an Enum value. If that value has `LocDisplayNameAttribute` then use that instead of the Value's name. If that value has `LocDescriptionAttribute` then do foldout with the description.</summary>
            should be renamed to GetFoldoutDisplayName, but it has too many references
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetEnumLocDisplayName(System.Enum)">
            <summary>Get only Loc Display name from localized Enum</summary>
            aware of <see cref="T:Eco.Shared.Localization.LocDisplayNameAttribute"/>, <see cref="T:Eco.Shared.Localization.NotLocalizedDisplayNameAttribute"/>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayName(System.Reflection.MemberInfo)">
            <summary> Get a localized display name, using the the defined LocDisplayName attribute, or if that's missing, by localizing the 'remove camel case' of the name.</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.GetLocDisplayNameColored(System.Reflection.MemberInfo)">
            <summary> Get the display name and query the color of this property from the Color attribute and apply it.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.InsertLineLoc(Eco.Shared.Localization.LocStringBuilder,System.FormattableString)">
            <summary> Inserts the line at the beginning of the builder. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.CropUntilLengthIfNeeded(Eco.Shared.Localization.LocStringBuilder,System.Int32)">
            <summary>Crops LocStringBuilder to given maxLength.</summary>
            <remarks>If the LocString is shorter than maxLength returns same LocString.</remarks>
        </member>
        <member name="M:Eco.Shared.Localization.LocExtensions.AppendStringWhileRespectingMaxLength(Eco.Shared.Localization.LocStringBuilder,Eco.Shared.Localization.LocString,System.Int32,System.Boolean)">
            <summary>Append a LocString respecting length limit.</summary>
            <remarks>Crops first LocString if the length exceeds limit and appends second.
            Has an option to include space in between.</remarks>
        </member>
        <member name="P:Eco.Shared.Localization.LocString.NotTranslated">
            <summary>Returns not translated string. If <see cref="T:System.FormattableString"/> was used then it will be resolved to string.</summary>
        </member>
        <member name="P:Eco.Shared.Localization.LocString.Inlinable">
            <summary>Checks if <see cref="T:Eco.Shared.Localization.LocString"/> may be inlined (resolved to string without information lose). It is <c>true</c> if the LocString shouldn't be localized and wraps string.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocString.TryGetInlineValue(System.String@)">
            <summary>If the loc string is <see cref="P:Eco.Shared.Localization.LocString.Inlinable"/> then returns inline value which then may be used for result string building.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.AppendArgument(System.Object)">
            <summary>Adds <paramref name="value"/> as argument to <see cref="T:Eco.Shared.Localization.LocStringBuilder"/>. If there at least one argument then <see cref="T:System.FormattableString"/> will be used.</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.Append(Eco.Shared.Localization.LocString)">
            <summary>
            Appends <paramref name="value"/> to <see cref="T:Eco.Shared.Localization.LocStringBuilder"/>. Behavior depends on the <paramref name="value"/>.
            If value is not localized and is plain string then it will just be added to format, but otherwise it will be added as argument.
            </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.Append(System.String)">
            <summary>Appends <paramref name="value"/> "as is".</summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.TrimFormat">
            <summary> Trims format string. </summary>
        </member>
        <member name="M:Eco.Shared.Localization.LocStringBuilder.ToLocString">
            <summary>Produces <see cref="T:Eco.Shared.Localization.LocString"/> from appended content.</summary>
        </member>
        <member name="T:Eco.Shared.Localization.LocStringBuilderUtils">
            <summary> utilities for <see cref="T:Eco.Shared.Localization.LocStringBuilder"/> </summary>
        </member>
        <member name="T:Eco.Shared.Localization.MissingString">
            <summary> class is used to register missing localization strings /// </summary>
        </member>
        <member name="T:Eco.Shared.Localization.SharedLocs">
            <summary>Shared localization strings.</summary>
        </member>
        <member name="T:Eco.Shared.Localization.StringLocalizedData">
            <summary> Class used by LocalizationAssemblyParser to hold data intended for localization. </summary>
        </member>
        <member name="F:Eco.Shared.Localization.SupportedLanguageUtils.DictToCultureLangCode">
            <summary>
            Table for converting eco lang to .NET culture codes for use with external ASP.NET restful services.
            A complete list of supported CultureInfo codes can be found here: 
            https://docs.microsoft.com/en-us/bingmaps/rest-services/common-parameters-and-types/supported-culture-codes
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.StreamEncodeInPlace(System.IO.MemoryStream,System.Int32,System.Boolean,K4os.Compression.LZ4.LZ4Level)">
             <summary>
             Encodes <paramref name="data"/> in-place at same <paramref name="data"/> stream.
             If compressed data never overlap next uncompressed data it won't imply any extra copy operation.
             If <paramref name="force"/> is <c>false</c> then it will decide if it is better to keep uncompressed (if input length is 0 or if first block is greater in compressed size than uncompressed.
             </summary>
            
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.CopyInput(System.Buffers.ArrayPool{System.Byte},System.Span{System.Byte}@,System.Int32@)">
            <summary>Copies input buffer and returns a copy byte array, resets producedBytes to MinValue so it never exceed consumedBytes again.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.StreamEncode(System.ReadOnlySpan{System.Byte},System.IO.MemoryStream,K4os.Compression.LZ4.LZ4Level)">
            <summary>Encodes <paramref name="data"/> to <paramref name="compressed"/> stream.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.StreamDecode(System.ReadOnlySpan{System.Byte},System.IO.MemoryStream)">
            <summary>Decodes content of <paramref name="compressed"/> span with LZ4 and outputs decompressed result to <paramref name="decompressed"/>.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.ReadFrame(Eco.Shared.Utils.Binary.ByteSpanReader@)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Reads LZ4 frame header and returns descriptor.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.ReadBlock(Eco.Shared.Utils.Binary.ByteSpanReader@,K4os.Compression.LZ4.Streams.LZ4Descriptor,K4os.Compression.LZ4.Encoders.ILZ4Decoder)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Reads next LZ4 block using <paramref name="descriptor"/> and <paramref name="decoder"/>.
            Block content may be then drained from <paramref name="decoder"/>. Returns number of uncompressed bytes to be drained.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteFrame(System.IO.MemoryStream,K4os.Compression.LZ4.Streams.LZ4Descriptor)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Writes LZ4 frame header for provided <paramref name="descriptor"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteEmptyBlock(System.IO.MemoryStream)">
            <summary>Writes empty block (usually used to last block marker).</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.WriteBlock(System.IO.MemoryStream,System.Byte[],System.Int32,K4os.Compression.LZ4.Encoders.EncoderAction)">
            <summary>
            Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4.
            Writes LZ4 block (either compressed or uncompressed).
            </summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.MaxBlockSizeCode(System.Int32)">
            <summary> Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4. Converts block size to block size code.</summary>
        </member>
        <member name="M:Eco.Shared.LZ4.LZ4Utils.MaxBlockSize(System.Int32)">
            <summary> Ported from https://github.com/MiloszKrajewski/K4os.Compression.LZ4. Converts block size code to actual block size.</summary>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundToMultiple(System.Single,System.Int32)">
            <summary> Rounds value so it will be multiple of some value. Sample: 11, 5 => 10 </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUp(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundUpToInt(System.Single)">
            <summary>
            Rounds half up. I.e. -0.5 -> 0; 0.5 -> 1; 1.5 -> 2.
            We should prefer this way of rounding for coordinates,
            because for voxel we always subtracting 0.5 (i.e. voxel with position [0,0,0] will have [-0.5,-0.5,-0.5] coordinates).
            </summary>
            <param name="value">value to round.</param>
            <returns>rounded value, tie rounded to closest greater int number.</returns>
        </member>
        <member name="M:Eco.Shared.Mathf.ClampTop(System.Single,System.Single)">
            <summary> Clamps to max value. Same as Clamp(current, float.MinValue, max). </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageOf(System.Single,System.Single)">
            <summary> Calculates percentage [0; 1] of <paramref name="total"/> for specified <paramref name="value"/>. </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.PercentageComplementOf(System.Single,System.Single)">
            <summary> Calculates complement of the percentage [0; 1] of the <paramref name="value"/> for the <paramref name="total"/> (1 - percentage). </summary>
            <sample> percentage of <c>5</c> for <c>100</c> is <c>0.05</c>; complement of the percentage of <c>5</c> for <c>100</c> is <c>0.95</c>. </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.RoundToAcceptedDigits(System.Single)">
            <summary> Calculates the exact visible amount for the economy by removing extra fractional digits. </summary>
        </member>
        <member name="M:Eco.Shared.Mathf.CeilingToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Ceiling(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If previous integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use previous value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;=0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>CeilingToInt(0.01f, 0.001f) // 1</code>
            <code>CeilingToInt(0.001f, 0.001f) // 0</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Mathf.FloorToInt(System.Single,System.Single)">
            <summary>
            Performs <see cref="M:System.Math.Floor(System.Double)"/> for <paramref name="num"/> with specified <paramref name="epsilon"/> and converts value to int.
            If next integer value is within <paramref name="epsilon"/> of <paramref name="num"/> then it will use next value instead.
            <paramref name="num"/> should be >= 0 and <paramref name="epsilon"/> should be > 0 and &lt;= 0.5. Otherwise you will get undetermined result.
            </summary>
            <sample>
            <code>FloorToInt(0.99f, 0.001f) // 0</code>
            <code>FloorToInt(0.999f, 0.001f) // 1</code>
            </sample>
        </member>
        <member name="M:Eco.Shared.Math.Directions.FacingRotationsArea(Eco.Shared.Math.DirectionAxisHorizontal)">
            <summary> Returns list of facing rotations from player facing area (player's left, facing and right sides) </summary>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.DirectionsArea(Eco.Shared.Math.DirectionAxisHorizontal)">
            <summary> Returns player facing directions area (player's left, facing and right sides) </summary>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.Rotate90(Eco.Shared.Math.DirectionAxisHorizontal)">
            <summary> Returns player Direction Axis Horizontal in the clockwise rotation </summary>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.RotateNeg90(Eco.Shared.Math.DirectionAxisHorizontal)">
            <summary> Returns the horizontal player direction axis counterclockwise rotation </summary>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.ToVec2i(Eco.Shared.Math.Direction2D)">
            <summary>Converts the direction into a Vector2i</summary>
        </member>
        <member name="M:Eco.Shared.Math.DirectionExtensions.ClosestDirectionAxis(System.Numerics.Vector3)">
            <summary>Get an approximate direction access this vector points in</summary>
        </member>
        <member name="M:Eco.Shared.Math.DoubleExtensions.TryConvertToLong(System.Double,System.Int64@)">
            <summary>Tries to convert <paramref name="value"/> to <see cref="T:System.Int64"/>. It will fail if the value out of long value range, NaN or infinity.</summary>
        </member>
        <member name="T:Eco.Shared.Math.EcoTextLimit">
            <summary>
            EcoTextLimit allows for limiting text length in Eco with respect to whether or not the text contains tags. Max is used for text without tags, while MaxWithTags is used for text with tags.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Sign(System.Single,System.Single)">
            <summary> Returns <paramref name="value"/> sing with specified <paramref name="tolerance"/>. If absolute <paramref name="value"/> less than <paramref name="tolerance"/> then sign will be assumed to <c>0</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.Wrap(System.Single,System.Single)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.FloatExtensions.SetWhenLess(System.Single@,System.Single)">
            <summary>
            Replaces <paramref name="value"/> with <paramref name="candidate"/> if it is less than <paramref name="value"/>.
            Shorthand for
            <code>
            var candidate = someFunc();
            if (candidate &lt; value)
            {
               value = candidate;
               doSomethingElse();
            }
            </code>
            may be shortened to
            <code>
            if (value.SetWhenLess(someFunc())) doSomethingElse();
            </code>
            </summary>
            <returns><c>true</c> if value was set.</returns>
        </member>
        <member name="T:Eco.Shared.Math.Geometry.IPosition3`1">
            <summary>Base interface for all positions for generic math.</summary>
        </member>
        <member name="T:Eco.Shared.Math.Geometry.IPosition3Factory`2">
            <summary>
            Adds API for new position creation for extension methods. Not intended for public API usage, but need to be public for extension methods.
            These methods helps to implement generic math without overhead for extra world bounds checks for wrapped positions.
            </summary>
        </member>
        <member name="T:Eco.Shared.Math.Geometry.PositionExtensions">
            <summary>Position extension methods collection.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Geometry.PositionExtensions.XZ``1(``0)">
            <summary>Returns XZ two-dimensional vector.</summary>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)">
             <summary>
             Wraps value to a range starting with 0 and ending with wrapTo.
             It ensures value in this range and if value is negative it will start from end of range.
            
             For wrapped range we means a some range starting with 0 and ended with concrete end value. I.e. [0, 100)
             When value wrapped it should be enclosed in this range:
              - reduce it to length of this range with "modulo" operation.
              - if it negative then it should be aligned at the end of range
              Some examples for range [0, 100):
                250     ->   250 % 100 = 50   | -                -> 50
                -175    ->   -175 % 100 = -75 | 100 - 75 = 25    -> 25.
             </summary>
             <param name="value">Value to wrap.</param>
             <param name="wrapTo">Ending value of range.</param>
             <returns>Value wrapped to range.</returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.PostfixIncrementWrapped(System.Int32@,System.Int32)">
            <summary>Wrapped alternative of <c>value++</c>. Increments <paramref name="value"/> (which should already be wrapped in <paramref name="wrapTo"/> space) and returns value before increment.</summary>
            <sample><code><![CDATA[
            (value = 9).PostfixIncrementWrapped(10); // value = 0, returns 9
            (value = 9).PostfixIncrementWrapped(20); // value = 10, returns 9
            (value = 10).PostfixIncrementWrapped(10); // invalid, result undefined, but in current implementation value = 11
            (value = -1).PostfixIncrementWrapped(10); // invalid, result undefined, but in current implementation value = 0
            ]]></code></sample>
            <returns></returns>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.InWrappedRange(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Checks if value is in a range which enclosed in wrapped range. <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
            
             It means that "wrappedStart" and "wrappedEnd" values defines a range [wrappedStart, wrappedEnd),
             but this range itself is wrapped to [0, wrappedTo).
            
             So it may create situation when we have initial values: "start" = 80, "end" = 150,
             but after wrapping to [0, 100) they become: "wrappedStart" = 80 and "wrappedEnd" = 50.
            
             And in this case we have "wrappedStart" > "wrappedEnd", because of wrapping. It may be represented as:
             <para>
             xxxxxxx*********************xxxxxxx.
             </para>
             where "x" belongs to wrappedStart to wrappedEnd range.
            
             And for this kind of range we have to make special check where "value" contained in [min, max) range when
             it either contained in [wrappedStart, wrappedTo) or [0, wrappedEnd).
            
             If min &lt;= max, then standard check will be used.
             </summary>
             <param name="value">value to check if it contains in range.</param>
             <param name="wrappedStart">start range value (wrapped).</param>
             <param name="wrappedEnd">end range value (open, wrapped).</param>
             <param name="wrappedTo">end of wrapping range.</param>
             <returns>True if value contained in wrappedStart to wrappedEnd range, False otherwise.</returns>
             <seealso cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
        </member>
        <member name="T:Eco.Shared.Math.IntExtensions.IterationInRange">
             <summary>
             Creates enumerator which enumerates all values contained in range defined by "wrappedStart" and "wrappedEnd". <see cref="M:Eco.Shared.Math.IntExtensions.Wrap(System.Int32,System.Int32)"/>
             These values enclosed in wrapping range [0, wrappedTo), so it may create situation where "wrappedStart"
             greater than "wrappedEnd" because of overlapping start or end bound.
            
             I.e. for wrapping range [0, 100): [-50, 10) => [50, 10), [50, 120) => [50, 20)
            
             In this case we have to iterate over two ranges: [wrappedStart, wrappedTo) and [0, wrappedEnd).
             If wrappedStart less or equal to wrappedEnd then we go to standard iteration over [wrappedStart, wrappedEnd).
             </summary>
        </member>
        <member name="T:Eco.Shared.Math.IntExtensions.IterationInRange.Enumerator">
            <summary> This struct is allocation free and allows to iterate through wrapped range. By example to go in range 0-10 from 7 to 3. It will return 7, 8, 9, 0, 1, 2 </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntExtensions.IterationInRange.Enumerator.CalcSteps">
            <summary> Calculates how many steps it have to make from start to end taking in cosideration the wrapped range. By example in range 0-10, in order to go from 8 to 2 it will return 4 (8, 9, 0, 1). </summary>
        </member>
        <member name="T:Eco.Shared.Math.IntRange">
            <summary>
            Range bounded by int numbers. Alternative to <see cref="T:System.Range"/> without at end indexes support.
            With <see cref="T:System.Range"/> you have to know length of sequence for ^1 like indices and so can't calculate <see cref="P:Eco.Shared.Math.IntRange.Length"/> of range.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.IntRange.Length">
            <summary> Length of the range. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.After(Eco.Shared.Math.IntRange,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.IntRange"/> right after the <paramref name="range"/> with specified <paramref name="length"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.FromOffsetAndLength(System.Int32,System.Int32)">
            <summary> Makes <see cref="T:Eco.Shared.Math.IntRange"/> from <paramref name="offset"/> and <paramref name="length"/> instead of two indexes. </summary>
        </member>
        <member name="M:Eco.Shared.Math.IntRange.op_Implicit(Eco.Shared.Math.IntRange)~System.Range">
            <summary> Implicitly converts to System.Range for array accessors etc. </summary>
        </member>
        <member name="T:Eco.Shared.Math.Matrix2x2i">
            <summary>
            Simple 2x2 integer matrix.
            </summary>
        </member>
        <member name="T:Eco.Shared.Math.PackedChunkPosition">
            <summary>Packed chunk position. Useful when you need to use chunk position as lookup key (i.e. in Dictionary) for faster checks and compact storage.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.InRangeNormalDist(System.Single)">
            Return whether a value is in the range, based on a normal random distribution 
        </member>
        <member name="M:Eco.Shared.Math.Range.Clamp0">
            <summary> Make sure the range is >= 0 </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToInt">
            <summary> Roumd min down, and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Range.RoundToMultiple(System.Single)">
            <summary> Roumd min down to the nearest multiple of 'val', and max up. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistanceSq(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Calculates squared distance for wrapped axes distances for voxel world size.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistance(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2@)">
            <summary>Calculates distance for wrapped axes distances for <paramref name ="size"/> (i.e. size may be voxel size, chunk size or plot size).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDistanceSq(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Calculates squared distance for wrapped axes distances for <paramref name="size"/> (i.e. size may be voxel size, chunk size or plot size).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.WrappedDirectionalVector(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@)">
            <summary>Returns directional difference vector wrapped in <paramref name="size"/> (i.e. WrappedVoxelSize, WrappedChunkSize or WrappedPlotSize).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.NormalizeSafe(Eco.Shared.Math.Vector2)">
            <summary>
            Same as <see cref="P:Eco.Shared.Math.Vector2.Normalized"/>, but for zero-length vector it returns <paramref name="defaultValue"/> instead.
            <see cref="P:Eco.Shared.Math.Vector2.Normalized"/> will return <see cref="F:System.Single.NaN"/> vector in this case.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.Vector2.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2.AngleRad(Eco.Shared.Math.Vector2)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIter(System.Int32)">
            <summary>Iterates all X,Z pairs from 0,0 to size,size (exclusive).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIter(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary> Emits all integer two-component vectors with offset in range from 0 to size for each component and with the specified <paramref name="origin"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIterMinMax(Eco.Shared.Math.Vector2i,Eco.Shared.Math.Vector2i)">
            <summary> Emits all integer two-component vectors from min (inclusive) to max (exclusive). </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIterMinMax(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Emits all integer two-component vectors from min (inclusive) to max (exclusive). </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector2i.XYIterInclusive(System.Int32,System.Int32)">
            Iterate over a range (inclusive) 
        </member>
        <member name="M:Eco.Shared.Math.SVector3.NormalizeSafe(Eco.Shared.Math.SVector3)">
            <summary> Returns normalized version of vector (by dividing each component on vector length), but returns <paramref name="defaultValue"/> in case if length is zero to avoid producing NaN vector. </summary>
        </member>
        <member name="M:Eco.Shared.Math.SVector3.AngleRad(Eco.Shared.Math.SVector3)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="P:Eco.Shared.Math.SVector3.Round">
            <summary>
            Uses default rounding rules (bank rounding, or round to closest even in case of tie).
            I.e. 0.5 -> 0, but 1.5 -> 2.
            </summary>
        </member>
        <member name="P:Eco.Shared.Math.SVector3.RoundUp">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.SVector3.XZWrappedDirectionalVector(Eco.Shared.Math.SVector3@,Eco.Shared.Math.SVector3@,Eco.Shared.Math.SVector3@)">
            <summary>Returns directional difference vector wrapped in <paramref name="size"/> (i.e. WrappedVoxelSize, WrappedChunkSize or WrappedPlotSize).</summary>
        </member>
        <member name="T:Eco.Shared.Math.Vector3Extensions">
            <summary>Extension methods for <see cref="T:System.Numerics.Vector3"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3Extensions.XZWrappedDirectionalVector(System.Numerics.Vector3@,System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>Returns directional difference vector wrapped in <paramref name="size"/> (i.e. WrappedVoxelSize, WrappedChunkSize or WrappedPlotSize).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3Extensions.XZWrappedDirectionalVector(System.Numerics.Vector3@,System.Numerics.Vector3@)">
            <summary>Wraps a true 'vector' (which is now meaningless so we need a long name, points in the shortest direction after accounting for world wrapping).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3Extensions.RoundUp(System.Numerics.Vector3)">
            <summary>
            Always rounds to closes greater number. Preferred way of rounding for coordinates, because voxel coordinates always shifted down.
            I.e. 0.5 -> 1, 1.5 -> 2 and -1.5 -> -1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3Extensions.AngleRad(System.Numerics.Vector3,System.Numerics.Vector3)">
            <summary> Returns angle between two in degs.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.AddY(System.Int32)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.Vector3i"/> with <see cref="P:Eco.Shared.Math.Vector3i.Y"/> component with added <paramref name="deltaY"/>. You can use negative <paramref name="deltaY"/> to subtract value.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.GetAxis(Eco.Shared.Math.Axis)">
            <summary> Returns the scalar value for the given axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.XZWrappedDirectionalVector(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Vector3i)">
            <summary>Wraps a true 'vector' (which is now meaningless so we need a long name, points in the shortest direction after accounting for world voxel wrapping).</summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MinAxis">
            <summary> Return the smallest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Vector3i.MaxAxis">
            <summary> Return the largest axis, breaking ties arbitrarily. </summary>
        </member>
        <member name="T:Eco.Shared.Math.Vector3iExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Math.Vector3i"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Math.Vector3Utils">
            <summary>Helper methods for System.Numerics.Vector3. Server now remaps System.Numerics.Vector3 to UnityEngine.Vector3 using Fody. More information in the Eco.Fody project Fody.md</summary>
        </member>
        <member name="T:Eco.Shared.Math.VectorPacker3Int">
            <summary>Vector packing helper. Packs a 3 int vector into single int value.</summary>
        </member>
        <member name="P:Eco.Shared.Math.VectorPacker3Int.MaxY">
            <summary>Max Y which may be packed.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.TryPackWrapped(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>Tries to pack values assuming they already wrapped, but Y may be out of bounds. Unlike <see cref="M:Eco.Shared.Math.VectorPacker3Int.TryPack(System.Int32,System.Int32,System.Int32,System.Int32@)"/> doesn't wrap X and Z to match their number space and so can exceed limits and corrupt packed value.</summary>
            <returns><c>false</c> if Y out of bounds.</returns>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.PackWrapped(System.Int32,System.Int32,System.Int32)">
            <summary>Packs values assuming they already wrapped. Unlike <see cref="M:Eco.Shared.Math.VectorPacker3Int.Pack(System.Int32,System.Int32,System.Int32)"/> doesn't wrap X and Z to match their number space and so can exceed limits and corrupt packed value.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.RemoveY(System.Int32)">
            <summary>Removes Y and returns packed value as if it with Y == 0.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.XZRange(System.Int32)">
            <summary>Returns range of packed values for specified <paramref name="y"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.PackYChecked(System.Int32)">
            <summary>Checks Y for overflow during packing when asserts enabled.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorPacker3Int.AddChecked(System.Int32,System.Int32)">
            <summary>Checks <paramref name="left"/> for overflow and validity for add operation.</summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.MoveAndRotate(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns distinct collection of vectors form the area that were shifted and rotated according to provided params. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector2})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector2i})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.Average(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i})">
            <summary> Average position, or zero's if none in list. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.ParseVector2(System.String)">
            <summary> Parses Vector2 string representation to <see cref="T:Eco.Shared.Math.Vector2"/> value. </summary>
        </member>
        <member name="M:Eco.Shared.Math.VectorUtils.ParseVector3(System.String)">
            <summary> Parses Vector3 string representation to <see cref="T:System.Numerics.Vector3"/> value. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldArea.WrappedAreas(Eco.Shared.Math.Vector2i)">
            <summary>Enumerates wrapped areas in <paramref name="size"/>. There may be more than one area if <see cref="T:Eco.Shared.Math.WorldArea"/> crossing the border. It assumes that <see cref="F:Eco.Shared.Math.WorldArea.MinInclusive"/> never less than -size for optimization purposes.</summary>
            <example>If <paramref name="size"/> is (100, 100) and area is (90, 90)-(110, 110) then this method will enumerate following areas: (90, 90)-(100, 100), (0, 90)-(10, 100), (90, 0)-(100, 10) and (0, 0)-(10,10).</example>
        </member>
        <member name="M:Eco.Shared.Math.WorldPosition3i.FromWrapped(System.Int32,System.Int32,System.Int32)">
            <summary>Creates <see cref="T:Eco.Shared.Math.WorldPosition3i"/> from pre-wrapped position. Be careful when use this method, if used with unwrapped value may return wrong position.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldPosition3i.FromWrapped(Eco.Shared.Math.Vector3i)">
            <summary>Creates <see cref="T:Eco.Shared.Math.WorldPosition3i"/> from pre-wrapped position. Be careful when use this method, if used with unwrapped value may return wrong position.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldPosition3i.TryCreateWrapped(Eco.Shared.Math.Vector3i,Eco.Shared.Math.WorldPosition3i@)">
            <summary>Tries to create <see cref="T:Eco.Shared.Math.WorldPosition3i"/> from pre-wrapped position, but with potentially out-of-world-grid-bounds Y. When used with unwrapped X and Z will result in invalid position.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldPosition3i.TryCreateWrapped(System.Int32,System.Int32,System.Int32,Eco.Shared.Math.WorldPosition3i@)">
            <summary>Tries to create <see cref="T:Eco.Shared.Math.WorldPosition3i"/> from pre-wrapped position, but with potentially out-of-world-grid-bounds Y. When used with unwrapped X and Z will result in invalid position.</summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Length">
            <summary> The length not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Width">
            <summary> The width not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Height">
            <summary> The height not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Volume">
            <summary> The volume not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Size">
            <summary> The size not including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.LengthInc">
            <summary> The length including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.WidthInc">
            <summary> The width including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.HeightInc">
            <summary> The height including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.VolumeInc">
            <summary> The volume including the maximum position. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.SizeInc">
            <summary> The size including the maximum position. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.#ctor(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i})">
            <summary>Creates a World Range that contains a list of Vector3i</summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Invalid">
            <summary> A range where IsValid() will return false. </summary>
        </member>
        <member name="P:Eco.Shared.Math.WorldRange.Empty">
            <summary> A range around 0,0,0 with 0 dimentions. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ContainsXZ(Eco.Shared.Math.Vector2i)">
            <summary>Checks if the range contains X,Z <paramref name="pos"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Translate(Eco.Shared.Math.Vector3i)">
            <summary>Shift world range by the given delta.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExpandMax(Eco.Shared.Math.Vector3i)">
            <summary>Expands the maximum value by <paramref name="delta"/>. Useful for converting from an inclusive world range to an exclusive one.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.CollapseAlongAxis(Eco.Shared.Math.Axis,System.Boolean)">
            <summary> Collapses a square range into a line. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.InvertRange(System.Int32@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Inverts the range inside world to make a direction in a proper way
            E.g. start as 955 with end as 1 and worldSize 1000 will give a reversed direction from 955 to 1
            It'll return minValue as -45 and maxValue as 1 (-45:1 range) 
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Fix(Eco.Shared.Math.Vector3i)">
            <summary> Swaps any values where the min of the axis is larger than the max of the axis. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.RotatedByExc(Eco.Shared.Math.Quaternion)">
            <summary>Rotates <see cref="T:Eco.Shared.Math.WorldRange"/> around (0, 0, 0) (works only with exclusive range). I.e. (-2,-2)-(4,4) rotated by 180 degree will be (-3,-3)-(3,3). When used as exclusive range will include point which was rotated from (-2,-2) to (2,2).</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.RotatedByInc(Eco.Shared.Math.Quaternion)">
            <summary>Rotates <see cref="T:Eco.Shared.Math.WorldRange"/> around (0, 0, 0) (works only with inclusive range). I.e. (-2,-2)-(4,4) rotated by 180 degree will be (-4,-4)-(2,2).</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExtendedBy(Eco.Shared.Math.Vector3i)">
            <summary>Returns new <see cref="T:Eco.Shared.Math.WorldRange"/> extended in each direction by <paramref name="extent"/>.</summary>
            <example><code>
            new WorldRange(new(0, 0, 0), new(1, 1, 1)).ExtendedBy(new(1, 0, 2)); // WorldRange((-1, 0, -2), (2, 1, 3))
            </code></example>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.XZIter">
            <summary>Iterates all X,Z positions in the range.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.WrappedXZIter(Eco.Shared.Math.Vector3i)">
            <summary>Iterates all X,Z positions in the range in wrapped space.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.Corners">
            <summary>
            Returns enumerable with all corners of this <see cref="T:Eco.Shared.Math.WorldRange"/>
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExtendToInclude(Eco.Shared.Math.Vector3i)">
            <summary>Result will be in [inclusive;exclusive) format</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ExtendToInclude(Eco.Shared.Math.WorldRange)">
            <summary>Extends current range to fully include <paramref name="range"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.IntersectsWrapped(Eco.Shared.Math.WorldRange,Eco.Shared.Math.Vector3i)">
            <summary>
            Checks if current current range intersects with another range in a wrapped space. Based loosely on the implementation of <see cref="M:Eco.Shared.Math.WorldRange.Intersects(Eco.Shared.Math.WorldRange)"/> 
            It makes sure to convert the ranges to a wrapped world space.
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.GetWorldRangeWithWrappedMin(Eco.Shared.Math.Vector3i)">
            <summary>
            Returns the wrapped version of the current range, making sure that the min point is in wrapped space while the end point may get out of wrapped size boundaries
            Since manually wrapping each component may result in an invalid range, we make sure to find an appropiate max position so that the range is always valid.
            [Any valid range] -> [Wrapped min range)]
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.GetNonOverlappingXZRanges(Eco.Shared.Math.WorldRange)">
            <summary>
            Returns sub-range(s) for current range which doesn't overlap <paramref name="range"/>. Useful for range difference calculation.
            Possible outcomes:
            - min1.x,min1.z,max1.x,min2.z (when part of the range is before other range min z and overlaps)
            - min1.x,max2.z,max1.x,max1.z (when part of the range is after other range max Z and overlaps)
            - min1.x,min{1,2}.z,min2.x,max{1,2}.z (when part of the range is at left, Z depends on previous parts slices)
            - max2.x,min{1,2}.z,max1.x,max{1,2}.z (when part of the range is at right, Z depends on previous parts slices)
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WorldRange.ToXZRect">
            <summary>Return a rect that represents the xz footprint of this world range.</summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedPosition3i">
            <summary> Represents a <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> variant in which y limitiations isn't applied, this is meant for objects movements around the world which isn't limited by y block bounds. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3i.Create(System.Int32,System.Int32,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3i.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3i.TryPack(Eco.Shared.Math.WorldPosition3i@)">
            <summary>Tries to pack <see cref="T:Eco.Shared.Math.WrappedPosition3i"/> as <see cref="T:Eco.Shared.Math.WorldPosition3i"/>. May fail if <see cref="P:Eco.Shared.Math.WrappedPosition3i.Y"/> is out of world grid bounds.</summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3">
            <summary> Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data, this is limited in y if you need y to not limited to the block bounds use <see cref="T:Eco.Shared.Math.WrappedPosition3"/> instead. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3Extensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3Extensions.WrappedDifference(Eco.Shared.Math.WrappedWorldPosition3,Eco.Shared.Math.WrappedWorldPosition3)">
            <summary> Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3Extensions.XZ(Eco.Shared.Math.WrappedWorldPosition3)">
            <summary> Returns <see cref="T:Eco.Shared.Math.Vector2"/> for <see cref="F:Eco.Shared.Math.WrappedWorldPosition3.X"/> and <see cref="F:Eco.Shared.Math.WrappedWorldPosition3.Z"/> coordinates. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedPosition3Extensions">
            <summary> Extension methods for <see cref="T:Eco.Shared.Math.WrappedPosition3"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3Extensions.WrappedDifference(Eco.Shared.Math.WrappedPosition3,Eco.Shared.Math.WrappedPosition3)">
            <summary> Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3Extensions.XZ(Eco.Shared.Math.WrappedPosition3)">
            <summary> Returns <see cref="T:Eco.Shared.Math.Vector2"/> for <see cref="P:Eco.Shared.Math.WrappedPosition3.X"/> and <see cref="P:Eco.Shared.Math.WrappedPosition3.Z"/> coordinates. </summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedWorldPosition3i">
            <summary>
            Represents wrapped world position which doesn't require any further conversions. It prevents multiple checks everywhere for position to be actually wrapped or multiple conversions for same data.
            Comparing to <see cref="T:Eco.Shared.Math.WorldPosition3i"/> it isn't packed, so doesn't require extra packing/unpacking operations and also readonly what allows to apply some optimizations and makes it thread-safe.
            This is limited in Y along with XZ wrapping, if you are looking for Position without y limitation use <see cref="T:Eco.Shared.Math.WrappedPosition3i"/>
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighbors">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Full26Neighbors(System.Boolean)">
            <summary> Returns all orthogonal and diagonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.XYZNeighborsWithDirection">
            <summary> Returns all orthogonal neighbors by X, Y, Z axes. It won't return Y axis neighbors if they out of bounds (bellow zero or above MaxY) and wrap X, Z neighbors (if they crossing zero coordinate). </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddX(System.Int32)">
            <summary>Adds <paramref name="x"/> to <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.X"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.X.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddZ(System.Int32)">
            <summary>Adds <paramref name="z"/> to <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Z"/> component and returns new value. The value should be not less than -<see cref="P:Eco.Shared.Voxel.World.WrappedVoxelSize"/>.Z.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to increase <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="increment"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and increased value in <paramref name="increasedPos"/>. For decreasing <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryDecreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to decrease <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> component where <paramref name="decrement"/> should be positive value. If succeed (not out of world bounds) then returns <c>true</c> and decreased value in <paramref name="decreasedPos"/>. For increasing <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> use <see cref="M:Eco.Shared.Math.WrappedWorldPosition3i.TryIncreaseY(System.Int32,Eco.Shared.Math.WrappedWorldPosition3i@)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryGetNeighbor(Eco.Shared.Math.Direction,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Returns neighbor world position for <paramref name="dir"/> if possible. It may return <c>false</c> for invalid <paramref name="dir"/> value or if Y will go out of world bounds.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.TryGetSides(Eco.Shared.Math.Axis,Eco.Shared.Math.WrappedWorldPosition3i@,Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary> If possible, returns two positions using passed axis. It may be impossible if it will be outside of world by Y coor. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Int32,System.Int32,System.Int32)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.Clamp(Eco.Shared.Math.WrappedPosition3i)">
            <summary>Clumps <paramref name="wrapped"/> position in Y space. If Y less 0 then it will be 0, if Y greater or equal to World Space Y then it will be World Space Y - 1.</summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedWorldPosition3i.AddYUnchecked(Eco.Shared.Math.WrappedWorldPosition3i,System.Int32)">
            <summary>
            Adds <paramref name="y"/> to <paramref name="wrapped"/> and returns value. In result of that operation it may produce invalid <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> with <see cref="P:Eco.Shared.Math.WrappedWorldPosition3i.Y"/> out of world grid bounds.
            Only use it if you sure result of that operation won't overflow Y bounds if you want to skip checks for optimization purposes!
            </summary>
        </member>
        <member name="T:Eco.Shared.Math.Wrapping.IWrappedPosition3`1">
            <summary>Common interface for pre-wrapped positions for optimized calculations like <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> or <see cref="T:Eco.Shared.Math.WrappedPosition3i"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Math.Wrapping.IWrappedPosition3WithUnboundedY`1">
            <summary>Interface for unbounded by Y wrapped positions (Y may go negative or over world size Y). May be useful for intermediate calculations or for movable object positions which not tight to world grid space.</summary>
        </member>
        <member name="T:Eco.Shared.Math.Wrapping.WrappedSpace">
            <summary><see cref="T:Eco.Shared.Math.Wrapping.WrappedSpace"/> is a struct which holds information about wrapped space size and provides tools for wrapped space calculations.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.WrappedDifference``1(``0,``0)">
            <summary>
            Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>.
            I.e. for world size (100, 100, 80):
            - (10, 10, 10).WrappedDelta(20, 20, 20) -> (-10, -10, -10)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -30)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -50)
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.WrappedXZDistanceSq``1(``0,``0)">
            <summary>Calculates wrapped distance (squared) between <paramref name="a"/> and <paramref name="b"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.WrappedXZDistanceSq(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2)">
            <summary>Calculates wrapped distance (squared) between <paramref name="one"/> and <paramref name="other"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.AbsDeltaBetweenWrappedValues(System.Single,System.Single,System.Single,System.Single)">
            <summary>Calculates absolute delta between pre-wrapped <paramref name="a"/> and <paramref name="b"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.AbsDeltaBetweenNonWrappedValues(System.Single,System.Single,System.Single,System.Single)">
            <summary>Absolute delta between non-wrapped <paramref name="a"/> and <paramref name="b"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedSpace.WrappedXZDistance``1(``0,``0)">
            <summary>Calculates wrapped distance between <paramref name="a"/> and <paramref name="b"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Math.Wrapping.WrappedSpaces">
            <summary>Holder for wrapped spaces (world, chunk and plot).</summary>
        </member>
        <member name="T:Eco.Shared.Math.Wrapping.WrappedWorldPositionExtensions">
            <summary> Extension methods for wrapped world positions. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedWorldPositionExtensions.WrappedDifference``1(``0,``0)">
            <summary>
            Calculates wrapped difference between <paramref name="a"/> and <paramref name="b"/>.
            I.e. for world size (100, 100, 80):
            - (10, 10, 10).WrappedDelta(20, 20, 20) -> (-10, -10, -10)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -30)
            - (10, 10, 10).WrappedDelta(60, 20, 60) -> (-50, -10, -50)
            </summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedWorldPositionExtensions.WrappedDistanceSq``1(``0,``0)">
            <inheritdoc cref="M:Eco.Shared.Math.Wrapping.WrappedSpace.WrappedXZDistanceSq``1(``0,``0)"/>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedWorldPositionExtensions.XZWrappedNeighborsRay``1(``0)">
            <summary>Returns enumerable of XZ rays in wrapped space.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Wrapping.WrappedWorldPositionExtensions.StepToInc``1(``0,``0,Eco.Shared.Math.Direction)">
            <summary>Returns enumerable of positions from current <paramref name="position"/> to <paramref name="other"/> with provided <paramref name="dir"/>. Be aware if <paramref name="dir"/> is wrong then position may never be reached!</summary>
        </member>
        <member name="T:Eco.Shared.Math.WrappedPosition3">
            <summary> Represents a <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/> variant in which y limitiations isn't applied, this is meant for objects movements around the world which isn't limited by y block bounds. </summary>
        </member>
        <member name="M:Eco.Shared.Math.WrappedPosition3.Create(System.Single,System.Single,System.Single)">
            <summary> Makes new <see cref="T:Eco.Shared.Math.WrappedPosition3"/> from unwrapped <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Math.Route.FindPathSegmentIndexAtTime(System.Single,System.Int32)">
            <summary>Finds <see cref="T:Eco.Shared.Math.PathSegment"/> index covering <paramref name="time"/> starting at path segment with index <paramref name="start"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Math.Route.PosListToWaypoints(Eco.Shared.Math.TraversalData,System.Numerics.Vector3,System.Collections.Generic.IEnumerable{System.Numerics.Vector3})">
            <summary>Create a list of detailed path segments, each one with detailed properties about that segment that will help us move and rotate smoothly the animal on the client side.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Auth.AdminAwareRPCAuthorizer">
            <summary><see cref="T:Eco.Shared.Networking.Auth.AdminAwareRPCAuthorizer"/> wraps another <see cref="T:Eco.Shared.Networking.Auth.IRPCAuthorizer"/> and adds special case for admin access. Auto-passes auth check if observer is admin.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer">
            <summary><see cref="T:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer"/> uses <see cref="F:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer.attribute"/> for auth checks for target before wrapped <see cref="F:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer.authorizer"/> check. In addition to <see cref="F:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer.accessType"/> it passes <see cref="F:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer.attribute"/> for custom checks.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Auth.DefaultRPCAuthorizer">
            <summary><see cref="T:Eco.Shared.Networking.Auth.DefaultRPCAuthorizer"/> uses target as <see cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer"/> for auth checks. If target isn't <see cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer"/> then returns true.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Auth.IRPCAuthorizer">
            <summary><see cref="T:Eco.Shared.Networking.Auth.IRPCAuthorizer"/> used by <see cref="T:Eco.Shared.Networking.RPCMethod"/> for RPC calls authorization. Auto-constructed from attributes on RPC method member. May be <see cref="T:Eco.Shared.Networking.Auth.AttributeAwareRPCAuthorizer"/>, <see cref="T:Eco.Shared.Networking.Auth.AdminAwareRPCAuthorizer"/>, or <see cref="T:Eco.Shared.Networking.Auth.DefaultRPCAuthorizer"/>.</summary>
            <remarks>See also: <seealso cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer"/></remarks>
        </member>
        <member name="T:Eco.Shared.Networking.Auth.RPCAuthAttribute">
            <summary>Base class for RPC auth check attributes. Such an attribute have to implement <see cref="M:Eco.Shared.Networking.Auth.RPCAuthAttribute.IsAuthorized(System.Object,Eco.Shared.Networking.IWorldObserver,Eco.Shared.Items.AccessType)"/> method which will check auth <b>in addition</b> to main auth check on target object itself.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Auth.RPCAuthAttribute.IsAuthorized(System.Object,Eco.Shared.Networking.IWorldObserver,Eco.Shared.Items.AccessType)">
            <summary>Checks if RCP authorized on <paramref name="target"/> performed by <paramref name="observer"/> for <paramref name="accessType"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientUpdate">
            <summary>
            Contains data for <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate"/> events.
            Every <see cref="T:Eco.Shared.Networking.ClientUpdate"/> belongs to network queue with <see cref="F:Eco.Shared.Networking.ClientUpdate.queueIndex"/>.
            Queue index defines associated <see cref="T:Eco.Shared.Networking.NetworkEvent"/> as ClientUpdate<i>Index</i> (i.e. <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate0"/> and <see cref="F:Eco.Shared.Networking.NetworkEvent.ClientUpdate1"/>).
            It has four data arrays for <see cref="F:Eco.Shared.Networking.ClientUpdate.Created"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Updated"/> objects, <see cref="F:Eco.Shared.Networking.ClientUpdate.Destroyed"/> objects and <see cref="F:Eco.Shared.Networking.ClientUpdate.ViewUpdates"/>.
            They should be filled and then flushed with <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> method. Only non-empty arrays sent.
            If all arrays are empty then <see cref="M:Eco.Shared.Networking.ClientUpdate.Send(Eco.Shared.Networking.INetClient)"/> call will be ignored unless <see cref="F:Eco.Shared.Networking.ClientUpdate.ForceSend"/> is set.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.ClientUpdate.AddToData(System.String,Eco.Shared.Serialization.BSONArray@)">
            <summary>Adds <paramref name="bson"/> to <see cref="F:Eco.Shared.Networking.ClientUpdate.data"/> with <paramref name="keyName"/> as key and replaces <paramref name="bson"/> with empty array.</summary>
        </member>
        <member name="F:Eco.Shared.Networking.Constants.PlayEcoTwitchLinkAddress">
            <summary>play.eco Twitch account linking address. Based on the branch matching play.eco website url set at <see cref="F:Eco.Shared.Networking.Constants.AccountsServerAddress"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Networking.Constants.PlayEcoTwitchLinkPollAddress">
            <summary>play.eco Twitch account linking poll address. Based on the branch matching play.eco website url set at <see cref="F:Eco.Shared.Networking.Constants.AccountsServerAddress"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Networking.Constants.MasterServerRestApiUrl">
            <summary>REST API url of Master Server for server listing.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.EcoAttribute">
            <summary>
            One attribute to rule them all. This gives all the bells-and-whistles to a property or class, including:
             - Serialized.          Loads and saves the entry.
             - SyncToView.          It creates a view of the property on the client and keeps it updated.
             - AutoRPC.             Creates an RPC for the client to edit this parameter.
             - AutoGen.             Tags the member to have UI generated for it automatically created on the client.
             - Property Scanning.   The Property Scanner will traverse into it to update validity.
             - PropertyExplanation. Explains the property.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ScanPropAttribute">
            <summary> Mark a property as being traversed by Property Scanner, even if not tagged [Eco]. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.TreatAsReferenceAttribute">
            <summary> Used for things that reference types like 'object', and we should consider them references from a scanning point of view. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ForceScanSubPropAttribute">
            <summary> Mark a property as to traverse its sub properties, even if it wouldn't usually otherwise (ie, references dont usually 'scan into') </summary>
        </member>
        <member name="T:Eco.Shared.Networking.OnlyReferenceScanAttribute">
            <summary> When this is encountered, the Property Scanner will continue scanning that property and any children properties, but will no longer check validity. This is useful when you have a property with members who's validity shouldnt affect our own (like actions that an election references), but you still want to perform the other features PropertyManager provides (like setting up references). </summary>
        </member>
        <member name="T:Eco.Shared.Networking.AnyStateAllowedAttribute">
            <summary> Mark a property as able to refernce any state of Proposablew. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCAttribute">
            <summary> Creates an RPC that can be called on the client. See <strong>RPCAuthorization.md</strong> for details.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.ClientAPIAttribute">
            <summary>Marks method or class with all it's members as Client API. It prevents it marked as unused and adds semantic about use cases.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.AutoRPCAttribute">
            <summary> Creates an RPC in the view for the client to change this property. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ProfanityAttribute">
            <summary> Filter profanity RPC properties and parameters </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RangeAttribute">
            <summary> Limit the strings to a certain range, based on the text type </summary>
        </member>
        <member name="T:Eco.Shared.Networking.EcoTextLimitAttribute">
            <summary> Limit the strings to a certain range, based on the text type </summary>
        </member>
        <member name="T:Eco.Shared.Networking.ProfanityPropertyAttribute">
            <summary> Filter profanity RPC properties and parameters by replacing with some specific property </summary>
        </member>
        <member name="M:Eco.Shared.Networking.CustomRPCSetterAttribute.#ctor(System.Type,System.String)">
            <summary>Create a custom setter that calls a static function on the given type.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.SharedAttributeExtensions.GetRequiredRPCAccess(System.Reflection.MemberInfo,Eco.Shared.Items.AccessType)">
            <summary>Returns <see cref="T:Eco.Shared.Items.AccessType"/> required for <see cref="T:Eco.Shared.Networking.RPCInvocation"/>. Checks attributes and uses <paramref name="defaultRequiredAccess"/> if can't retrieve it from attributes.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.KeepIconAttribute">
            <summary>
            Keep class icon when using as property for GameValue instead of context icon.
            <para>Example: GameAction contains Citizen property and uses context icon, this attribute will force any User property to use it's own icon.</para>
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.DoNotLinkOnTypeTooltipAttribute">
            <summary> Marks the type as non-linkable, even if it inherits from ILinkable. Types with this will not be linked from CivicsTooltip. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.CustomIconOnTypeTooltipAttribute">
            <summary>
            Use to have a property prepended with an icon different than its type's.
            <para>Example: Alias has no icon of its own, but we want it to appear with the icon of 'Demographics', so we apply [CustomIconOnTypeTooltip(typeof(Demographics))].</para>
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.CustomIconOnTypeTooltipAttribute.#ctor(System.Type)">
            <param name="type"> Type to inherit the icon from. </param>
        </member>
        <member name="T:Eco.Shared.Networking.ForceAotHint">
            <summary>Used to force add a specific class/struct to AoTHints in ViewAutogen on the client, see AutoGenViews.cs for more details.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.ExtendedServerInfo">
            <summary>Subclass of <see cref="T:Eco.Shared.Networking.ServerInfo"/> with additional properties provided only by Master Server and not published by server with <see cref="T:Eco.Shared.Networking.ServerInfo"/> to keep payload size as small as possible (to avoid problems with UDP packet size limits).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.UdpPeerExtensions.SendUnconnectedMessageWithFragmentation(Eco.Shared.Networking.Udp.IUnconnectedUdpPeer,System.Net.IPEndPoint,System.IO.MemoryStream)">
             <summary>
             Sends unconnected message to recipient with fragmentation support.
             Fragmented messages conforms to following protocol:
                 [NetMessage.FragmentedMessage][fragmentation info byte][fragmented message guid][message body fragment]
            
             [fragmentation info byte] - contains pair partIndex/numOfParts (4 bits each), lower 4 bits is a part index and upper 4 bits is a number of parts. If 0 then message is not fragmented
             [fragmented message guid] - Used as fragmented message identifier to assembly message from parts at destination. 16 bytes.
             [message body fragment] - actual message body. Each fragment will contain part of message body.
            
             Samples:
             0Hello World
            
             One fragment:
                 [\0][H][e][l][l][o][ ][W][o][r][l][d]
             Two fragments:
                 [\10][\32][Guid:16 bytes][\0][H][e][l][l][o]
                 [\10][\33][Guid:16 bytes][ ][W][o][r][l][d]
            
             Following this protocol maximum useful allowed message length is: (MTU - 18) * 15.
             </summary>
             <param name="peer">peer.</param>
             <param name="message">Message to send, if it matches MTU then it will be send as is, otherwise wrapped in fragmented message.</param>
             <param name="recipient">recipient endpoint.</param>
             <exception cref="T:System.ArgumentException">Thrown if message body is too long to split into 15 fragments (max number of fragments).</exception>
        </member>
        <member name="P:Eco.Shared.Networking.FragmentedMessageHandler.TTL">
            <summary>
            Gets or sets fragmented message Time-To-Life, if during this interval message will not be assembled then it will be cleaned up.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.FragmentedMessageHandler.TryGetCompleteBuffer(Eco.Shared.Networking.UdpDataMessage@,Eco.Shared.Networking.UdpDataMessage@)">
            <summary>
            Handles incoming message which may be a fragment. Will return same message if message is complete and may be processed further.
            If it is a message fragment then it will be added to collection of message fragments.
            As soon as all message fragments will be collected it will assemble NetBuffer with message content.
            </summary>
            <param name="message">UdpIncomingMessage message which may be fragment or complete message.</param>
            <param name="completeMessage">UdpIncomingMessage containing complete message data if success, null otherwise.</param>
            <returns>Returns true if able to get complete buffer, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">In case of a fragment inconsistency.</exception>
        </member>
        <member name="T:Eco.Shared.Networking.INetObjectName">
            <summary> Interface which may be implemented by <see cref="T:Eco.Shared.Networking.INetObject"/> to expose custom name for network object (i.e. for logging). </summary>
        </member>
        <member name="T:Eco.Shared.Networking.INetObjectManager">
            <summary>Interface for <see cref="T:Eco.Shared.Networking.INetObject"/> manager.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.GetNextID">
            <summary>Allocates and returns next <see cref="T:Eco.Shared.Networking.INetObject"/> identifier.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.Add(Eco.Shared.Networking.INetObject,System.Int32)">
            <summary>Adds <paramref name="netObject"/> with associated <paramref name="id"/> to <see cref="T:Eco.Shared.Networking.INetObjectManager"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetObjectManager.Remove(Eco.Shared.Networking.INetObject)">
            <summary>Removes <paramref name="netObject"/> from <see cref="T:Eco.Shared.Networking.INetObjectManager"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.INetworkInterceptor">
            <summary>
            <para>Allows an object to intercept <seealso cref="T:Eco.Shared.Serialization.BSONObject"/>s being sent.</para>
            <para>
            See <seealso cref="M:Eco.Shared.Networking.NetObject.AddNetworkInteceptor(Eco.Shared.Networking.INetworkInterceptor)"/> and <seealso cref="M:Eco.Shared.Networking.NetObject.RemoveNetworkInterceptor(Eco.Shared.Networking.INetworkInterceptor)"/> 
            for adding/removing <seealso cref="T:Eco.Shared.Networking.INetworkInterceptor"/> instances.
            </para>
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.IRpcMethodHandler">
            <summary>
            Custom RPC find method handler, for unity side to route RPCs to corresponding components instead of the NetObjComponent.
            Read more about RPC in Eco.Shared/Networking/README.md.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.IRpcMethodHandler.TryCreateInvocation(Eco.Shared.Networking.INetClient,System.Object,System.String,Eco.Shared.Serialization.BSONArray,Eco.Shared.Networking.RPCInvocation@)">
            <summary>Tries to create an RPC invocation on <paramref name="target"/> for <paramref name="methodName"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.IWorldObserverAuthorizer">
            <summary><see cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer"/> interface should be implemented by objects which may be checked for authorization for network clients (i.e RPC calls).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.IWorldObserverAuthorizer.IsAuthorized(Eco.Shared.Networking.IWorldObserver,Eco.Shared.Items.AccessType)">
            <summary>Checks if <paramref name="observer"/> authorized for access of type <paramref name="accessType"/> on an object implementing the interface.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.InstantiateAndCreate(Eco.Shared.Networking.INetObject,System.Boolean)">
            <summary>Makes new instance of <see cref="T:Eco.Shared.Networking.NetObject"/> for <paramref name="controller"/> with <see cref="P:Eco.Shared.Networking.NetObject.Active"/> set to <paramref name="active"/> value and then <see cref="M:Eco.Shared.Networking.NetObject.Create"/> it.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.InstantiateAndCreate(Eco.Shared.Networking.INetObject,System.Int32)">
            <summary>Makes new instance of <see cref="T:Eco.Shared.Networking.NetObject"/> for <paramref name="controller"/> with pre-defined <paramref name="id"/> and then <see cref="M:Eco.Shared.Networking.NetObject.Create"/> it.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.SendEvent``1(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,``0,Eco.Shared.Networking.INetObject)">
            <summary>
            Send event to multiple clients at once. It requires <see cref="T:Eco.Shared.Collections.IScopeAwareEnumerable`1"/> for <paramref name="targets"/> because may process them asynchronously and save reference to enumerable for future usage.
            Explicit scope control allow us to prevent errors when <paramref name="targets"/> only valid in scope of calling method and avoid defensive copy to prevent such errors when <paramref name="targets"/> safe to reference outside of scope (i.e. when they're immutable or unowned right after passing to method).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.SendEventWithInterceptors``1(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,``0,Eco.Shared.Networking.INetObject)">
            <summary>
            Version of <see cref="M:Eco.Shared.Networking.NetObject.SendEvent``1(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,``0,Eco.Shared.Networking.INetObject)"/> with interceptors.
            Interceptors may be used to apply logic for every sent event and even filter some events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObject.SendEventNow(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient)">
            <summary>Sends event immediately if possible ignoring previously queued messages. As side effect it makes encoding in current thread instead of network thread.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetworkEventHandler.SendEvent(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONValue,Eco.Shared.Networking.INetClient,Eco.Shared.Networking.INetObject)">
            <summary>Sends network event to destination target with respect to order of previously queued events.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetworkEventHandler.SendEvent``1(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONValue,``0,Eco.Shared.Networking.INetObject)">
            <summary>
            Send event to multiple clients at once. It requires <see cref="T:Eco.Shared.Collections.IScopeAwareEnumerable`1"/> for <paramref name="targets"/> because may process them asynchronously and save reference to enumerable for future usage.
            Explicit scope control allow us to prevent errors when <paramref name="targets"/> only valid in scope of calling method and avoid defensive copy to prevent such errors when <paramref name="targets"/> safe to reference outside of scope (i.e. when they're immutable or unowned right after passing to method).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.INetworkEventHandler.SendEventNow(Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONValue,Eco.Shared.Networking.INetClient)">
            <summary>Sends network event immediately if possible ignoring previously queued events. If not possible then fallback to SendEvent behavior. It also makes all encoding and serialization in current thread.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetObjectManager.CollectObjectStats">
            <summary> Collect stats about existing network objects in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint">
            <summary> Actual remote end-point for the <see cref="F:Eco.Shared.Networking.NetworkClient.peer"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Networking.NetworkClient.ServerEndPoint">
            <summary> Server's original end-point (may differ from <see cref="P:Eco.Shared.Networking.NetworkClient.RemoteEndPoint"/> if connected with relay). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectDirectly(Eco.Shared.Networking.ExtendedServerInfo)">
            <summary>Tries to connect directly to <paramref name="server"/> using external and internal endpoints (if available).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.EnqueueReceivedPacket(Eco.Shared.Networking.ReceivedNetworkPacket)">
            <summary>Enqueues received packet to the queue based on network event.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithNextConnectionMethod">
            <summary>Tries next connection method (if available). The order is following: DirectConnect, NATPunchConnect, RelayConnect.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithNATPunch(Eco.Shared.Networking.NetworkClient.ConnectionAttempt)">
            <summary>Tries to connect with NAT Punch Through. This method used when client can't connect to server directly due to lack of external IP.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.TryConnectWithRelay(Eco.Shared.Networking.NetworkClient.ConnectionAttempt)">
            <summary>Tries to connect using Relay (proxy for client-server traffic when all other methods fails).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkClient.Dispose">
            <summary>
            Disposes of the <see cref='T:System.ComponentModel.Component'/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket``1(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,``0,System.Action{System.IO.MemoryStream,``0},System.Boolean)">
            <summary>
            Encodes network packet either as compressed or as non-compressed (if it is short enough &lt;=512).
            It has following structure:
            [network event | compressed flag (as high bit):1 byte]
            [message data bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.EncodePacket(System.IO.MemoryStream,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONValue)">
            <summary> Encodes <paramref name="payload"/> as network packet for <paramref name="netEvent"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpClient,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Sends <paramref name="netEvent"/> with <paramref name="payload"/> through the <paramref name="peer"/> (to the server). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.BroadcastPacket(Eco.Shared.Networking.Udp.IUdpServer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject)">
            <summary> Broadcasts <paramref name="netEvent"/> with <paramref name="payload"/> to all connected clients. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.SendPacket(Eco.Shared.Networking.Udp.IUdpPeer,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONValue,System.Object)">
            <summary> Encodes <paramref name="payload"/> and sends <paramref name="netEvent"/> with it's data to <paramref name="connection"/> (may be obtained from <see cref="E:Eco.Shared.Networking.Udp.IUdpPeer.Connected"/>). </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetMessage.DoWithDisconnectReason``1(System.String,``0,System.Boolean,System.Action{``0,Eco.Shared.Networking.NetworkEvent,Eco.Shared.Serialization.BSONObject},System.Int32)">
            <summary> Invokes <paramref name="action"/> with pre-constructed disconnect message object. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkUtils.TryResolve(System.String,System.Net.IPAddress@)">
            <summary>
            Resolves IP address or host name to IPAddress object.
            If '*' used then it will auto-discovery remote address using https://www.ipify.org/.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkUtils.GetOperationalNetworkInterfaceProperties">
            <summary>Returns <see cref="T:System.Net.NetworkInformation.IPInterfaceProperties"/> for operational network interfaces (either up or unknown status).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.NetworkUtils.V4OrV6(System.Collections.Generic.IEnumerable{System.Net.IPAddress})">
            <summary>Filters <paramref name="addresses"/> to include only IPv4 and IPv6 addresses.</summary>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerAddresses">
            <value>Remote address list for official relay servers.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.DefaultRelayServerPort">
            <value>Default Relay Server port.</value>
        </member>
        <member name="F:Eco.Shared.Networking.RelayClient.RelayServerProtocolVersion">
            <value>Current message serialization version, bump when message format changes.</value>
        </member>
        <member name="M:Eco.Shared.Networking.RelayClient.TryProcessRelayIntroduce(System.Net.IPEndPoint,Eco.Shared.Utils.Binary.ByteSpanReader@,System.Guid@,System.Net.IPEndPoint@)">
            <summary>
            Processes relay introduce message:
             [remote port:2 bytes][server id:guid].
            </summary>
            <param name="senderEndpoint">remote endpoint from which message received.</param>
            <param name="reader">reference to message data reader.</param>
            <param name="serverId">expected server id.</param>
            <param name="connectionEndPoint">output parameter for connection end point.</param>
        </member>
        <member name="T:Eco.Shared.Networking.RPCEvent">
            <summary>Handles BSON packaging for the RPC calls and used by <see cref="T:Eco.Shared.Networking.RPCManager"/></summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCInfo">
            <summary><see cref="T:Eco.Shared.Networking.RPCInfo"/> contains identifying information for RPC method. The method may be called by name or by Id (usually faster and may be only way to call overloaded RPC methods). This info shared with client.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCInvocation">
            <summary>
            Contains information about <see cref="T:Eco.Shared.Networking.RPCMethod"/> invocation including method itself, target and prepared args.
            Used as prepared call for <see cref="T:Eco.Shared.Networking.RPCManager"/> internally and also may be used externally if you need to do some kind of postprocessing/security checks on invocation.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.#ctor(Eco.Shared.Networking.RPCMethod,System.Object,System.Int32)">
            <summary>Creates <see cref="T:Eco.Shared.Networking.RPCInvocation"/> from method and target with null args. These args may be then set to required values with <see cref="P:Eco.Shared.Networking.RPCInvocation.Args"/> span accessor.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.HasAccess(Eco.Shared.Networking.INetClient)">
            <summary>Checks if <paramref name="client"/> has required access to make the invocation.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.Invoke">
            <summary>Performs the call.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCInvocation.Dispose">
            <summary>Returns rented args array back to cache (for reusing arrays and reducing memory allocations).</summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCManager">
            <summary>Manager responsible for RPC lookup and invocation.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.Invoke(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.RPCInvocation)">
            <summary>Invokes <paramref name="invocation"/> with access permissions check.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.ResolveMethodName(System.String)">
            <summary>Resolves method name from method id or method name.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.TryCreateInvocation``1(Eco.Shared.Networking.INetClient,System.Object,System.String,System.Collections.Generic.IList{``0},System.Func{``0,System.Type,System.Object},Eco.Shared.Networking.RPCInvocation@)">
            <summary>
            Tries to create <see cref="T:Eco.Shared.Networking.RPCInvocation"/> for <paramref name="methodName"/> on <paramref name="target"/>. Method name either method ID (int) for distinguishing overrides or method name.
            If <paramref name="methodName"/> then it tries to find matching method by arguments.
            <paramref name="packedArgs"/> may be either list of <see cref="T:Eco.Shared.Serialization.BSONValue"/> or <see cref="T:System.Object"/>. Packed arg will be unpacked with <paramref name="unpackArg"/> function which accepts argument value and target type as parameters.
            Returns <c>false</c> if matching method not found. Throws exception if invalid args passed.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.GetAutoParameter(Eco.Shared.Networking.RPCMethod,Eco.Shared.Networking.INetClient)">
            <summary>Returns auto-parameter which exposed from <paramref name="client"/>: client itself, world observer or object which may be evaluated from observer (implementing <see cref="T:Eco.Shared.Networking.IObserverConversionTarget"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.PrepareInvocation``1(Eco.Shared.Networking.INetClient,System.Collections.Generic.IList{``0},System.Func{``0,System.Type,System.Object},Eco.Shared.Networking.RPCMethod,System.Object)">
            <summary>
            Unpacks list of <paramref name="packedArgs"/> to array of <paramref name="method"/> arguments using <paramref name="unpackArg"/> function.
            <paramref name="packedArgs"/> may be either list of <see cref="T:Eco.Shared.Serialization.BSONValue"/> or <see cref="T:System.Object"/>. Packed arg will be unpacked with <paramref name="unpackArg"/> function which accepts argument value and target type as parameters.
            Then unpacked args together with <paramref name="method"/> and <paramref name="target"/> used to create an <see cref="T:Eco.Shared.Networking.RPCInvocation"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.TryCreateAndAddQuery``1(Eco.Shared.Serialization.BSONObject,System.Action{``0},Eco.Shared.Networking.INetClient,System.String)">
            <summary> Try creating an <see cref="T:Eco.Shared.Networking.RPCManager.AwaitedQuery"/> using the given callback and bind it to the given <see cref="T:Eco.Shared.Serialization.BSONObject"/></summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.TryCreateAndAddQuery(Eco.Shared.Serialization.BSONObject,System.Action,Eco.Shared.Networking.INetClient,System.String)">
            <summary> Try creating an <see cref="T:Eco.Shared.Networking.RPCManager.AwaitedQuery"/> using the given callback and bind it to the given <see cref="T:Eco.Shared.Serialization.BSONObject"/></summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.TryAddQuery(Eco.Shared.Networking.RPCManager.AwaitedQuery,System.Int64@)">
            <summary> Try to add the given query for <see cref="T:Eco.Shared.Networking.RPCManager"/> to handle on getting callback. </summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCManager.FromObjArg(System.Object,System.Type)">
            <summary>Converts <paramref name="arg"/> to <paramref name="targetType"/>. For now just returns arg, but this logic may be improved with smart casts.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCManager.AwaitedQuery">
            <summary> A query that is used by <see cref="T:Eco.Shared.Networking.RPCManager"/> to manage RPCs that have callbacks. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCMethod">
            <summary><see cref="T:Eco.Shared.Networking.RPCMethod"/> contains all meta information about RPC method like name, flags, required arguments, required access etc.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.RPCMethod.GetRPCAuthorizer(System.Reflection.MemberInfo,Eco.Shared.Items.AccessType,System.Boolean)">
            <summary>
            Returns <see cref="T:Eco.Shared.Networking.Auth.IRPCAuthorizer"/> for <paramref name="member"/>. If required access type not provided via attribute then uses <paramref name="defaultRequiredAccess"/>.
            It also checks if member has attributes of type <see cref="T:Eco.Shared.Networking.Auth.RPCAuthAttribute"/> interface and then uses attribute based auth check before passing to <see cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer"/>.
            If specialAllowAdminAcces is passed in, then the RPC will be guaranteed to allow admins to always call it.
            </summary>
        </member>
        <member name="T:Eco.Shared.Networking.RPCMethodFlags">
            <summary>Important flags for <see cref="T:Eco.Shared.Networking.RPCMethod"/>.</summary>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.External">
            <value>
            Set by master server if this server is available directly by external IP address.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.RelayAddress">
            <value>
            Optional relay address, may be set by server to inform clients how to connect to this server if connect in usual way (direct/NAT Punch Through) doesn't work.
            </value>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.Access">
            <summary> Access mode of server: "public", "hidden", or "private". </summary>
        </member>
        <member name="P:Eco.Shared.Networking.ServerInfo.JoinUrl">
            <summary> Used by the built in web server to allow connecting to the server via the website. Contains the full uri protocol connection string for this server </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.DisconnectReason">
            <summary> Enum for different disconnect reasons which may be produced by <see cref="T:Eco.Shared.Networking.Udp.IUdpPeer"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpClient">
            <summary>
            Interface for Upd client.
            It contains client specific methods and properties (like <see cref="P:Eco.Shared.Networking.Udp.IUdpClient.ConnectionStatus"/> or <see cref="M:Eco.Shared.Networking.Udp.IUdpClient.Disconnect"/>).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpClient.Disconnect">
            <summary>Disconnects client from server peer.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpClient.GetStats">
            <summary>Returns network stats like how much bytes sent and received. <see cref="T:Eco.Shared.Networking.NetStats"/> for more details.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpClient.SendData(System.ReadOnlySpan{System.Byte},System.Byte)">
            <summary>Sends data to the server peer. Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpLibrary">
            <summary>
            Interface for UDP libraries. Use this to create network lib peers.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateClient(System.String,System.UInt32,System.UInt32)">
            <summary>
            Create UPD client for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">app identifier.</param>
            <param name="protocolVersion">version of binary protocol used between client and server.</param>
            <param name="connectTimeoutMs">connection timeout (time before Disconnect event received with <see cref="F:Eco.Shared.Networking.Udp.DisconnectReason.Timeout"/>).</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpClient"/> implementation instance for this lib.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpLibrary.CreateServer(System.String,System.UInt32,System.Net.IPEndPoint,System.Int32)">
            <summary>
            Create UPD server for app with <c>appIdentifier</c>.
            </summary>
            <param name="appIdentifier">App identifier.</param>
            <param name="protocolVersion">version of binary protocol used between client and server.</param>
            <param name="requestedEndPoint">Request endpoint for the server. You can use <c>IPEndPoint.Any</c> for address or <c>0</c>
            for port if you want to have automatically assigned values.</param>
            <param name="maxConnections">Maximum number of connections. <c>0</c> - for maximum possible.</param>
            <returns><see cref="T:Eco.Shared.Networking.Udp.IUdpServer"/> implementation instance for this lib.</returns>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUdpPeer">
            <summary>
            Base interface for all UPD peers (either client or server).
            Contains common UPD transport methods: like Connect to specific peer, Send to peer or Receive message.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpPeer.SendData(System.Object,System.ReadOnlySpan{System.Byte},System.Byte)">
            <summary>Sends data to the <paramref name="connection"/> (one of connected peers). Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpPeer.SendData(System.Collections.Generic.IEnumerable{System.Object},System.ReadOnlySpan{System.Byte},System.Byte)">
            <summary>Sends data to all <paramref name="connections"/>. Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUdpServer.BroadcastData(System.ReadOnlySpan{System.Byte})">
            <summary>Broadcast data to every connected peer.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer">
            <summary>
            Interface for unconnected UPD peers.
            Contains UPD Peer Api for unconnected messages only.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.UnconnectedDataMessageReceived">
            <summary>
            Event called when unconnected data message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ErrorMessageReceived">
            <summary>
            Event called when an error message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.WarningMessageReceived">
            <summary>
            Event called when a warning message received.
            </summary>
        </member>
        <member name="E:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.DebugMessageReceived">
            <summary>
            Event called when a debug message received.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.MaximumUnconnectedMessageLength">
            <summary>
            MTU - maximum transmission unit size. Maximum size of UPD packet.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Port">
            <summary>
            Gets local port.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.IsRunning">
            <summary>
            Gets running state of the peer.
            </summary>
        </member>
        <member name="P:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.LocalEndPoint">
            <summary>
            Local IP End Point for the peer.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendRaw(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends raw data with socket to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SendUnconnectedMessage(System.Net.IPEndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends unconnected message with network lib to destination peer.
            It releases buffer after a send operation, so it is safe to reuse the <c>messageData</c> buffer.
            </summary>
            <param name="remoteEndPoint">destination end point.</param>
            <param name="messageData">message data to send.</param>
            <param name="offset">offset in message data.</param>
            <param name="length">length of message.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Start">
            <summary>
            Starts peer. Makes initialization, creates socket and optionally starts background message processing thread.
            You need to call <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/> or <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/> to have network messages processed and trigger message events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Shutdown">
            <summary>
            Shutdowns peers. Releases resources and stops background threads (if any).
            </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)">
            <summary>
            Services network messages - sending, receiving, connecting etc. You should call this method regular.
            /// Typical usage is following:
            <code>
            while (peer.IsRunning)
               peer.Service(10);
            </code>
            You can service single network event with <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)"/>.
            </summary>
            <param name="timeoutMs">Maximum timeout between events. It will return if timeout exceed.</param>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.ServiceOne(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.Service(System.Int32)"/>, but only service single network event.
            </summary>
            <param name="timeoutMs">Maximum timeout until event. It will return <c>false</c> if the event won't happen.</param>
            <returns><c>true</c> if the event serviced, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.IUnconnectedUdpPeer.SyncTimer(System.Double)">
            <summary>
            Synchronize timers. Ensures local timer and network timer will use same time base.
            </summary>
            <param name="currentTimeInSeconds">current time on your timer.</param>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer">
            <summary> Simplest implementation of Unconnected UDP peer (used by master server) which doesn't use any third-party library, but just async sockets from .NET Core. </summary>
        </member>
        <member name="F:Eco.Shared.Networking.Udp.SimpleUnconnectedUdpPeer.ENetMtu">
            <summary> ENet Network Library MTU, we should have unconnected messages &lt;= MTU to be received by ENet. </summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.UdpClientExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Networking.Udp.IUdpClient"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.UdpClientExtensions.SendData(Eco.Shared.Networking.Udp.IUdpClient,System.Byte[],System.Int32,System.Int32,System.Byte)">
            <summary>Sends data to the server peer. Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.UdpPeerExtensions.SendData(Eco.Shared.Networking.Udp.IUdpPeer,System.Object,System.Byte[],System.Int32,System.Int32,System.Byte)">
            <summary>Sends data to the <paramref name="connection"/> (one of connected peers). Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.UdpPeerExtensions.SendData(Eco.Shared.Networking.Udp.IUdpPeer,System.Collections.Generic.IEnumerable{System.Object},System.Byte[],System.Int32,System.Int32,System.Byte)">
            <summary>Sends data to all <paramref name="connections"/>. Optionally may be provided <paramref name="channel"/>. Reliable sequenced packets delivers independently on different channels.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.Udp.UdpServerExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Networking.Udp.IUdpServer"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.Udp.UdpServerExtensions.BroadcastData(Eco.Shared.Networking.Udp.IUdpServer,System.Byte[],System.Int32,System.Int32)">
            <summary>Broadcast data to every connected peer.</summary>
        </member>
        <member name="T:Eco.Shared.Networking.ViewDistance">
            <summary><see cref="T:Eco.Shared.Networking.ViewDistance"/> structure used by <see cref="T:Eco.Shared.Networking.IWorldObserver"/> for representing view distance optimized for checks. <see cref="F:Eco.Shared.Networking.ViewDistance.Visible"/> is when object is visible in the view distance and <see cref="F:Eco.Shared.Networking.ViewDistance.NotVisible"/> is when object is out of view distance. It usually higher than <see cref="F:Eco.Shared.Networking.ViewDistance.Visible"/> value to avoid too adding and removing objects in the view.</summary>
        </member>
        <member name="M:Eco.Shared.Networking.ViewDistance.#ctor(System.Single,System.Single)">
            <summary>Creates new <see cref="T:Eco.Shared.Networking.ViewDistance"/> with <paramref name="visible"/> distance and <paramref name="invisibilityThreshold"/> when objects in view distance no more visible. <see cref="F:Eco.Shared.Networking.ViewDistance.NotVisible"/> calculated as <see cref="F:Eco.Shared.Networking.ViewDistance.Visible"/> + <paramref name="invisibilityThreshold"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.Clear">
            <summary>Stop moving along any routes, and clear targets.</summary>
        </member>
        <member name="P:Eco.Shared.Pathing.AITarget.TargetPosition">
            <summary> Returns either the target object position (if available) and updates <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> to last known position or returns <see cref="F:Eco.Shared.Pathing.AITarget.targetPos"/> with fallback to default value otherwise. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.TryGetTargetObject(Eco.Shared.Networking.INetObjectPosition@)">
            <summary> Returns <paramref name="targetObj"/> if it is set and available in <see cref="T:Eco.Shared.Networking.NetObjectManager"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetPosition(System.Numerics.Vector3)">
            <summary> Clear the route and set the position as passed. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Sets look to <paramref name="followingTarget"/>. If <paramref name="followingTarget"/> is null then resets look target. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.AITarget.SetLook(Eco.Shared.Math.Vector3i)">
            <summary> Sets look to fixed <paramref name="pos"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.SetRoute(Eco.Shared.Math.Route,System.Double)">
            <summary> Set the route, when we start, our speed, an an optional target to watch.</summary>
        </member>
        <member name="M:Eco.Shared.Pathing.RouteFollower.Position(System.Single)">
            <summary> Take the expected position at given time.</summary>
            <param name="lookAhead">Offset distance is adding to a calculated position.</param>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot">
            <summary>
            Returns unsafe list snapshot which may be directly accessed with <see cref="T:System.Collections.Generic.List`1"/> API.
            This list only safe to use before any modification operation like <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.Clear"/> etc.
            Also you should guarantee this list won't exceed current <see cref="P:System.Collections.Generic.List`1.Capacity"/> otherwise it may lead to unexpected behavior (including exceptions).
            </summary>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear">
            <summary>
            Returns current list snapshot and clear poolable list wrapper.
            </summary>
            <returns>Current snapshot. It may be null if Capacity == 0.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear(System.Collections.Generic.List{`0}@)">
            <summary>
            Outputs current list snapshot in <paramref name="snapshot"/> and clear poolable list wrapper. Returns a promise which should be disposed to return a list back to pool.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.ReturnSnapshot(System.Collections.Generic.List{`0})">
            <summary>
            Return previously rented snapshot (see <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.RentSnapshotAndClear"/>).
            This method is thread-safe. Usual case you rent list in thread-unsafe content and then return it in another thread.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot(System.Int32)">
            <summary>
            Same as <see cref="M:Eco.Shared.Pools.Collections.PoolableListWrapper`1.GetUnsafeListSnapshot"/>, but ensures required capacity.
            </summary>
            <param name="minimalCapacity">minimal required capacity for snapshot.</param>
            <returns>Current snapshot reference. It may be null if Capacity == 0.</returns>
        </member>
        <member name="T:Eco.Shared.Pools.FixedSizePool`1">
            <summary>Implementation of <see cref="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1"/> with extended functionality. Obsolete, should be replaced with <see cref="T:Eco.Shared.Pools.PoolService`1"/> when all functionality will be supported.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.FixedSizePool`1.TryAdd(`0)">
            <summary>Tries to add object to the pool (if enough capacity in the pool).</summary>
        </member>
        <member name="T:Eco.Shared.Pools.IObjectPool`1">
            <summary> Minimal Pool interface. If you wanna to have more advanced pool management you can use <see cref="T:Eco.Shared.Pools.PoolService`1"/>. </summary>
        </member>
        <member name="P:Eco.Shared.Pools.IObjectPool`1.Count">
            <summary> Current number of elements in pool. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.Get">
            <summary> Returns object from pool (if any) or <c>null</c> if pool is empty. It doesn't create new instance. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.IObjectPool`1.TryAdd(`0)">
            <summary> Tries to add <paramref name="obj"/> to pool. If succeed then it returns <c>true</c>, otherwise (if pool is full or object is incompatible with pool) it will return <c>false</c>. You can handle return value for final object cleanup. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ListPool`1.RentAndPromiseToReturn(System.Int32,System.Collections.Generic.List{`0}@)">
            <summary>Rents <paramref name="list"/> and promises to return it back to pool when <see cref="T:Eco.Shared.Pools.ListPool`1.ReturnPromise"/> disposed.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ListPool`1.Return(System.Collections.Generic.List{`0})">
            <summary>
            Use this with caution! If you will return list which was exceeded requested capacity then you can give an exception.
            </summary>
            <param name="list">list which was rented from pool.</param>
        </member>
        <member name="T:Eco.Shared.Pools.ListPool`1.ReturnPromise">
            <summary>Disposable return promise which returns <see cref="F:Eco.Shared.Pools.ListPool`1.ReturnPromise.Value"/> when disposed.</summary>
        </member>
        <member name="T:Eco.Shared.Pools.ObjectPoolExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> instances.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with default constructor for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass(), onReturn)]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(onReturn)]]></code>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.ObjectPoolExtensions.AsService``1(Eco.Shared.Pools.IObjectPool{``0},System.Func{``0},System.Action{``0})">
            <summary>
            Wraps <paramref name="pool"/> with <see cref="T:Eco.Shared.Pools.PoolService`1"/> with <paramref name="factory"/> for new pool elements and optional <paramref name="onReturn"/> cleanup method.
            With this factory method <code><![CDATA[new PoolService<MyClass>(new MyPool<MyClass>(), () => new MyClass("abc"))]]></code> can be rewritten as <code><![CDATA[new MyPool<MyClass>().AsService(() => new MyClass("abc"))]]></code>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.PooledMemoryStream">
            <summary>
            PooledMemoryStream (based on https://github.com/itn3000/PooledStream).
            It uses .NET Standard <see cref="T:System.Buffers.ArrayPool`1"/> for buffer allocations.
            Also it has <see cref="M:Eco.Shared.Pools.PooledMemoryStream.Truncate"/> which returns buffer to <see cref="T:System.Buffers.ArrayPool`1"/> and resets length, position and capacity to zero.
            It makes the stream reusable without holding extra memory for buffer.
            </summary>
        </member>
        <member name="F:Eco.Shared.Pools.PooledMemoryStream.Shared">
            <summary>Shared pool of <see cref="T:Eco.Shared.Pools.PooledMemoryStream"/> for zero-allocations <see cref="T:System.IO.MemoryStream"/> instances.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.GrowBuffer(System.Int32)">
            <summary>Grows <see cref="F:Eco.Shared.Pools.PooledMemoryStream.currentBuffer"/> to cover <paramref name="minimumRequired"/> bytes.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.PrepareWriteOperation(System.Int32)">
            <summary>Prepares write operation. Ensures capacity, fills uninitialized bytes if required between old length and current position, updates length if required and updates the position to a position after write operation. Returns write start position.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.SkipTo(System.Int32)">
            <summary>Clears skipped bytes from <see cref="F:Eco.Shared.Pools.PooledMemoryStream.length"/> to <paramref name="skipToPosition"/> if necessary.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.GetBuffer">
            <summary>
            This buffer is only valid until next Write or Reset operation.
            </summary>
            <returns>current buffer.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.PooledMemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
            <summary>Returns occupied array segment of memory stream buffer.</summary>
        </member>
        <member name="T:Eco.Shared.Pools.PoolService`1">
            <summary>
            <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> manager which simplifies pool usage, adding methods for automatic objects creation and cleaning up when returned to pool.
            When <see cref="T:Eco.Shared.Pools.PoolService`1"/> created you should provide <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/> method for new object instantiation (if pool is empty) and optionally
            <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method which will be called on an object when it returned (added) to pool.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Rent">
            <summary> Rents object from pool or creates new instance using <see cref="F:Eco.Shared.Pools.PoolService`1.factory"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.Return(`0)">
            <summary>
            Returns (add) <paramref name="value"/> to the pool. If <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> method was provided then it will be called on <paramref name="value"/> <b>before</b> adding to pool.
            Also it may fail to add <paramref name="value"/> to <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> (in example if <see cref="F:Eco.Shared.Pools.PoolService`1.pool"/> is fixed size and already full).
            In this case <see cref="F:Eco.Shared.Pools.PoolService`1.onReturn"/> will be called anyway, but method return <c>false</c>. It returns <c>true</c> if object was actually added to pool, you can check return value for final object cleanup.
            </summary>
        </member>
        <member name="M:Eco.Shared.Pools.PoolService`1.RentAndPromiseToReturn(`0@)">
            <summary>
            <c>using</c> operator friendly <see cref="M:Eco.Shared.Pools.PoolService`1.Rent"/>.
            One of common cases is when you need to rent an object only for scope of the function and then return it by the end of the function like:
            <code>
            void MyFunc()
            {
                var obj = poolService.Rent();
                try
                {
                    DoSomethingWithObject(obj);
                }
                finally
                {
                    poolService.Return(obj);
                }
            }
            </code>
            This method let you optimize a layout and don't care about <c>Return</c> by the end of function like:
            <code>
            void MyFunc()
            {
                using var promise = poolService.RentAndPromiseToReturn(out var obj);
                DoSomethingWithObject(obj);
            }
            </code>
            or
            <code>
            void MyFunc()
            {
                using (poolService.RentAndPromiseToReturn(out var obj))
                    DoSomethingWithObject(obj);
            }
            </code>
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafeFixedSizePool`1">
             <summary>
             Fixed Size Pool used to avoid any extra-GC allocations, unless requesting more items from pool than are available.
             It uses circular buffer where
             `tail` points to first element which will be retrieved from pool on request (read position)
             `head` points to next write position which will be used for returning element to pool (write position)
             when `head` == `tail` then buffer is empty
             when `head` == `tail - 1` then buffer is full
             we're using `poolSize + 1` for capacity to maintain full buffer scenario, because otherwise we can have two situations when write position == read position (empty and full).
            
             Performance:
             ~2x faster in concurrent environment than basic Stack based pool implementation with lock
             ~10% faster in single-thread environment than basic Stack based pool implementation with lock.
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.MaxSize">
            <summary>Max number of elements in the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.Get">
            <summary>
            Returns a object from the pool or null if no objects in the pool.
            </summary>
            <returns>object from the pool or a new object.</returns>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.TryAdd(`0)">
            <summary>
            Tries to add object to the pool (if enough capacity in the pool).
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:Eco.Shared.Pools.ThreadSafeFixedSizePool`1.Clear">
            <summary>Clears cache.</summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadSafePool`1">
            <summary>
            Simple thread-safe <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            For optimal performance you should prefer thread-safe lock free <see cref="T:Eco.Shared.Pools.FixedSizePool`1"/>, but it has fixed pool size and can't be shrink or extended.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has fixed pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize">
            <summary>
            Max number of elements in pool.
            It actually may be less than actual number of elements if <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/> was reduced when <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> &gt; <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            In this case it will not add objects with <see cref="M:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.TryAdd(`0)"/> until <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.Count"/> go below <see cref="P:Eco.Shared.Pools.ThreadUnsafeFixedSizePool`1.MaxSize"/>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Pools.ThreadUnsafePool`1">
            <summary>
            Thread-unsafe lock free <see cref="T:System.Collections.Generic.Stack`1"/> based pool implementation. It implements <see cref="T:Eco.Shared.Pools.IObjectPool`1"/> interface and has unlimited pool size.
            You should prefer it to use over thread-safe pool implementations where you're sure it won't be used from multiple threads (in example in Unity components).
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.PoolableListEnumerator`1">
            <summary> This allows to iterate through list with return to the pool after end. 
            Uesfull for iterations over not-thread-safe collections in multithread environment. It will create a copy of collection by using lock and pooled list and it will automaticly return the list after Dispose is called. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.ActionRef`1">
            <summary>For when you want a ref type in a callback.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2D`1.Select``1(System.Func{Eco.Shared.Math.Vector2i,`0,``0})">
            <summary>Transforms the map using the given transformation function.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2D`1.ForEachRef(Eco.Shared.Utils.ActionRef{`0,Eco.Shared.Math.Vector2i})">
            <summary>Runs a function on each entry, but accepts the value by ref so it can change the array</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2D`1.ReadFromStream(System.IO.MemoryStream)">
            <summary>Creates <see cref="T:Eco.Shared.Utils.Array2D`1"/> from <paramref name="stream"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2DExtensions.Normalize(Eco.Shared.Utils.Array2D{System.Single})">
            <summary>Special funciton for float array2ds, normalize them so all values add up to 1.</summary>
            <param name="array"></param>
        </member>
        <member name="T:Eco.Shared.Utils.Array2DExtensions.BlendFunc`1">
            <summary>Multiplies 'input' by 'mult' and stores it in 'output'.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Array2DExtensions.GeneratedBlurredArray``1(Eco.Shared.Utils.Array2D{``0},System.Int32,Eco.Shared.Utils.Array2DExtensions.BlendFunc{``0})">
            <summary>Perform a simple blur. Kernel must be odd and >= 3. Returns the blurred array.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtils.CreateWithNewEntries``1(System.Int32)">
            <summary>Create an array of the given size, and instantiate the given type into each entry.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.AssertInterpolatedStringHandler">
            <summary>Provides an interpolated string handler for <see cref="M:Eco.Shared.Utils.DebugUtils.Assert(System.Boolean,Eco.Shared.Utils.AssertInterpolatedStringHandler@)"/> that only performs formatting if the assert fails. Based on <see cref="T:System.Diagnostics.Debug.AssertInterpolatedStringHandler"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.AssertInterpolatedStringHandler.stringBuilderHandler">
            <summary>The handler we use to perform the formatting.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.#ctor(System.Int32,System.Int32,System.Boolean,System.Boolean@)">
            <summary>Creates an instance of the handler..</summary>
            <param name="literalLength">The number of constant characters outside of interpolation expressions in the interpolated string.</param>
            <param name="formattedCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="condition">The condition Boolean passed to the <see cref="T:System.Diagnostics.Debug"/> method.</param>
            <param name="shouldAppend">A value indicating whether formatting should proceed.</param>
            <remarks>This is intended to be called only by compiler-generated code. Arguments are not validated as they'd otherwise be for members intended to be used directly.</remarks>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.ToStringAndClear">
            <summary>Extracts the built string from the handler.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendLiteral(System.String)">
            <summary>Writes the specified string to the handler.</summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted``1(``0)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted``1(``0,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>Writes the specified character span to the handler.</summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>Writes the specified string of chars to the handler.</summary>
            <param name="value">The span to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:Eco.Shared.Utils.AssertInterpolatedStringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <param name="alignment">Minimum number of characters that should be written for this value.  If the value is negative, it indicates left-aligned and the required minimum is the absolute value.</param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetValue(`0,`1@)">
            <summary> Tries to get <paramref name="val"/> by the <paramref name="key"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary> Tries to get <paramref name="key"/> by the <paramref name="val"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.ReplaceZigZag(System.IO.BinaryWriter,System.Int32,System.Int32,System.Int32)">
            <summary>
            Replaces previously encoded <paramref name="oldValue"/> with <paramref name="newValue"/> at <paramref name="position"/>. To perform this operation <paramref name="writer"/> backing stream should be <see cref="T:System.IO.MemoryStream"/>.
            Length of encoded number may be different, in this case data after encoded number will be shifted left or right.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.EncodeZigZag(System.IO.BinaryWriter,System.UInt32)">
            <summary>
            Encodes <paramref name="value"/> to <paramref name="writer"/> using zig-zag encoding which minimizes number of bytes to represent the number.<br/>
            1. If the number below 128 then it just serialize it as single byte.<br/>
            2. Otherwise it will set the flag 0x80 for first byte, divide the number by 128 and repeat from step 1.<br/>
            In best case we have 1 byte (0-127).
            In worst case we have 5 bytes (the number &gt;268 435 456).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.IO.BinaryWriter,System.Int32)">
            <inheritdoc cref="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.Int32)"/>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryWriterExtensions.GetZigZagLength(System.Int32)">
            <summary>Returns number of bytes required to encode the <paramref name="value"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BinaryUtils">
            <summary> Utility methods to work with binary number representation. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryUtils.CountOfSetBits(System.Int32)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BinaryUtils.CountOfSetBits(System.UInt64)">
            <summary> Counts set bits in a number. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BitReader">
            <summary>
            This class provides functionally to read bit-wide values, tracking <c>bitOffset</c> (in opposite to byte-wide values for regular <see cref="T:System.IO.MemoryStream"/> or byte array).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            Reads boolean from byte array using <c>bitPosition</c>. Boolean represented as single bit.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>boolean value. <c>true</c> - if bit was 1, <c>false</c> - otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadByte(System.Byte[],System.Int32@)">
            <summary>
            Reads a byte value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Reads a ushort value from byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">byte array.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.BitReader.BitReadBytes(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads a byte array from a source byte array using <c>bitPosition</c>. It may have offset within a byte.
            </summary>
            <param name="buffer">source byte array.</param>
            <param name="length">number of bytes to read.</param>
            <param name="bitPosition">position in array in bits.</param>
            <returns>result byte array.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.BitWriter">
            <summary>
            This class provides functionally to write bit-wide values, tracking bitOffset (in opposite to byte-wide values for regular MemoryStream).
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.ByteArrayReader">
            <summary>
            Utility class to read structured data from byte array.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadByte(System.Byte[],System.Int32@)">
            <summary>
            Read a byte from byte array using provided offset.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded byte value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt32ZigZag(System.Byte[],System.Int32@)">
            <summary>
            Read a unsigned int from data array zig zag encoded.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded unsigned int value.</returns>
            <exception cref="T:System.Exception">if value can't be decoded from byte array.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a short value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded short value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a int value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded int value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadInt64(System.Byte[],System.Int32@)">
            <summary>
            Read a long value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded long value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt16(System.Byte[],System.Int32@)">
            <summary>
            Read a ushort value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded ushort value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadUInt32(System.Byte[],System.Int32@)">
            <summary>
            Read a uint value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded uint value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadDouble(System.Byte[],System.Int32@)">
            <summary>
            Read a double value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded double value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadVector3(System.Byte[],System.Int32@)">
            <summary>
            Read a vector3 value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadSingle(System.Byte[],System.Int32@)">
            <summary>
            Read a float value from data array. Always uses LittleEndian.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded float value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadString(System.Byte[],System.Int32@)">
            <summary>
            [str len:zig zag uint][str:utf-8 encoded byte array]
            Reads a string from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded string.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadBoolean(System.Byte[],System.Int32@)">
            <summary>
            [0 - false/1 - true:byte]
            Reads a boolean value from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded boolean value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadGuid(System.Byte[],System.Int32@)">
            <summary>
            [guid:byte[16]]
            Reads a Guid from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded Guid.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteArrayReader.ReadIPEndPoint(System.Byte[],System.Int32@)">
            <summary>
            [address length:byte][address bytes:byte array][port:ushort]
            Reads a IP end point from byte array using provided <c>offset</c>.
            </summary>
            <param name="data">byte array.</param>
            <param name="offset">reference to offset, will be modified to next read position.</param>
            <returns>decoded IP endpoint.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.Binary.ByteSpanReader">
            <summary>
            Wraps <see cref="T:System.ReadOnlySpan`1"/> as source for binary data.
            When Read* operation used then it changes internal state and so you need to avoid copy this struct if you need to keep reading position.
            But similar if you copy it before Read operation(s) then you can use original copy for read position reset.
            </summary>
        </member>
        <member name="P:Eco.Shared.Utils.Binary.ByteSpanReader.BytesLeft">
            <summary>Returns how much bytes left for read.</summary>
        </member>
        <member name="P:Eco.Shared.Utils.Binary.ByteSpanReader.UnreadSpan">
            <summary>Returns unread span. Changes after every read operation.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadByte">
            <summary>Read next byte from the reader and advance read position by 1.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt32ZigZag">
            <summary>Read an unsigned int from the reader zig zag encoded and advance read position by 1-5 bytes (depending on how large is number).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt16">
            <summary>Read a short value from the reader and advance read position by 2. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt32">
            <summary>Read an int value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadInt64">
            <summary>Read a long value from the reader and advance read position by 8. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt16">
            <summary>Read a unsigned short value from the reader and advance read position by 2. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadUInt32">
            <summary>Read a unsigned int value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadDouble">
            <summary>Read a double value from the reader and advance read position by 8. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadVector2">
            <summary>Read a <see cref="T:Eco.Shared.Math.Vector2"/> from the reader and advance read position by 8 (2 x float).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadVector3">
            <summary>Read a <see cref="T:System.Numerics.Vector3"/> from the reader and advance read position by 12 (3 x float).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadSingle">
            <summary>Read a double value from the reader and advance read position by 4. Always uses LittleEndian.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadString">
            <summary>
            [str len:zig zag uint][str:utf-8 encoded byte array]
            Reads a string from the reader and advance read position by string length and encoded length size.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBoolean">
            <summary>
            [0 - false/1 - true:byte]
            Reads a boolean value from the reader and advance read position by 1.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadGuid">
            <summary>
            [guid:byte[16]]
            Reads a Guid from the reader  and advance read position by 16.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadIPEndPoint">
            <summary>
            [address length:byte][address bytes:byte array][port:ushort]
            Reads an IP end point from the reader and advances position (depending on size of encoded endpoint).
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBytesTo(System.Span{System.Byte})">
            <summary>Reads <paramref name="destination"/> length bytes to <paramref name="destination"/>. Fails if not enough bytes to read.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.ReadBytesTo(System.IO.Stream,System.Int32)">
            <summary>Reads <paramref name="count"/> bytes to <paramref name="output"/>. Fails if not enough bytes to read.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Binary.ByteSpanReader.Skip(System.Int32)">
            <summary>Skips <paramref name="count"/> bytes.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.BlockLayout">
            <summary>A set of blocks represented by dictionary of block positions mapped to block IDs. Used in blueprints and multi-block placement.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.BlockLayout.SetValue(Eco.Shared.Math.Vector3i,System.UInt16)">
            <summary> Set the block ID of a relative position, overwriting any existing block ID. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BlockLayout.RemoveValue(Eco.Shared.Math.Vector3i)">
            <summary> Clear the block from the given position if it is set.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.BlockLayout.TryGetValue(Eco.Shared.Math.Vector3i,System.UInt16@)">
            <summary> Gets the block ID for the given position if it exists. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BlockLayout.Clear">
            <summary> Clear all block IDs from the blueprint. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.BlockLayout.SetFromRangeAndBlockId(System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.UInt16)">
            <summary> Sets the blueprint to all the blocks of the range, relative to WorldRange.min, set to the given block ID. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ClusteringAlgos.CalculateClusters(Eco.Shared.Utils.Array2D{System.Single},Eco.Shared.Utils.ClusteringAlgos.KMeansSettings)">
            <summary>Finds a list of clusters given the passed in settings.
            The algorithm here is Mean-Shift Clustering, described here: https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68</summary>
        </member>
        <member name="T:Eco.Shared.Utils.CommandLine">
             <summary>
             Class for getting arguments from command line. Arguments are not case sensitive.
            
             Excpected syntax of parameters:
             * -arg
             * -arg="value"
             * -arg.subarg="value"
             </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.SetCmdLine(System.String)">
            <summary>Sets command line from unparsed <paramref name="commandLine"/> string.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValuelessArg(System.String)">
            <summary> Gets whether an argument is set or not. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CommandLine.GetValueArg(System.String)">
            <summary> Gets the value for a given argument is set, null otherwise. Not case sensitive. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress(System.Byte[])">
            <summary>Decompresses <paramref name="compressed"/> data to uncompressed byte array.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress``1(System.ReadOnlySpan{System.Byte},System.Func{System.IO.MemoryStream,``0})">
            <summary>Decompresses <paramref name="data"/> and then converts it to <typeparamref name="TResult"/> using provided <paramref name="converter"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CompressionUtils.Decompress``2(System.ReadOnlySpan{System.Byte},``0,System.Func{System.IO.MemoryStream,``0,``1})">
            <summary>Decompresses <paramref name="data"/> and then converts it to <typeparamref name="TResult"/> using provided <paramref name="converter"/>. Supports custom context.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddNonNull``1(System.Collections.Generic.ISet{``0},``0)">
            <summary>Add to the hashset if it's not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddNonNullKey``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Add to the dictionary if the key is not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RandomWeighted``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>Picks random element from list based on weights</summary>
            <param name="weightSelector"> weight to be evaluated </param>
            e.g.: [(Salmon, 50), (Crab, 10)] salmon has bigger chance than crab
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RemoveAll``2(System.Collections.Generic.List{``0},``1,System.Action{``0})">
            <summary>
            Removes first item in <paramref name="list"/> matching <paramref name="matcher"/> and calls <paramref name="onRemove"/> action if provided for the removed item.
            This method may be used with allocation-free struct based predicates instead of closures. Also it may inline predicate body for better performance.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RemoveFirst``2(System.Collections.Generic.List{``0},``1,System.Action{``0})">
            <summary>
            Removes first item in <paramref name="list"/> matching <paramref name="matcher"/> and calls <paramref name="onRemove"/> action if provided for the removed item.
            This method may be used with allocation-free struct based predicates instead of closures. Also it may inline predicate body for better performance.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RemoveFirst``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Removes first item matching the <paramref name="matcher"/>. Returns <c>true</c> if item was removed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.AddOrReplace``1(System.Collections.Generic.IList{``0},``0,System.Predicate{``0})">
            <summary>Replaces first element matching the <paramref name="matcher"/> with <paramref name="item"/> or adds new <paramref name="item"/> if no one matched.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FirstOfTypeOrDefault``2(System.Collections.Generic.List{``0})">
            <summary> Returns first item of type <typeparamref name="T"/> or default value if not found. It is a list specific implementation to avoid GC-allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.Median``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="list"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of list to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.NullIndices``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns an enumerable of each index that has a null value in the passed list.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FindNearestValue``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,System.Single})">
            <summary>Finds nearest value in collection</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FindNearestValueAndDistance``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,System.Single})">
            <summary>Finds nearest value and distance in collection</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FindNearestValueIndex``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,System.Single})">
            <summary>Finds nearest value index in collection</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.FindNearestValueIndexAndDistance``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,System.Single})">
            <summary>Finds nearest value index and distance in collection</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListExtensions.RotateLeft``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>"Rotates" list by <paramref name="offset"/>. Every element has it's index shifted left by offset, if it results in negative index then it pushes to end of the list.</summary>
            <example><code>
            new[] { 1, 2, 3, 4 }.RotateLeft(2) // => 3, 4, 1, 2
            </code></example>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayExtensions.CurveOrder``1(``0[])">
            <summary>Pass forward sorted array for large middle numbers for example {1,2,3,4,5} would be {1,3,5,4,2}, or reverse sorted array for large side numbers for example {5,4,3,2,1} would be {5,3,1,2,4}, this is useful for aligning trees based on depth, this is a special iterator that jumps through enumerable check this explanation: https://stackoverflow.com/a/3796619</summary>
            <example>One of the cases this is used on is the tech tree visualizer where nodes with higher total rank go in the top and bottom for a better aethestic and line drawing:
            <code>listToOrder.OrderByDescending(tree => GetTotalRank(tree)).ToArray().CurveOrder();</code>
            </example>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AddOrUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1,System.Func{``1,``1,``1})">
            <summary>Add a new element to a dictionary, or update an existing one if the key already exists.
            <paramref name="updateFunc"/> is a function that accepts the existing value and passed value, and returns the new value to store.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AddDefaultIfNeededThenUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1,``1})">
            <summary>Add a default entry to a dictionary if it doesnt exist. Then, whether or not it existed, updated it.</summary>
            <param name="updateFunc">Accepts the current value and returns the new value to store in the dictionary</param>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AddIfNeededThenUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1,``1},System.Func{``1})">
            <summary>Add an entry to a dictionary if it doesnt exist, using the past 'addFunc' to create it. Then, whether or not it existed, updated it.</summary>
            <param name="updateFunc">Accepts the current value and returns the new value to store in the dictionary</param>
            <param name="addFunc">Function to create the new entry. If null, use the 'default' value.</param>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.AllValues``2(System.Collections.Generic.Dictionary{``0,``1},System.Predicate{``1})">
            <summary>
            Checks if all values in <paramref name="dict"/> matches <paramref name="predicate"/>.
            We are using explicit <see cref="T:System.Collections.Generic.Dictionary`2"/> here and don't use LINQ to avoid garbage creation for enumerator.
            We are using this method in Unity, so it is critical to not have extra GC-allocations.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.Update``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Updates <paramref name="dictionary"/> with all entries from <paramref name="entries"/>. Not existing entries will be created and matching existing entries overwritten.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.DictionaryExtensions.LeftJoin``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary> returns new dictionary with all left values and adds right distinct ones </summary>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.DequeueIntoList``1(System.Collections.Generic.Queue{``0},System.Int32)">
            <summary>Deque a given number of elements into a list.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.List{``0})">
            <summary>
            Optimized non-alloc version of <see cref="M:Eco.Shared.Utils.QueueExtensions.AddRange``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.IEnumerable{``0})"/>.
            Because <see cref="M:System.Collections.Generic.List`1.GetEnumerator"/> returns struct <see cref="T:System.Collections.Generic.List`1.Enumerator"/>, but <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> returns <see cref="T:System.Collections.Generic.IEnumerator`1"/> as boxed version of <see cref="T:System.Collections.Generic.List`1.Enumerator"/>.
            </summary>
            <param name="queue">destination queue.</param>
            <param name="list">list to add.</param>
            <typeparam name="T">item type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.Set``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Clear the hash set and assign it the new set.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if <paramref name="source"/> collection contains any value from <paramref name="values"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.CollectionExtensions.AddNotNull``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>Adds element to <paramref name="collection"/> only if it isn't null. Returns <c>true</c> if element was added.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.ValuesAtX``1(``0[0:,0:],System.Int32)">
            <summary>Returns the columns of the given row index</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.ValuesAtY``1(``0[0:,0:],System.Int32)">
            <summary>Returns the rows of the given column index</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.SetValuesAtX``1(``0[0:,0:],System.Int32,``0)">
            <summary>Assigns the given value to the whole row</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.SetValuesAtY``1(``0[0:,0:],System.Int32,``0)">
            <summary>Assigns the given value to the whole column</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ArrayUtil.MakeNew``1(System.Int32)">
            <summary> Make an array and fill it with 'new'd entries. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListUtil.TakeAndCalculateForRest``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32})">
            <summary>Take First numToTake of items in IEnumerable and apply function doForRest on the elements left in IEnumerable.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListUtil.TakeSelectAndCalcRest``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1},System.Func{``0,System.Int32})">
            <summary>Take first <paramref name="numToTake"/> of items in IEnumerable, transform it with Func <paramref name="doWithTaken"/> and apply Func <paramref name="doForRest"/> on the elements left in IEnumerable.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ListUtil.ConvertToBits``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>Converts container into 64bit data.</summary>
            <remarks>Saves the bit if container element comparer returns true</remarks>
            <param name="compareFunc">Comparer for saving the bit</param>
            <exception cref="T:System.IndexOutOfRangeException">If container size is more than 64</exception>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.First``1(System.Collections.Generic.HashSet{``0})">
            <summary> No alloc version of Enumerable.First() for HashSet. </summary>
            <exception cref="T:System.InvalidOperationException">If no elements in HashSet.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.MapGroupingKey``3(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``2}},System.Func{``0,``1})">
            <summary> Maps <see cref="T:System.Linq.IGrouping`2"/> key to new value (in example id may be resolved to name). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.IgnoreRepeats``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Returns the passed enumerable omitting any entries repeated in the sequence. Only checks sequential repeats, not list-wide repeats (like 'Distinct()' would).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.EnumerableElementAt(System.Collections.IEnumerable,System.Int32)">
            <summary>Get the element at the given index, or null. Note that this is O(N), and should only be used when generic version of IEnumerable isnt available.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.EnumerableIndexOf(System.Collections.IEnumerable,System.Object)">
            <summary>Return the index of the given value in a non-generic enumerable. Note that this is O(N), and should only be used when generic version of IEnumerable isnt available.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SetExtensions.CompareAll``1(System.Collections.Generic.List{``0},System.Action{``0,``0})">
            <summary>Execute a comparison between every element in the list (not caring for ordering)</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Delegates">
            <summary>Helper methods for delegates.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Delegates.InterlockedAddAssign``1(``0@,``0)">
            <summary>Atomic thread-safe alternative to += operator.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Delegates.InterlockedSubtractAssign``1(``0@,``0)">
            <summary>Atomic thread-safe alternative to -= operator.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.DelegateWrapper`1">
            <summary>
            Intended to be used as base class for delegate wrapper which implements some interface.
            It implements equality operations and holds delegate references.
            It helps to avoid creating similar classes only differing by interface method implementation.
            </summary>
            <example>
            This sample shows how it may be used with <see cref="T:System.IComparable`1"/> interface.
            <code>
            class IntComparableWrapper : DelegateWrapper&lt;Func&lt;int, int&gt;&gt;, IComparable&lt;int&gt;
            {
               public IntComparableWrapper(Func&lt;int, int&gt; func) : base(func) { }
               int CompareTo(int value) => this.Delegate(value);
            }
            </code>
            </example>
        </member>
        <member name="T:Eco.Shared.Utils.DisposableUtils.DisposableActionEnumerator`1">
            Provides an enumerator which will execute an action when it is disposed (such as after a foreach loop)
        </member>
        <member name="T:Eco.Shared.Utils.EcoTagToHTMLConverter">
            <summary>Extension methods for converting Eco tag strings to HTML tag based equivilants.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EcoTagToHTMLConverter.ToHTML(System.String,System.Boolean)">
            <summary>Converts a Eco text string to a HTML string for use by Vue/HTML5</summary>
            <param name="input">String to convert.</param>
            <param name="stripFoldouts">Flag used to strip foldout tags. Defaults to false.</param>
            <returns>Converted string ready for use in HTML.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Tries to get first element from enumerable (if exists).</summary>
            <returns><c>true</c> if <paramref name="enumerable"/> is not empty and <paramref name="element"/> contains the first element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary> Gets the first value matching <paramref name="predicate"/> into an out var, returning true if found. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary> Gets the single value into an out var, returning true if found only one value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary> Gets the single value matching <paramref name="predicate"/> into an out var, returning true if found only one value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirstFromEnumerator``1(System.Collections.Generic.IEnumerator{``0},System.Func{``0,System.Boolean},``0@)">
            <summary>Internal helper for <see cref="M:Eco.Shared.Utils.EnumerableExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)"/> and <see cref="M:Eco.Shared.Utils.EnumerableExtensions.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)"/>. Tries to find first item matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.EnumerableExtensions.CastMethods">
            <summary>Cache for <see cref="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)"/> method.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AnyNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Checks if collection contains at least 1 not null element </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Same as <see cref="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but returns <c>null</c> if both are <c>null</c> and <paramref name="nullAllowed"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ConcatNullSafe``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concat two enumerable if possible (both not null). If any enum is null then it will be omitted from concatenation and only non-null enumerable elements will be returned.
            If both null then it will return empty enumerable.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.MinObj``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>Returns first item with minimal value of <paramref name="distanceFunc"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.TryGetMinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``0@)">
            <summary>Tries to get minimal element from <paramref name="enumerable"/> if it has elements. Returns <c>false</c> otherwise.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.MinRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary> Returns up to <paramref name="n"/> minimal elements from <paramref name="enumerable"/>. From smallest to larger. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Any``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary> Specialized version for <see cref="T:System.Collections.Generic.List`1"/>. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.FirstOfTypeOrDefault``1(System.Collections.IList)">
            <summary> Returns first value in list of type <typeparamref name="T"/> or default value. No allocations. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.Dictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary.
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{System.Collections.Generic.KeyValuePair{``0,``1},``2})">
            <summary>
            Calls action for each entry with the context for a dictionary preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="dict">dictionary.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="TKey">key type.</typeparam>
            <typeparam name="TValue">value type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.List{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with the context for a list.
            </summary>
            <param name="list">list.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls action for each element with context preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="enumerable">enumerable.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ParallelForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            Calls parallel action for each element with context preferring no-alloc enumerator version (avoiding boxing).
            </summary>
            <param name="enumerable">enumerable.</param>
            <param name="context">context.</param>
            <param name="action">action.</param>
            <typeparam name="T">item type.</typeparam>
            <typeparam name="TContext">context type.</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Median``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary> Returns median value for <paramref name="enumerable"/>. If <paramref name="sorted"/> is <c>false</c> then it makes sorted copy of enumerable to find the median otherwise it just returns medium element. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.ToDictionaryWithDistinctKeys``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary> Same as ToDictionary, but only adds entry with first distinct key. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AsCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Represents enumerable as <see cref="T:System.Collections.Generic.ICollection`1"/> avoiding copy creation if not necessary. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.AsReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Represents enumerable as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> avoiding copy creation if not necessary. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.Cast(System.Collections.IEnumerable,System.Type)">
            <summary>Casts <paramref name="enumerable"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/>. Is useful when you need to cast to specific runtime type, but can't use generic type arguments.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.FallbackIfEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Fallback to another enumerable provided by <paramref name="fallbackProvider"/> if <paramref name="enumerable"/> is empty.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumerableExtensions.NullableExcept``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Improved version of <see cref="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but with nullable <paramref name="except"/> support. If it is <c>null</c> then <paramref name="source"/> returned unmodified.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.EnumUtils">
            <summary>Utility classes for interacting with Enum instances.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.ToEnumMap``2(System.Collections.Generic.IList{``1})">
            <summary> Maps the contents of an array or a list to a Dictionary of specified enum type. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.SequentialEntries``1">
            <summary>Returns a <seealso cref="T:System.Collections.Generic.IEnumerable`1"/> instancing containing the distinct etnries of an Enum object ordered by value.</summary>
            <typeparam name="T">Enum type to retrieve the values from</typeparam>
            <returns><seealso cref="T:System.Collections.Generic.IEnumerable`1"/> instance containing the distinct values ordered by value.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.GetEnumDescriptions``1">
            <summary> Gets All descriptions From Enum Type of Enum Values if they have LocDescriptionAttibure else returns null</summary>
            <typeparam name="T"> Enum Type to Get descriptions from</typeparam>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.GetEnumDescriptions(System.Type)">
            <summary> Gets All descriptions From Object of type Type of Enum Values if they have LocDescriptionAttibure else returns null</summary>
            <param name="type">Tyep Object to get descriptions from</param>
        </member>
        <member name="M:Eco.Shared.Utils.EnumUtils.HasAttribute``1(System.Enum,System.Boolean)">
            <summary>Checks if enum value has an attribute</summary>
        </member>
        <member name="T:Eco.Shared.Utils.EnumUtils.EnumInfo`1">
            <summary>Cached information about <see cref="T:System.Enum"/> type. Makes names, values and count requests much cheaper.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.EventUtils.RaiseEvent``1(System.Object,System.String,``0)">
            <summary>Allows raising an event on object from an external party, via reflection.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExceptionUtils.TryFindExceptionOfType``1(System.Exception,``0@)">
            <summary>Recursively tries to find exception of type <typeparamref name="T"/> for the <paramref name="exception"/>. It may be <paramref name="exception"/> itself or one of it's inner exceptions.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExceptionUtils.TryFindExceptionOfType``1(System.AggregateException,``0@)">
            <summary>Recursively tries to find exception of type <typeparamref name="T"/> in <paramref name="exception"/> inner exceptions.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ExpressionUtils">
            <summary>Utility and helper methods for <see cref="T:System.Linq.Expressions.Expression"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ExpressionUtils.IndexedProperty(System.Linq.Expressions.Expression,System.String)">
            <summary>Creates indexed property expression (e.g. instance[index]).</summary>
        </member>
        <member name="T:Eco.Shared.Utils.FastMath">
            <summary>
            Fast but not so precise math, it uses approximation for expensive functions (like pow). It may vary in 5-10% of original value, but it may be OK for some scenarios.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.FastMath.FastAndDirtyPow(System.Double,System.Double)">
            <summary>
            Calculates fast and dirty power of value. In worst cases it may have error up-to 25% (for big power value), but usually within 5%-12%.
            It is faster than regular pow in 23 times for Java (didn't test for C#).
            More details here https://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/.
            </summary>
            <param name="value"></param>
            <param name="pow"></param>
            <returns></returns>
        </member>
        <member name="T:Eco.Shared.Utils.ForceStartEndComparer">
            <summary>
            Forces a given string name to be the first in the list. The rest of the list is sorted alphabetically.
            </summary>
            <seealso cref="T:System.IComparable`1"/>
        </member>
        <member name="T:Eco.Shared.Utils.FuncPredicate`1">
            <summary>Simple wrapper around <see cref="T:System.Func`2"/> delegate implementing <see cref="T:Eco.Shared.Utils.IPredicate`1"/> interface.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.GeneralUtils.IsDefault``1(``0)">
            <summary>Tests if a given value is the default.  Used for structs. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.GeneralUtils.TypeIsFullyGeneric(System.Type)">
            <summary>We check whether the definition of a generic type is actually generic or not. This will also return true when the generic type has all its arguments as generic.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.GeneralUtils.IsGenericDefinitionOfType(System.Type,System.Type)">
            <summary>We check whether the current type is the generic type definition of the specified type or any of its parents.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.GeneralUtils.TypeGenericDefinitionIs(System.Type,System.Type)">
            <summary>Check whether the current type has the specified generic type definition or not.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.GlobalRandom">
            <remarks>
            Exposed implementation of Global Random from MoreLinq to be publicly available.
            <see cref="T:System.Random"/> is not thread-safe so the following
            implementation uses thread-local <see cref="T:System.Random"/>
            instances to create the illusion of a global
            <see cref="T:System.Random"/> implementation. For some background,
            see <a href="https://blogs.msdn.microsoft.com/pfxteam/2009/02/19/getting-random-numbers-in-a-thread-safe-way/">Getting
            random numbers in a thread-safe way</a>
            </remarks>
        </member>
        <member name="T:Eco.Shared.Utils.Grouping`2">
            <summary> Simple implementation of <see cref="T:System.Linq.IGrouping`2"/> which allows us to make grouping remapping (like resolving key to string or filtering elements). </summary>
        </member>
        <member name="T:Eco.Shared.Utils.IBidirectionalMap`2">
            <summary>Interface for bi-directional maps which allow to access key by value in addition to usual by key lookup.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.TryGetByValue(`1,`0@)">
            <summary>Lookups key by value.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.ContainsValue(`1)">
            <summary>Checks if value is in map.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,System.Func{`1})">
            <summary>Gets value by key or adds new mapping if not exits. Value will be created with <paramref name="valueFactory"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.GetOrAdd(`0,`1)">
            <summary>Gets value by key or adds new mapping if not exits.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IBidirectionalMap`2.TryAdd(`0,`1)">
            <summary>Tries to add two-way mapping between <paramref name="key"/> and <paramref name="value"/>. Fails if either key or value already exists in the dictionary.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ILogWriter">
            <summary>Interface for different log writer implementations.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ILogWriter.ErrorInfo">
            <summary>
            <see cref="T:Eco.Shared.Utils.ILogWriter.ErrorInfo"/> for error messages. It may be used for separate access to <see cref="F:Eco.Shared.Utils.ILogWriter.ErrorInfo.Message"/> and <see cref="F:Eco.Shared.Utils.ILogWriter.ErrorInfo.Exception"/> or to obtain cached <see cref="P:Eco.Shared.Utils.ILogWriter.ErrorInfo.MessageWithException"/>.
            Main purpose of this struct to avoid expensive <see cref="P:Eco.Shared.Utils.ILogWriter.ErrorInfo.MessageWithException"/> build if there multiple log consumers.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ILogWriter.ErrorInfo.WithException(System.String,System.Exception)">
            <summary>Extends <paramref name="message"/> with <paramref name="ex"/> stack trace.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.LogWriterExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.Utils.ILogWriter"/> for direct message logging.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ImmutableCountdown">
            <summary> An immutable timer that is sycned with the client and doesn't require ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ImmutableCountdown.Create(System.Double,System.Double,System.Boolean)">
            <summary> Creates <see cref="T:Eco.Shared.Utils.ImmutableCountdown"/> either paused or running with <paramref name="duration"/> and <paramref name="timeLeft"/>. <paramref name="timeLeft"/> should be less or equal to duration. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.TrySubNonNegative(System.Int32@,System.Int32)">
            <summary>
            Tries to subtract value from location. It only happen if location won't become negative (value &lt;= location).
            </summary>
            <param name="location">location to modify.</param>
            <param name="value">value to subtract.</param>
            <returns>true - if location >= value, location -= value; false - otherwise, location won't be modified.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Int32@,System.Int32)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.SubMinNonNegative(System.Single@,System.Single)">
            <summary>
            Atomic operation to subtract `value` from `location`, or if value > location then subtract location (make it 0). It returns actual subtracted value.
            Basic formula: value > location ? location = 0, return old_location_value : location -= value, return value.
            </summary>
            <param name="location">location to change.</param>
            <param name="value">value to subtract.</param>
            <returns>subtracted value: min(location, value).</returns>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.AssertTypeCompatible``1">
            <summary>Checks if <typeparamref name="T"/> can be used in <see cref="T:System.Threading.Interlocked"/> exchange operations.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.InterlockedUtils.Exchange``1(``0@,``0)">
            <summary>Exchange <typeparamref name="T"/> using appropriate <see cref="T:System.Threading.Interlocked"/> exchange method if possible.</summary>
            <exception cref="T:System.NotSupportedException"> if type not supported.</exception>
        </member>
        <member name="T:Eco.Shared.Utils.IPredicate`1">
             <summary>Interface for allocation-free predicates. You can add a struct which implements the predicate and then use with generic function which uses struct at compile time.</summary>
             <example><![CDATA[
             public struct ContainsStringPredicate : IPredicate<string>
             {
                 public string SubString { get; set; }
                 public bool Match(string s) => s.Contains(this.SubString);
             }
            
             public static class Test
             {
                 public int CountByFilter<T, TPredicate>(List<T> items, TPredicate filter) where TPredicate : IPredicate<T>
                 {
                     var count = 0;
                     for (var item in items)
                       if (filter(item)) count++;
                     return count;
                 }
            
                 public static void CountBySubString(List<string> items, string subStr) => CountByFilter(items, new ContainsStringPredicate { SubString = subStr } );
             }
             ]]></example>
        </member>
        <member name="M:Eco.Shared.Utils.IPredicate`1.Match(`0)">
            <summary>Checks if item matches the predicate.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IPredicate`1.ToDelegate">
            <summary>Converts to <see cref="T:System.Func`2"/> delegate.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.IPredicate`1.ToPredicate">
            <summary>Converts to <see cref="T:System.Predicate`1"/> delegate.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.LimitMapper.Config">
            <summary>Functions for 'soft capping' values. That is, making them approach a 'soft cap' linearly as an input changes, then approach a 'hard cap' as a limit, 
            never actually reaching it.  This is used in various places in order to allow for unlimited improvement as a value goes up, but at diminishing returns.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.LimitMapper.Config.InputMin">
            <summary>Start the mapping at this value.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.LimitMapper.Config.InputHalflife">
            <summary>After the amount increases this much, it will increase the output half the remaining distance to the limit.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.LimitMapper.Config.OutputAtMin">
            <summary>The output yielded when input is at or below 'InputMin'.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.LimitMapper.Config.OutputLimit">
            <summary>When the input value goes 'InputHalfLife' past 'InputSoftCap', the output will reach 50% towards this value.  This is the value it will approach but never reach.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.LimitMapper.Config.Describe(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>Describes the values of this config</summary>
        </member>
        <member name="M:Eco.Shared.Utils.LimitMapper.Map(System.Single,Eco.Shared.Utils.LimitMapper.Config)">
            <summary>Maps an input to an output, such that as the input reaches infinity, the output will approach (but never reach) a hard cap.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.LimitMapper.MapAndDescribe(System.Single,Eco.Shared.Utils.LimitMapper.Config,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Func{System.Single,Eco.Shared.Localization.LocString},System.Func{System.Single,Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)">
            <summary>Maps the given input value to an output value, using the limits defined in 'values'.</summary>
            <param name="val">The value to map to an output</param>
            <param name="config">The config values for how the mapping occurs</param>
            <param name="inputName">What is the name of the value being mapped</param>
            <param name="outputName">What is the name of the resulting value type.</param>
            <param name="inputValDescription">A function that renders an input value (incase you want special colors/icons)</param>
            <param name="outputValDescription">A function that renders an output value (incase you want special colors/icons)</param>
            <param name="header">Text to show at the top of our display.</param>
            <returns></returns>
        </member>
        <member name="T:Eco.Shared.Utils.ListUtils.DuplicateKeyComparer`1">
            <summary> Comparer for comparing two keys, handling equality as beeing greater
            Use this Comparer e.g. with SortedLists or SortedDictionaries, that don't allow duplicate keys</summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.rwLock"/> will exit read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.rwLock"/> will exit write lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitWriteLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="T:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose">
            <summary>
            Disposable structure which guarantees that <see cref="F:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.rwLock"/> will exit upgradeable read lock when <see cref="M:Eco.Shared.Utils.LockUtils.ExitUpgradeableReadLockOnDispose.Dispose"/> called. Handy when you wanna to use it with `using` pattern.
            We are not using something like <see cref="M:Eco.Shared.Utils.DisposableUtils.FromAction(System.Action)"/> because it creates new delegate every time what is bad both for performance and memory allocations.
            </summary>
        </member>
        <member name="F:Eco.Shared.Utils.Log.displayedErrors">
            <summary>Write the warnings, errors and exceptions unless they've already been displayed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Log.WriteErrorsSummary">
            <summary>When shutting down report amount of times called per issue.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.BinaryNode">
            <summary> Represents math expressions as binary trees. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.BinaryNode.TryResolveInternal(System.Collections.Generic.Stack{System.Single},System.Collections.Generic.Dictionary{System.String,System.Single})">
            <summary> Resolve current node only. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.ConstantValueNode">
            <summary> Binary node that repesents an operand with defined value. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.OperatorNode">
            <summary> Binary node that represents an operation between two operands. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.MathParser.MathParser">
            <summary> Parses and evaluates math expressions. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.ReplaceVariable(System.String,System.String,System.Single)">
            <summary> Replaces text representations of the variable with the provided value. 
            Note that it looks for exact matches and if 'Example' is passed, it won't touch 'Also Example', though the second one contains provided representation. </summary>
            <param name="expression"> A string that contains text representations of the variable. </param>
            <param name="variableName"> Text representation that will be replaced. </param>
            <param name="value"> This will replace text representation of the variable in the provided expression. </param>
            <returns> Modified expression, where text representations of the varible are replaced with the provided value. </returns>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.GetVariables(System.String)">
            <summary>  Extracts variables from the provided string (ignores constant values like 3.14 or 72). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.CompareNames(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>  Compares two provided collections and returns missmatches and declared duplicates. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.DescribeValues(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.Single,Eco.Shared.Localization.LocString}})">
            <summary> Replaces text representations of variables with their values. Each value will show its name and description in a foldout when hovered. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.BuildTree(System.String)">
            <summary> Converts provided expression into a binary tree and returns its root node (null if failed to parse). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.OnelineAndTrim(System.String)">
            <summary> Replaces newline characters with spaces and trims the result. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathParser.MathParser.CreateNode(System.String,Eco.Shared.Utils.MathParser.BinaryNode,Eco.Shared.Utils.MathParser.BinaryNode)">
            <summary> Parses data and creates either operator node or operand node (either constant or variable). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.DivideAndFloor(System.Int32,System.Int32)">
            <summary>Unlike a regular division, this will round *down*, instead of towards zero (IE, negative numbers round up when there is a remainder)</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.LerpToTarget(System.Single,System.Single,System.Single)">
            <summary>Sum source with delta to approach target, without passing it, and respecting absolute value.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.NormalizeAngleDeg(System.Numerics.Vector3,System.Numerics.Vector3,System.Single)">
            <summary> Find a normalized (-1 : 1) angle between two directions. Cuts angle higher than max angle </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.IsInCenter(System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Numerics.Vector3,System.Single)">
            <summary>
            Determine whether the point is in the center of a block
            </summary>
            <param name="size">Size of a block</param>
            <param name="normal">Normal vector of a hit point</param>
            <param name="scaledHit">Position of a hit point scaled to a size</param>
            <param name="centerSize">Size of center on a block (default is 65% of a half)</param>
            <param name="thinSize">Size of thin block</param>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionAngleDeg(Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Single)">
            <summary> Returns a max possible angle between two vectors </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.ClampDirectionToOffsetDeg(Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2@,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,Eco.Shared.Math.Vector2,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary> Function is finding new target and opposite directions in a curved way (lerping each step) </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(System.Int32,System.Int32)">
            <summary>Ceiling that (3,15) return 15. (-3, 15) will return 0.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(System.Int32,System.Int32)">
            <summary>Floor that (3, 15) return 0. (-3, 15) return -15</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary>Applies <see cref="M:Eco.Shared.Utils.MathUtil.CeilToNearestMultiple(System.Int32,System.Int32)"/> to each <see cref="T:Eco.Shared.Math.Vector2i"/> component.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(Eco.Shared.Math.Vector2i,System.Int32)">
            <summary>Applies <see cref="M:Eco.Shared.Utils.MathUtil.FloorToNearestMultiple(System.Int32,System.Int32)"/> to each <see cref="T:Eco.Shared.Math.Vector2i"/> component.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.WeightedAverage(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates average value between <paramref name="x"/> nad <paramref name="y"/> using value weights.
            Formula is following: <c>(x * xWeight + y * yWeight) / (xWeight + yWeight)</c>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MathUtil.TotalAverageVector3i(Eco.Shared.Math.Vector3i,System.Int32,Eco.Shared.Math.Vector3i,System.Int32)">
            <summary>Combine calculate average total from 2 source value of Vector3i</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemberUtils.IsSettable(System.Reflection.MemberInfo)">
            <summary> Returns true if this member is a field, or a property with a setter. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Byte)">
            <summary>
            byte<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadByte(System.IO.MemoryStream)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Boolean)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadBool(System.IO.MemoryStream)">
            <summary>
            bool<br/>
            [1 byte]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int16)">
            <summary>
            short<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadShort(System.IO.MemoryStream)">
            <summary>
            short<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.UInt16)">
            <summary>
            ushort<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadUShort(System.IO.MemoryStream)">
            <summary>
            ushort<br/>
            [2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteArray``1(System.IO.MemoryStream,System.ReadOnlySpan{``0})">
            <summary>
            short span encoded as array<br/>
            [length as zigzag int][ushort array]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteArray(System.IO.MemoryStream,System.UInt16[])">
            <summary>
            short array<br/>
            [length as zigzag int][ushort array]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadArray``1(System.IO.MemoryStream,``0[],System.Int32)">
            <summary>
            Reads <paramref name="count"/> <typeparamref name="T"/> values to <paramref name="array"/>.
            It makes binary copy of stream data to array and won't correctly work if any kind of compression (like zig zag) was used.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadUShortArray(System.IO.MemoryStream)">
            <summary>
            Decodes ushort array.
            [count:int sig zag][ushort[count]]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int32)">
            <summary>
            zig zag int<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadInt(System.IO.MemoryStream)">
            <summary>
            zig zag int<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.Int32)">
            <summary>
            non zig zag int<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.UInt32)">
            <summary>
            zig zag uint<br/>
            [1-5 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.UInt32)">
            <summary>
            non zig zag uint<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Int64)">
            <summary>
            zig zag long<br/>
            [1-10 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteNoZigZag(System.IO.MemoryStream,System.Int64)">
            <summary>
            non zig zag long<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadLong(System.IO.MemoryStream)">
            <summary>
            zig zag long<br/>
            [1-10 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Single)">
            <summary>
            float<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadFloat(System.IO.MemoryStream)">
            <summary>
            float<br/>
            [4 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Double)">
            <summary>
            double<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadDouble(System.IO.MemoryStream)">
            <summary>
            double<br/>
            [8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Guid)">
            <summary>
            <see cref="T:System.Guid"/><br/>
            [16 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadGuid(System.IO.MemoryStream)">
            <summary>
            <see cref="T:System.Guid"/><br/>
            [16 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.Net.IPEndPoint)">
            <summary>
            Encodes <see cref="T:System.Net.IPEndPoint"/> to <paramref name="stream"/>.<br/>
            [address bytes length:1 byte][address bytes:4-16 bytes][port:2 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.String,System.Boolean)">
            <summary>
            Encodes <see cref="T:System.String"/> <paramref name="value"/> to <paramref name="stream"/>. Depending on <paramref name="signedZigZag"/> will either use <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.Int32)"/> for <c>true</c> or <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.EncodeZigZag(System.IO.MemoryStream,System.UInt32)"/> for <c>false</c> when encoding string length.<br/>
            [length: signed/unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Write(System.IO.MemoryStream,System.String)">
            <summary>
            Encodes <see cref="T:System.String"/> <paramref name="value"/> to <paramref name="stream"/>.<br/>
            [length: unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadString(System.IO.MemoryStream)">
            <summary>
            Decodes <see cref="T:System.String"/> from <paramref name="stream"/>.<br/>
            [length: unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadString(System.IO.MemoryStream,System.Boolean)">
            <summary>
            Decodes <see cref="T:System.String"/> from <paramref name="stream"/>. Depending on <paramref name="signedZigZag"/> will either use <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.DecodeIntZigZag(System.IO.MemoryStream)"/> for <c>true</c> or <see cref="M:Eco.Shared.Utils.MemoryStreamExtensions.DecodeUIntZigZag(System.IO.MemoryStream)"/> for <c>false</c> when decoding string length.<br/>
            [length: signed/unsigned int zigzag][utf8 bytes]
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.WriteSpan(System.IO.MemoryStream,System.Int32)">
            <summary>
            Returns <see cref="T:System.Span`1"/> which may be used for direct write access to <see cref="T:System.IO.MemoryStream"/> buffer (obtained with <see cref="M:System.IO.MemoryStream.GetBuffer"/>) and advances stream position for <paramref name="bytesCount"/>.
            This span should be used immediately before any other Stream write operation, because otherwise buffer may be re-allocated and Span reference become invalid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadSpan(System.IO.MemoryStream,System.Int32)">
            <summary>
            Returns <see cref="T:System.ReadOnlySpan`1"/> for next <paramref name="bytesCount"/> bytes of <paramref name="memoryStream"/> and advances read position.
            This span should be used immediately before any other Stream write operation, because otherwise buffer may be re-allocated and Span reference become invalid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.ReadSpanToEnd(System.IO.MemoryStream)">
            <summary>Returns <see cref="T:System.ReadOnlySpan`1"/> for <paramref name="memoryStream"/> buffer starting from current position and advances stream position to the end.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.GetBufferSpan(System.IO.MemoryStream)">
            <summary>Returns <see cref="T:System.IO.Stream"/> byte content as <see cref="T:System.Span`1"/>. It is alternative to <see cref="M:System.IO.MemoryStream.ToArray"/>, but without byte array allocation.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.GetBufferArraySegment(System.IO.MemoryStream)">
            <summary>Returns <see cref="T:System.IO.Stream"/> byte content as <see cref="T:System.ArraySegment`1"/>. It is alternative to <see cref="M:System.IO.MemoryStream.GetBuffer"/>, but with used range only and with user provided byte array offset support.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.MemoryStreamExtensions.Shift(System.IO.MemoryStream,System.Int32,System.Int32)">
            <summary>
            Shifts <paramref name="stream"/> content at given <paramref name="shiftPosition"/> by <paramref name="shift"/>. Stream position and length adjusted if required.
            Useful when you need to insert or remove byte content from stream.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.WorldPos(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Get <see cref="T:Eco.Shared.Math.WrappedWorldPosition3"/> which is a wrapped position that makes sure it is within the world bounds, this is the preferred method to get a Position. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.WorldPosInt(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Get <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> which is an int wrapped position that makes sure it is within the world bounds, this is the preferred method to get an int Position. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.WorldPosXZ(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Get Wrapped position but only XZ as Vector2. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.WorldPosXZi(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Get Wrapped position as int and valid but only XZ as Vector2i</summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.RawPos(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Gets Raw Position without checking for wrapping, not recommended to use but is available, use <see cref="M:Eco.Shared.Utils.NetPositionExtensions.WorldPos(Eco.Shared.Networking.INetObjectPosition)"/> instead when possible. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NetPositionExtensions.PlotPos(Eco.Shared.Networking.INetObjectPosition)">
            <summary> Get PlotPos directly based of the XZ position, this handles the wrapping for the position and gets proper PlotPos implicitly. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.NullableExtensions">
            <summary> Extension methods for <see cref="T:System.Nullable`1"/> </summary>
        </member>
        <member name="M:Eco.Shared.Utils.NullableExtensions.TryGetValue``1(System.Nullable{``0},``0@)">
            <summary> Checks if <paramref name="nullable"/> has value and returns it as <paramref name="value"/> if has. Returns result of this check. It is thread-safe as it makes copy of <see cref="T:System.Nullable`1"/> struct. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.PathUtils">
            <summary>Home for <see cref="T:System.IO.Path"/> utility functions.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PathUtils.SanitizeFileName(System.String)">
            <summary>Replaces all invalid file name characters with '_' and removes trailing '.' if exists.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PathUtils.IsSubPath(System.String,System.String)">
            <summary>Checks if a string path is within a root directory.</summary>
            <param name="root">Root directory to check for</param>
            <param name="path">Path to check.</param>
            <returns><c>true</c> if the path value of <paramref name="path"/> is contained within <paramref name="root"/>>. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.PeriodicUpdate.Reset">
            <summary>Update the next tick time to be 'period' away.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.PeriodicUpdateSpatial">
            <summary>Updates only when a position changes sufficiently or time has changed.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Predicates.EqualityPredicate`1">
            <summary>Equality predicate with custom <see cref="F:Eco.Shared.Utils.Predicates.EqualityPredicate`1.equalityComparer"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.PredicateUtils">
            <summary>Utility methods for combining predicate functions together.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PredicateUtils.AndAlso``1(System.Func{``0,System.Boolean},System.Func{``0,System.Boolean})">
            <summary>Combines <paramref name="left"/> and <paramref name="right"/> by <c>&amp;&amp;</c> operator. Uses same naming as <see cref="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PredicateUtils.MatchesAll``2(``1,``0)">
            <summary>Checks if <paramref name="item"/> matches all <paramref name="predicates"/>. Returns <c>true</c> if no predicates.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PredicateUtils.MatchesAll``1(``0,System.Func{``0,System.Boolean}[])">
            <summary>Checks if <paramref name="item"/> matches all <paramref name="predicates"/>. Returns <c>true</c> if no predicates.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.PredicateUtils.MatchesAny``2(``1,``0)">
            <summary>Checks if <paramref name="item"/> matches any of <paramref name="predicates"/>. Returns <c>false</c> if no predicates.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ProfanityFilterType">
            <summary>Enumerable used to define profanity filtering behaviour.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ProfaneWords">
            <summary>
            Singleton instance for loading the profane words used by the <see cref="T:Eco.Shared.Utils.ProfanityFilter"/> singleton.
            Loads a profanity list obtained from https://github.com/shutterstock/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words on Eco Server with other languages available at the link.
            Non Eco Server use cases can be loaded via the <see cref="F:Eco.Shared.Utils.ProfaneWords.OverrideLoad"/> static <see cref="T:System.Func`2"/> variable.
            </summary>
        </member>
        <member name="F:Eco.Shared.Utils.ProfaneWords.OverrideLoad">
            <summary>Hook for providing custom profane word loading instead of the default "Profanity.eco" file in Eco Server. Generally used by Eco Client.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ProfaneWords.Load">
            <summary>Loads the local profanity file into memory or loads the words provided by the <see cref="F:Eco.Shared.Utils.ProfaneWords.OverrideLoad"/> attribute if present.</summary>
            <returns>Loaded profane words to censor.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ProfaneWords.LoadConfigs">
            <summary>Loads the profane words line by line as found inside the file defined at <see cref="F:Eco.Shared.Utils.ProfaneWords.ProfanityFile"/> or its matching template file <see cref="F:Eco.Shared.Utils.ProfaneWords.ProfanityFileTemplate"/>.</summary>
            <returns>Loaded profanity words if either profanity server config file was found. Otherwise returns an empty <see cref="T:System.String"/> <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Initializes the <see cref="T:Eco.Shared.Utils.ProfanityFilter"/> singleton with a predefined list of blacklisted "profane" words.</summary>
            <param name="blackListWords"><see cref="T:System.Collections.Generic.IEnumerable`1"/> containing all blacklisted/censored "profane" words.</param>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.#ctor">
            <summary>Initializes the <see cref="T:Eco.Shared.Utils.ProfanityFilter"/> singleton with the blacklisted words defined by the <see cref="T:Eco.Shared.Utils.ProfaneWords"/> singleton.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.ValidateTextContainsProfanity(System.String)">
            <summary>Validates and returns if the text contains profane content.</summary>
            <param name="text"><see cref="T:System.String"/> to check for profanity.</param>
            <returns>True if profanity was detected. Otherwise returns false.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.Invoke(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.RPCInvocation@)">
            <summary>Invokes <paramref name="invocation"/> with profanity filter.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ProfanityFilter.Clean(System.String)">
            <summary>Cleans a text <see cref="T:System.String"/> instance of any profanity found in it.</summary>
            <param name="text"><see cref="T:System.String"/> to censor profanity from if detected.</param>
            <returns>Censored <see cref="T:System.String"/> if profanity was detected in the original text <see cref="T:System.String"/></returns>
        </member>
        <member name="T:Eco.Shared.Utils.RandomCandidateChooser`1">
             <summary>
             Random Candidate Chooser from unknown size number of candidates.
             As soon as first candidate tested it will be auto-winner, but also it will randomly select next winner index and reset candidate counter.
             As soon as we have candidate with selected winner index it will replace previous winner and we select next winner index.
             It uses some adjustments to make replacement more often for low number of elements and less often as number of elements growth.
            
             This algorithm is adaptation of https://en.wikipedia.org/wiki/Reservoir_sampling for k = 1.
             </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.weight">
            <summary> Next candidate weight. With lower value new candidate has lower chances to replace last Winner. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextWinnerIndex">
            <summary> Next winner index (zero-based). </summary>
        </member>
        <member name="F:Eco.Shared.Utils.RandomCandidateChooser`1.nextCandidateIndex">
            <summary> Next candidate (who will be tested) index. If it matches winner index then the candidate wins. Increased after each <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>.  </summary>
        </member>
        <member name="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner">
            <summary> Current winner. Should be selected by <see cref="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomCandidateChooser`1.TestCandidate(`0)">
            <summary> Test the <paramref name="candidate"/> if it is the next winner. Updates <see cref="P:Eco.Shared.Utils.RandomCandidateChooser`1.Winner"/> if test succeed. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Random(System.Random,Eco.Shared.Math.Vector2i)">
            <summary> Returns new <see cref="T:Eco.Shared.Math.Vector2i"/> with <c>x</c> greater or equal to <c>0</c> and less than <c>max.x</c>. Same for <c>y</c>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])">
            <summary> Shuffles <paramref name="array"/> elements in-place in random order using <paramref name="random"/> generator. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomUtil.Shuffle``1(``0[])">
            <summary> Shortcut for <see cref="M:Eco.Shared.Utils.RandomExtensions.Shuffle``1(System.Random,``0[])"/> with <see cref="P:Eco.Shared.Utils.RandomUtil.Global"/> randomizer. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.RandomUtil.RandomBytes(System.Int32)">
            <summary>Return an array of random bytes of the given length</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ReadOnlySpanTuple`2">
            <summary><see cref="T:System.ValueTuple"/> like tuple of span values. <see cref="T:System.ReadOnlySpan`1"/> can't be used with non ref structs and classes and so we do need to have own tuple type for it.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ReadOnlySpanTuple`3">
            <summary><see cref="T:System.ValueTuple"/> like tuple of span values. <see cref="T:System.ReadOnlySpan`1"/> can't be used with non ref structs and classes and so we do need to have own tuple type for it.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.ReflectionCache.GameAssemblies">
            <summary> Assemblies required by Eco and mods to perform reflection on. See <see cref="M:Eco.Shared.Utils.ReflectionCache.RegisterBaseAssemblies"/> and <see cref="M:Eco.Shared.Utils.ReflectionCache.RegisterAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/> </summary>
        </member>
        <member name="F:Eco.Shared.Utils.ReflectionCache.BaseAssembliesName">
            <summary> Assembly names required by Eco for reflection, add as needed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetSerializableProperties(System.Type)">
            <summary> Get Serializable Properties of Type using cache </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetPropertiesCached(System.Type)">
            <summary> Get cached Type Properties, prefer over Type.GetProperties </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetTypesCached(System.Reflection.Assembly)">
            <summary> Get cached Assembly types, prefer over Assembly.GetTypes </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetExtensionMethods(System.Type)">
            <summary>Returns all extensions methods for <paramref name="type"/> including those which assignable from <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.HasAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            Cache defined Attributes per MemberInfo, for inherited and non-inherited check
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetEnumerableType(System.Type)">
            <summary>Returns element type for array, or first implemented <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface, or of type itself if it is <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.RegisterBaseAssemblies">
            <summary>
            Register assemblies required by Eco for reflection.
            Called during Server startup as the various Plugins are added which may add new assemblies to <see cref="M:Eco.Shared.Utils.ReflectionCache.GetAssemblies"/>.
            Also called during Client startup.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.RegisterAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary> Register assemblies for reflection. Used to add mod assemblies at ModKit DLL load. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionCache.GetAssemblies">
            <summary> Get all assemblies </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsSerialized(System.Reflection.MemberInfo)">
            <summary> Check member is serialized, through SerializedAttribute, EcoAttribute or SerializedDerivedAttribute </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsSerializedTypeName(System.Reflection.MemberInfo)">
            <summary>Checks if <see cref ="T:System.Type"/> may be referenced in serialized data, but may not be serialized itself. Any <see cref="M:Eco.Shared.Utils.ReflectionUtils.IsSerialized(System.Reflection.MemberInfo)"/> type is also <see cref="M:Eco.Shared.Utils.ReflectionUtils.IsSerializedTypeName(System.Reflection.MemberInfo)"/>, but not all <see cref="M:Eco.Shared.Utils.ReflectionUtils.IsSerializedTypeName(System.Reflection.MemberInfo)"/> types are <see cref="M:Eco.Shared.Utils.ReflectionUtils.IsSerialized(System.Reflection.MemberInfo)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Type,System.Reflection.Assembly,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> optionally in specific <paramref name="assembly"/> and optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type,System.Boolean)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assemblies"/> optionally (if <paramref name="includeSelf"/> set) returning the type itself. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.VerifySignature(System.Reflection.MethodInfo,System.Type[])">
            <summary>Return true if the given method has the exact list of types in this order as its signature.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ConcreteTypesWithInteface(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary> Returns all types that implements interface <paramref name="interfaceType"/>  </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DerivedTypes(System.Reflection.Assembly,System.Type)">
            <summary> Returns all derived types for <paramref name="baseType"/> in <paramref name="assembly"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GenericTypeImplementations(System.Type,System.Reflection.Assembly)">
            <summary>Returns all compile time implementations of <paramref name="genericTypeDefinition"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.HasGenericParameters(System.Type)">
            <summary>Checks if <paramref name="type"/> has any generic parameters. I.e. when generic type used as based it isn't more generic type definition, but still has generic parameters in it's definition (i.e. base class for StringKeyDictionary{TValue} : Dictionary{string, TValue}).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsInheritFromGenericTypeDefinition(System.Type,System.Type)">
            <summary> Checks if any base class is generic type from generic type definition. </summary>
            <sample><code>EconomyManager.IsInheritFromGenericTypeDefinition(typeof(Singleton&lt;&gt;)) // true</code></sample>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CreatableTypes(System.Type,System.Reflection.Assembly,System.Boolean)">
            <summary>Returns types that derive from this type in the given assembly (or all assemblies if null), and optionally the passed type itself, if it's creatable.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CallStatic(System.Type,System.String,System.Object[])">
            <summary>Call a static function on the given type.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryCallStatic(System.Type,System.String,System.Object[])">
            <summary>Try to call a static method, doing nothing if it doesn't exist or is wrong signature.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CallStatic``1(System.Type,System.String,System.Object[])">
            <summary>Call a static with an expected return type T</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryCallStatic``1(System.Type,System.String,System.Object[])">
            <summary>Call a static function of the given name, triggering an error if it doesnt exist.  T = return type</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.AllMembers(System.Type,System.Boolean)">
            <summary> Gets all properties, methods, and extension methods.  Operates either on instance members or static members based on passed bool. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.WithAttribute``1(System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.Boolean)">
            <summary>Syntax sugar for <see cref="M:Eco.Shared.Utils.ReflectionUtils.WithAttribute``2(System.Collections.Generic.IEnumerable{``0},System.Boolean)"/> for property infos.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.WithAttribute``2(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>Filters <paramref name="members"/> to keep only members with <typeparamref name="TAttr"/> attribute(s).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.MembersWithAttribute``1(System.Type,System.Boolean)">
            <summary> Returns all public instance and static members that have the passed attribute, including from parent classes. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ForEachMemberWithAttribute``1(System.Type,System.Boolean,System.Action{System.Reflection.MemberInfo,``0})">
            <summary>Execute action for every member of type that has argument of type T.</summary>
            <param name="includeExtensions">Should extension methods be included?</param>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetStaticFieldValue``2(System.String)">
            <summary>Returns value of static field on <typeparamref name="TType"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetStaticFieldValue``1(System.Type,System.String)">
            <summary>Returns value of static field on <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.PropertyValue``1(System.Object,System.Reflection.PropertyInfo)">
            <summary>Returns a value of <paramref name="property"/> converted to <typeparamref name="T"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.Value``1(System.Reflection.PropertyInfo,System.Object)">
            <summary>Returns a value of <paramref name="property"/> converted to <typeparamref name="T"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.Attribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>Returns first attribute of type <typeparamref name="T"/> if exists, otherwise <c>null</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.HasAttributeIncludingInterfaces``1(System.Reflection.PropertyInfo)">
            <summary>Checks if <paramref name="property"/> has attribute <typeparamref name="T"/> or any of interfaces declaring same property has the attribute.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.DeepAttributes(System.Type,System.Type)">
            <summary>Collects all attributes of 'attributeToScan' in typeToScan itself and its Fields, Properties and Methods</summary>
            <param name="attributeToScan">Attribute to scan for.</param>
            <returns>Discovered MemberInfo and their attribute data.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetTypesWithAttribute``1(System.Reflection.Assembly)">
            <summary>Returns all types in the assembly with the attribute,</summary>
            <typeparam name="T">Attribute to find,</typeparam>
            <param name="assembly">Assembly to check,</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> containing all the found types.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetGenericInterface(System.Type,System.Type,System.Type@)">
            <summary>Tries to get <paramref name="genericInterface"/> constructed from <paramref name="genericInterfaceDefinition"/> implemented by <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsGenericTypeConstructedFrom(System.Type,System.Type)">
            <summary>Checks if <paramref name="genericType"/> is a generic type constructed from <paramref name="genericTypeDefinition"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetPropertyByName``1(System.Object,System.String,``0@)">
            <summary>Try to get a property using reflection for the given name, and assign it to val, returning true if found.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.InNamespace(System.Type,System.String)">
            <summary> Checks if <paramref name="type"/> in <paramref name="namespace"/> (same or nested). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsBackingField(System.Reflection.FieldInfo)">
            <summary> Checks if <paramref name="fieldInfo"/> is backing field (for auto-property). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.FieldInfo)">
            <summary>
            Checks if <paramref name="field"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - field is "public";
            - field declared in the assembly;
            - field declared as "protected" or "protected internal" and field's owning type is in the assembly;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.field
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.CanAccess(System.Reflection.Assembly,System.Reflection.MethodInfo)">
            <summary>
            Checks if <paramref name="method"/> may be accessed (without reflection) from <paramref name="assembly"/>.
            It is possible in 3 cases:
            - <paramref name="method"/> is "public";
            - <paramref name="method"/> declared in the <paramref name="assembly"/>;
            - <paramref name="method"/> declared as "protected" or "protected internal" and <paramref name="method"/>'s owning type is in the <paramref name="assembly"/>;
            <remarks>It currently doesn't support intermediate types through inheritance, i.e. in A (Assembly 1) : B (Assembly 2) : C (Assembly 3) if you check for Assembly 2 for A.Method
            which is declared as protected in C then it will return false. Adding this check will make logic more complex and doesn't have practical usage for now.</remarks>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.ZipByProperty``1(System.Object,System.Object,System.Object,System.Func{``0,``0,``0})">
            <summary> Goes over each assignable member of type T in the given object, gets the value in both 'object' and 'other', and calls the func to transform
            them into the final value.
            </summary>
            <typeparam name="T">The parameter type of properties we're looking at.</typeparam>
            <param name="target">The given object.</param>
            <param name="leftObj">The object providing the left value in the transformFunc</param>
            <param name="rightObj">The object providing the right value in the transformFunc</param>
            <param name="transformFunc">The function that accepts the property from both left and right, and returns the value of the new one. </param>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.BlendProperties(System.ICloneable,System.ICloneable,System.Single)">
            <summary> Clones source, then assigns all int and float values a lerped-value relative to 'target' </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetMatchingMethodWithInheritance(System.Reflection.MethodInfo,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Reflection.MethodInfo@)">
            <summary>Searches matching method starting from <paramref name="methodInfo"/> and then fallback to base class and interfaces. I.e. may be used to find base method in non-generic type.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetMatchingInterfaceMethod(System.Reflection.MethodInfo,System.Func{System.Reflection.MethodInfo,System.Boolean},System.Reflection.MethodInfo@)">
            <summary>Tries to get first interface declaring <paramref name="methodInfo"/> matching <paramref name="predicate"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsExtension(System.Reflection.MethodInfo)">
            <summary>Checks if <paramref name="methodInfo"/> is an extension method.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.IsOverride(System.Reflection.MethodInfo)">
            <summary>Checks if <paramref name="methodInfo"/> is an method override.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.TryGetExtensionType(System.Reflection.MethodInfo,System.Type@)">
            <summary>Try to get the extension type of the method if it's an extended method else return false.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetMethodRealType(System.Reflection.MethodInfo)">
            <summary>If the method is an extended one we get the extension type else we just get the method declaring type.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.BasestOrDefault(System.Type,System.Func{System.Type,System.Boolean})">
            <summary>
            Returns basest type in hierarchy matching <paramref name="predicate"/>. All types higher in hierarchy also should match the <paramref name="predicate"/>.
            Usually may be used to find a base type which first implements an interface: <code>type.BasestOrDefault(t => typeof(IController).IsAssignableFrom(t)).</code>
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetSimpleName(System.Reflection.MemberInfo)">
            <summary>Returns simple name (without explicit interface specification). I.e. Eco.Core.Systems.IRegistrar.IdToObj => IdToObj.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetSimpleName(System.String)">
            <summary>Returns simple name (without explicit interface specification). I.e. Eco.Core.Systems.IRegistrar.IdToObj => IdToObj.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetMatchingMethod(System.Reflection.MethodInfo,System.Type)">
            <summary>Returns method with same name and arguments in <paramref name="type"/> (looking into declared members only). Returns <c>null</c> if such method not found.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetTypeByGenericTypeDefinitionInHierarchy(System.Type,System.Type)">
            <summary>Returns (if exists) type corresponding to <paramref name="genericTypeDefinition"/> in <paramref name="type"/> hierarchy. I.e. if when check for List{}: List{string} -> List{string}, IntList : List{int} -> List{int}.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ReflectionUtils.GetDefaultValue(System.Type)">
            <summary>Returns default value for <paramref name="type"/>.</summary>
            <returns>Same as default(T) via reflection.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Text.SignedNum(System.Single,System.Boolean,System.Boolean)">
            <summary> Returns styled number with forded sign ('+' - for positive, '-' - for negative, no sign for zero). If <paramref name="invertHighlight"/> set then it will use negative highlight for positive value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.CurrencySignedNum(System.Single,System.Boolean)">
            <summary> Returns styled number with forded sing and $ symbol ('+$' for positive, '-$' for negative, no sing for zero). If <paramref name="invertHighlight"/> set then it will use negative highlight for positive value. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.IsZeroAfterRounding(System.Single,System.Int32)">
            <summary> Check if number is different than 0 after formatting </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.StyledNegativeNum(System.Single)">
            <summary>Displays a styled number, but using negative coloring.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.StyledIntUnsigned(System.Single)">
            <summary> Styles originally negative numbers in red (negative style) while removing the negative sign from the output.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Pos(System.Int32,System.Object)">
            <summary>Sets text position inside text box (value in EM not pixels) The size of an EM depends on its parent. E.g if the text size of body is 16 pixels, then 150% or 1.5 EM will be 24 pixels (1.5 * 16).</summary>
            <remarks>Not supported in UIToolkit</remarks>
        </member>
        <member name="M:Eco.Shared.Utils.Text.PosIgnoreFont(System.Int32,System.Object)">
            <summary>Sets text position inside text box ignoring font size</summary>
            <remarks>In most cases it's better to use <see cref="M:Eco.Shared.Utils.Text.Pos(System.Int32,System.Object)"/></remarks>
        </member>
        <member name="M:Eco.Shared.Utils.Text.CopyToClipBoard(System.String,System.Object,System.String)">
            <summary>
            Build a link to copy to clipboard on click
            <br> "<paramref name="name"/> (click to copy): &lt;link=copy:<paramref name="toCopy"/>&gt;{<paramref name="inner"/>}&lt;/link&gt;" </br>
            </summary>
            <param name="toCopy"> Content copied to clipboard on click </param>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Font(System.String,System.String)">
            <summary>Creates a font tag for use with TextMeshPro on the Client. http://digitalnativestudios.com/textmeshpro/docs/rich-text/#font </summary>
            <returns>TextMeshPro compatible font tag.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Font(System.String,System.String,System.String)">
            <inheritdoc cref="M:Eco.Shared.Utils.Text.Font(System.String,System.String)"/>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Truncate(System.String,System.Int32)">
            <summary> Cuts visible part of the content after provided width and replaces it with a hoverable link to see the origin. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.Columns(System.Int32,System.Int32,System.ValueTuple{System.String,System.Int32}[])">
            <summary> Aligns strings within blocks with specified widths. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.NegativeOrDefault(System.String,System.Boolean)">
            <summary>Coloring text with default or negative color by condition</summary>
        </member>
        <member name="M:Eco.Shared.Utils.Text.NegativeOrPositive(System.String,System.Boolean)">
            <summary>Coloring text with positive or negative color by condition</summary>
        </member>
        <member name="T:Eco.Shared.Utils.ISettlementConfig">
            <summary>Interface to hold reference to the SettlementTypes for accessing them outside Eco.Gameplay, SettlementConfig implements this</summary>
        </member>
        <member name="T:Eco.Shared.Utils.SharedSettlement">
            <summary>Holds the reference to SettlementConfig for easy access from anywhere. it's set from SettlementDefinitions</summary>
        </member>
        <member name="M:Eco.Shared.Utils.SharedSettlement.SetSettlementConfig``1(``0)">
            <summary>Used on both client and server, so settlement properties are shared through dll.</summary>
        </member>
        <member name="P:Eco.Shared.Utils.AutoSingleton`1.Obj">
            <summary>Current Singleton instance of this object.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.Singleton`1.Temp">
            <summary>
            Structure which used for temporary replaced singletons (for test purposes). It saves previous singleton object (usually null) and when disposed restores it.
            It may be preferred over <see cref="M:Eco.Shared.Utils.Singleton`1.WithTempSingleton``1(System.Action)"/>, because you may create this object in [SetUp] method and destroy in [TearDown] method
            allowing all tests to run with this temp singleton without explicitly wrapping them in WithTempSingleton call.
            </summary>
        </member>
        <member name="P:Eco.Shared.Utils.Singleton`1.Obj">
            <summary>Current Singleton instance of this object.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchExtensions.FractionalMilliseconds(System.Diagnostics.Stopwatch)">
            <summary>Returns milliseconds as fractional.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.StopwatchUtils">
            <summary> <see cref="T:System.Diagnostics.Stopwatch"/> utilities for high performance time measures. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Int64)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromMilliseconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="milliseconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromSeconds(System.Double)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="seconds"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TicksFromTimeSpan(System.TimeSpan)">
            <summary> Returns number of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> for <paramref name="timeSpan"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.MillisecondsFromTicks(System.Int64)">
            <summary> Returns number of milliseconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.NanosecondsFromTicks(System.Int64)">
            <summary> Returns number of nanoseconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.SecondsFromTicks(System.Int64)">
            <summary> Returns number of seconds for <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StopwatchUtils.TimeSpanFromTicks(System.Int64)">
            <summary> Returns <see cref="T:System.TimeSpan"/> for raw <see cref="T:System.Diagnostics.Stopwatch"/> ticks. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.ReadTo(System.IO.Stream,System.IO.Stream,System.Int64,System.Int64)">
            <summary>Reads portion of <paramref name="source"/> stream to <paramref name="destination"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StreamExtensions.ReadTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>Reads <paramref name="count"/> of <paramref name="source"/> stream bytes to <paramref name="destination"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.StringBuilderExtensions">
            <summary>Static extension methods for the .NET <see cref="T:System.Text.StringBuilder"/> object.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringBuilderExtensions.AppendLineIf(System.Text.StringBuilder,System.Boolean,System.String)">
            <summary>Appends <param name="str"> only if <paramref name="condition"/> is true.</param></summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringDisplayUtil.AppendHeaderLine(System.Text.StringBuilder,System.String,System.Int32,System.Char)">
            <summary>Appends a header line to the <see cref="T:System.Text.StringBuilder"/>. Header line represents a text centered between space characters that will always match the requested length.</summary>
            <param name="sb"><see cref="T:System.Text.StringBuilder"/> instance to operate on.</param>
            <param name="header">Header text to center on the line</param>
            <param name="totalLength">Total length of the header line. Defaults to 50</param>
            <param name="spaceCharacter">Space character used to pad the header line. Defaults to "-"</param>
            <returns>A reference to this instance after the append operation has completed.</returns>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.JoinSafe(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.String,System.String)">
            <summary>Join a string to another with a separator, if both are set.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.JoinWordSafe(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.String,System.String)">
            <summary>Put a word (like 'and') between two strings, if there are indeed two strings.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StartWithWords(System.String,System.String)">
            <summary>Check if a string is in the beginning of this string, whole words included. Partial overlap will return false. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripCData(System.String)">
            <summary>Strips CData XML tags from the input string and returns the cleaned version.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripTags(System.String)">
            <summary>Strips HTML/Eco tags from the string and returns the cleaned version.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripSpecialCharacters(System.String,System.Boolean)">
            <summary>Strip all special characters from a given string.</summary>
            <param name="removeSpaces">Do we also want to remove all spaces ?</param>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripTagsNoParse(System.String)">
            <summary>Same as <see cref="M:Eco.Shared.Utils.StringExtensions.StripTags(System.String)"/>, but does not strip tags that are inside 'noparse' tag.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.ContainsTags(System.String)">
            <summary> Returns true if given string contains ANY tags. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripNonColorTags(System.String)">
            <summary> Removes all tags from a given string EXCEPT 'color' tags (includes both opening and closing tags). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripSizeTags(System.String)">
            <summary> Removes all size tags from a given string (includes both opening and closing tags). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripIconTags(System.String)">
            <summary> Removes all icon tags from a given string (includes both opening and closing tags). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.StripLinkTags(System.String)">
            <summary> Removes all link tags from a given string (includes both opening and closing tags). </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.Strip(System.String,System.Char)">
            <summary>Strips character <paramref name="ch"/> from <paramref name="input"/> string.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.ContainsCaseInsensitiveIgnoreTags(System.String,System.String)">
            <summary>We strip both strings from all tags and then we check whether the string can be found in the other string or not.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmountLoc(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},System.String)">
            <summary>  Version of <see cref="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.DescribeAmount(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString)">
            <summary> Combines a set of lines into a foldout list. The link will be in format "description: linesCount". </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.CommaList(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>
            Creates comma separated list from <paramref name="phrases"/>.
            If input is empty then it will return <paramref name="noneText"/>.
            Otherwise it will return comma separated list prefixed with <paramref name="prefix"/> and suffixed with <paramref name="suffix"/>.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.CommaList(System.Collections.Generic.IEnumerable{Eco.Shared.Localization.LocString},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Boolean)">
            <summary>Creates comma separated list of given phrases.</summary>
            <param name="phrases">Phrases to include in the list.</param>
            <param name="noneText">Alternative text displayed when list of phrases is empty.</param>
            <param name="joinText">Text used to join last two phrases (for example for 'and' result is: 'phrase1, phrase2, phrase3 and phrase4').</param>
            <param name="phrasesOnSeparateLines">Set to true to separate phrases with new line in addition to comma.</param>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.TrimEndString(System.String,System.String)">
            <summary> Trim the end if it matches a string. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.Truncate(System.String,System.Int32,System.String,System.Boolean)">
            <summary>Shortens a string with appending of suffix. May work with tagged messages, and in this case will count only real text ignoring tags.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.IsSet(System.String)">
            <summary> Checks if string is not null and is not empty. Inverse of <see cref="M:System.String.IsNullOrEmpty(System.String)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.AppendToBuilder(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocStringBuilder@)">
            <summary> Avoid creating new builder if not needed </summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String,System.Int32)">
            <summary>Replaces the first string found.</summary>
            <param name="text">String instance to operate on.</param>
            <param name="search">String to search for.</param>
            <param name="replace">String to replace.</param>
            <param name="startIndex">Index to start search from.</param>
            <returns>String instance with the value of <paramref name="search"/> replaced with <paramref name="replace"/></returns>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.ReplaceFirstAfter(System.String,System.String,System.String,System.String)">
            <summary>Replaces first occurence of <paramref name="search"/> with <paramref name="replace"/> after first occurence of <paramref name="after"/>.</summary>
            <seealso cref="M:Eco.Shared.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.FastSplit2(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>Helper to split a span into two parts. Fast split call.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.FastSplit3(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>Helper to split a span into three parts. Fast split call.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.StringExtensions.SplitToChunks(System.String,System.Int32)">
            <summary>Splits a string into chunks of equal or less size as defined by the max size input.</summary>
            <param name="text">String instance to split</param>
            <param name="chunkSize">Max size of each chunk.</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the instance of <paramref name="text"/> split into chunks determined by the given size.</returns>
        </member>
        <member name="T:Eco.Shared.Utils.TableUtils">
            <summary> Contains utility functions that can help style table content. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetTitleRowLoc(System.String)">
            <summary> Returns an Header that is ready to added to a table as a row. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetDescriptionRowLoc(System.String)">
            <summary> Returns an Header that is ready to added to a table as a row. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.MakeEmptyLineTable(System.Int32)">
            <summary> Returns an empty table with howmany empty lines we want. Can be used for styling purposes. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TableUtils.GetStyledRow(System.Int32,System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Int32)">
            <summary> Pass a row and get it back styled with optional amount of empty lines before and after it. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParser">
            <summary>Parses XML-like text using custom tag processors from config. Tag processor is a <see cref="T:Eco.Shared.Utils.TagParser.CustomTagProcessor"/> delegate.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParser.CustomTagProcessor">
            <summary>Processing callback for custom tags.</summary>
            <param name="paramNamesToValues">Parameters of the tag and their values (see sample below). This dictionary will be used as parentAttrs for child tags. See how ProcessFoldoutMatch on client side looks for parameters that were added by its children.</param>
            <param name="content">&lt;someTag parameter="value"&gt;content&lt;/someTag&gt;</param>
            <param name="parentAttrs">paramNamesToValues of the parent tag. See how ProcessFoldoutTitle on the client side passes data to its parent foldout tag.</param>
            <param name="foldouts">Optional foldouts mapping provided in <see cref="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})"/> call. May be null.</param>
        </member>
        <member name="F:Eco.Shared.Utils.TagParser.AutoCloseTagsParser">
            <summary>Parser for autoclosing tags only (e.g. color tags in titles).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})">
            <summary>Parses <paramref name="text"/> using registered custom processors and fixing any unclosed tags (defined to be auto-closed).</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ReleaseContext(Eco.Shared.Utils.TagParserState)">
            <summary>Returns content of <paramref name="state"/>'s Output and adds it back to the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ReleaseBuilder(System.Text.StringBuilder)">
            <summary>Returns content of <paramref name="builder"/> and adds it back to the pool.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryParseClosingTag(System.ReadOnlySpan{System.Char},System.String@)">
            <summary>Tries parse <paramref name="tag"/> as closing and outputs it's <paramref name="name"/> if succeed.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseAttributes(System.ReadOnlySpan{System.Char})">
            <summary>Parses parameters for the <paramref name="tag"/> as dictionary.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Handles <paramref name="tag"/> either as unknown tag or registered custom tag. For custom tags it will output <see cref="T:Eco.Shared.Utils.TagParser.CustomTagProcessor"/> result, for unknown tags it will add them as is to <paramref name="state"/> Output.</summary>
            <param name="tag">Contains tag to process.</param>
            <param name="unparsed">Contains unparsed value right after the <paramref name="tag"/>.</param>
            <param name="state">Contains current parser state including Output, OpenTags, last unhandled tag etc.</param>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.CaptureContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Same as <see cref="M:Eco.Shared.Utils.TagParser.ParseContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)"/>, but captures parsed content to string and returns. It temporary overrides state's Output, original Output stays unmodified.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.ParseContent(System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)">
            <summary>Parses <paramref name="unparsed"/> content. Handles tags with <see cref="M:Eco.Shared.Utils.TagParser.HandleTag(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@,Eco.Shared.Utils.TagParserState)"/> for every open tag, returns if found close tag and output it to state's UnhandledCloseTag and adds everything else to state's Output.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParser.TryFindNextTag(System.ReadOnlySpan{System.Char},System.Int32@,System.Int32@)">
            <summary>Scans <paramref name="unparsed"/> content until first tag entry and outputs it's position in <paramref name="tagStart"/> and <paramref name="tagEnd"/> parameters if succeed. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParserConfig">
            <summary> Config for <see cref="T:Eco.Shared.Utils.TagParser"/> which allows to add custom parsers and configure autocloseable tags. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.TagNamesToCustomProcessors">
            <summary> Tag parser looks for a custom processor for every tag it finds. The tag and its content will be left as is if there is no custom processor for it.
            Otherwise, everything will be replaced with the result returned by the processor. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserConfig.AutoCloseTags">
            <summary> Set of tags which should be automatically closed if no matching close tag was found. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.TagParserState">
            <summary><see cref="T:Eco.Shared.Utils.TagParser"/> state object used during call to <see cref="M:Eco.Shared.Utils.TagParser.Parse(System.String,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.String,System.String}})"/>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.OpenTags">
            <summary>Tracks for all open tags when processing nested tags.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.ParentAttributes">
            <summary>Contains parent tag attributes dictionary (only if parent tag has custom tag processor). May be <c>null</c>.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.Output">
            <summary>Current Output for parsed content.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.UnhandledCloseTag">
            <summary>Last unhandled close tag. Set when close tag doesn't match opened tag. Tag will be auto-closed in this case and closed tag reused by parent tag.</summary>
        </member>
        <member name="F:Eco.Shared.Utils.TagParserState.Foldouts">
            <summary>Optional foldouts mapping between foldout id and it's Title and Content.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TagParserState.Clear">
            <summary>Clears state and prepares it for next parse.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.TextReaderExtensions">
            <summary>Extensions for <see cref="T:System.IO.TextReader"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextReaderExtensions.ReadLinesToEnd(System.IO.TextReader)">
            <summary>Read all lines to end of reader.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextReaderExtensions.ReadLinesToEndAsync(System.IO.TextReader)">
            <summary>Read all lines to end of reader asynchronously.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.JoinLocStr(System.String,System.Nullable{Eco.Shared.Localization.LocString}[])">
            <summary>Joins an arbitrary number of localized strings together with the joiner, if not null.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.CheckRPCLength(Eco.Shared.Networking.INetClient,Eco.Shared.Networking.RPCInvocation)">
            <summary> Method to check the size of the strings that pass through the RPC, if they have a Range attribute we limit the size to this, if not then we check that MaxTextSize is not reached </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.GetObjectRange(System.String,System.Reflection.MemberInfo,Eco.Shared.Localization.LocString@)">
            <summary>Get the variables needed to analyze the attribute of the object.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TextUtil.CheckLength(Eco.Shared.Math.EcoTextLimit,System.String,Eco.Shared.Localization.LocString@,System.Boolean)">
            <summary>Check that the incoming string is under the allowed limits of text sizes, in case it is not return False and and return a message with the description of why it failed.</summary>
        </member>
        <member name="T:Eco.Shared.Utils.TimedTaskProgressLogging">
            <summary> Utility functions to log TimedTask start and progress to the console, and parse and format the same messages for when running the server through the client</summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogTask(System.String)">
            <summary> Log task start to console with padding </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogProgress(System.String,System.Int32,System.Int32)">
            <summary> Log task progress to console with cursor offset. Resets cursor position after writting. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.LogTaskAndProgress(System.String,System.String)">
            <summary> Log task and progress to console. Used when same line reporting is not available </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimedTaskProgressLogging.ParseAndFormatLogParts(System.String)">
            <summary> Parse the name and progress of a task console message and format it for client UI display. Used by the client when running the server through the client. </summary>
        </member>
        <member name="M:Eco.Shared.Utils.TimeUtil.SecondsToTimeUnit(System.Double,Eco.Shared.Items.TimeUnits)">
            <summary>Converts seconds to desired unit of time</summary>
            <returns>Time converted to <paramref name="timeUnits"/></returns>
        </member>
        <member name="M:Eco.Shared.Utils.TimeUtil.ConvertTime(Eco.Shared.Items.TimeUnits,System.Double,Eco.Shared.Items.TimeUnits)">
            <summary>Converts time from one unit of time to another</summary>
            <returns>Time converted from <paramref name="startUnit"/> to <paramref name="finalUnit"/></returns>
        </member>
        <member name="F:Eco.Shared.Utils.TMPLinkTags.NoTooltip">
            <summary> Sometimes we do not want a tooltip to be generated at all. </summary>
        </member>
        <member name="F:Eco.Shared.Utils.TMPLinkTags.CopyToClipboard">
            <summary> Content to copy to clipboard on click. </summary>
        </member>
        <member name="T:Eco.Shared.Utils.UserTextureSize">
            <summary>enum for setting custom size to UserTexture in TMPro</summary>
        </member>
        <member name="M:Eco.Shared.Utils.UserTextureSizeUtils.TryGetUserTextureFromString(System.String,Eco.Shared.Utils.UserTextureSize@)">
            <summary>Finds the relevant UserTextureSize by the string value. (Check <see cref="M:Eco.Shared.Utils.UserTextureSizeExtensions.GetTagValue(Eco.Shared.Utils.UserTextureSize)"/> for better understanding.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.UserTextureSizeExtensions.GetTagValue(Eco.Shared.Utils.UserTextureSize)">
            <summary>Tag value for TMPro. (I.E img size = "small"/>) </summary>
        </member>
        <member name="M:Eco.Shared.Utils.UserTextureSizeExtensions.GetPixelSize(Eco.Shared.Utils.UserTextureSize)">
            <summary>Get TMPro sprite pixel size</summary>
        </member>
        <member name="T:Eco.Shared.Utils.VolatileUtils">
            <summary>
            Utility methods extending standard functionality of <see cref="T:System.Threading.Volatile"/> class (https://learn.microsoft.com/en-us/dotnet/api/system.threading.volatile).
            Read more about volatile and why it needed at https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile.
            </summary>
        </member>
        <member name="M:Eco.Shared.Utils.VolatileUtils.AssertTypeCompatability``1">
            <summary>Checks if <typeparamref name="T"/> can be used in <see cref="T:Eco.Shared.Utils.VolatileUtils"/> generic methods.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.VolatileUtils.Write``1(``0@,``0)">
            <summary>Exchange <typeparamref name="T"/> using appropriate <see cref="T:System.Threading.Volatile"/> write method if possible.</summary>
            <exception cref="T:System.NotSupportedException"> if type not supported.</exception>
        </member>
        <member name="M:Eco.Shared.Utils.VolatileUtils.Read``1(``0@)">
            <summary>Exchange <typeparamref name="T"/> using appropriate <see cref="T:System.Threading.Volatile"/> read method if possible.</summary>
            <exception cref="T:System.NotSupportedException"> if type not supported.</exception>
        </member>
        <member name="T:Eco.Shared.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Eco.Shared.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.DecompressArray``1(Eco.Shared.Serialization.BSONValue)">
            <summary>Array2Ds always come through as compressed bytes</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.ObjectTypeHandler(Eco.Shared.Serialization.BSONValue)">
            <summary> Unpacks object from <see cref="T:Eco.Shared.Serialization.BSONValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.ToBsonDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},Eco.Shared.Serialization.BsonSerializationContext@,System.Boolean)">
            <summary>Serializes enumerable of key-value pairs as BSON dictionary.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.MakeGenericDictionarySerializer``2">
            <summary>Makes generic dictionary lightweight (no reflection) delegate which just converts first argument from non-generic to generic dictionary and passes all other arguments.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.MakeGenericDictionarySerializer(System.Type)">
            <summary> Makes generic dictionary lightweight (no reflection) delegate which just converts first argument from non-generic to generic dictionary and passes all other arguments. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.FromBsonIDictionary(System.Type,Eco.Shared.Serialization.BSONObject)">
            <summary>Creates new dictionary from BSON <paramref name="obj"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.FromBsonToDictionary``2(Eco.Shared.Serialization.BSONObject,System.Collections.Generic.IDictionary{``0,``1})">
            <summary>Deserializes <paramref name="obj"/> to <paramref name="dictionary"/>. <paramref name="dictionary"/> elements will be replaced with new elements from BSON.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.FromBsonToDictionary(Eco.Shared.Serialization.BSONObject,System.Collections.IDictionary,System.Type,System.Type)">
            <summary>Deserializes <paramref name="obj"/> to <paramref name="dictionary"/>. <paramref name="dictionary"/> elements will be replaced with new elements from BSON.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForClassType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})">
            <summary>Register <see cref="T:Eco.Shared.Serialization.BsonManipulator.FromBsonFunction`1"/> for <typeparamref name="T"/> of class type.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForValueType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})">
            <summary>Register <see cref="T:Eco.Shared.Serialization.BsonManipulator.FromBsonFunction`1"/> for <typeparamref name="T"/> of value type.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonManipulator.BsonNullCondition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Helper function for <see cref="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForValueType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})"/> and <see cref="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForClassType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})"/>.
            Generates following expression <c>value == null || value.ValueType == BSONValueType.Null ? null : body</c>.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonManipulator.FromBsonFunction`1">
            <summary>FromBson function wrapper used by <see cref="M:Eco.Shared.Serialization.BsonManipulator.FromBson``1(Eco.Shared.Serialization.BSONValue)"/>. By default it uses <see cref="M:Eco.Shared.Serialization.BsonManipulator.FromBson(Eco.Shared.Serialization.BSONValue,System.Type)"/>, but uses optimized versions registered with <see cref="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForValueType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})"/> or <see cref="M:Eco.Shared.Serialization.BsonManipulator.RegisterFromBsonFunctionForClassType``1(System.Linq.Expressions.Expression{System.Func{Eco.Shared.Serialization.BSONValue,``0}})"/> when possible. For primitive types it is 3x times faster with optimized version and don't need to use boxing/unboxing form object with extra GC allocation.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONArray">
            <summary>
            Array of <see cref="T:Eco.Shared.Serialization.BSONValue"/> items. Used in binary serialization while data transfer data between client and server.
            It implements List like behavior based on shared array pool instead of backing List for better memory utilization.
            If we use a List then it will never drop in Capacity, eventually all lists in BSONArray will grow to match bigger capacity needed for often used arrays.
            I.e. if we transfer BSON array with size 100 once per second and use 100 BSONArray objects then:
            - with lists every time when BSONArray created (actually rented from pool) it may be a different BSONArray
            and it will be filled with 100 items even if all other BSON arrays we use need just 2-10 items. Now we have 100x100 = 10 000 capacity allocated and never released.
            - with array pools it will use same array from shared pool every time when BSONArray need to accept 100 items (assuming we don't have two BSON arrays of that size in parallel).
            All other arrays not exceed 10 items so we have just 100 + 99x10 = 1 090 capacity allocated instead of 10 000.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONArray.ClearNoRecycle">
            <summary>Clears <see cref="T:Eco.Shared.Serialization.BSONArray"/> without recycling it's items. May be useful when array copied to another BSONArray to avoid recycling items twice.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONArray.AddSpan(System.ReadOnlySpan{Eco.Shared.Serialization.BSONValue})">
            <summary>Adds new items form <paramref name="span"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONCachedValue">
            <summary>
            <see cref="T:Eco.Shared.Serialization.BSONCachedValue"/> may be used to cache any other <see cref="T:Eco.Shared.Serialization.BSONValue"/> and to be used in place of it. Cached <see cref="T:Eco.Shared.Serialization.BSONValue"/> will be pre-serialized to byte array and helps to save serialization time.
            When decoded it will be deserialized as a cached BSONValue. There no need for additional handling on receiving side.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONCachedValue.Cache(Eco.Shared.Serialization.BSONValue)">
            <summary>Encodes <paramref name="value"/> to binary form and saves it to <see cref="F:Eco.Shared.Serialization.BSONCachedValue.CachedBytes"/>. Returned <see cref="T:Eco.Shared.Serialization.BSONCachedValue"/> can't be modified. Cached value will be recycled!</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONCachedValue.Recycle">
            <summary>Recycle does nothing, because usually cached value shared between multiple BSON objects.</summary>
        </member>
        <member name="F:Eco.Shared.Serialization.BSONObject.refs">
            <value> References count. </value>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryIncrementRef">
            <summary>
            Every time when you create a ref for shared BSONObject you have to increment ref.
            In this case it will be recycled only when last ref will be recycled.
            </summary>
            <returns><c>true</c> if ref was increased, <c>false</c> if ref can't be increased because of all existing refs was already recycled and this object is invalid.</returns>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetStringValue(System.String,System.String@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.String"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetLocStringValue(System.String,Eco.Shared.Localization.LocString@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:Eco.Shared.Localization.LocString"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetGuidValue(System.String,System.Guid@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Guid"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt32Value(System.String,System.Int32@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Int32"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt64Value(System.String,System.Int64@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Int64"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetFloatValue(System.String,System.Single@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Single"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetDoubleValue(System.String,System.Double@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Double"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetArrayValue(System.String,Eco.Shared.Serialization.BSONArray@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:Eco.Shared.Serialization.BSONArray"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetArrayValueAsList``1(System.String,System.Collections.Generic.List{``0}@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Collections.Generic.List`1"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONObject.TryGetInt32ArrayValueAsList(System.String,System.Collections.Generic.List{System.Int32}@)">
            <summary> Returns value for <paramref name="key"/> converted to <see cref="T:System.Collections.Generic.List`1"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonSerializationContext">
            <summary> This is used when you send views to some client. Client is necesary to bind to him controllers and to get right value for params PropertyName(Player player).
            RelatedControllers are used for caching system, so when you cache some view it will be known which exact controllers you should package too (otherwise you could get cached value that refers not-existed at your side controllers). </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONSimpleValue">
            <summary>Represents simple value (like float, double, int, string etc).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONSimpleValue.TryPerformRecycle">
            <summary>Releases all resources (nullify refs for GC and return pooled objects).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONSimpleValue.DisablePooling``1">
            <summary>Disables pooling for <see cref="F:Eco.Shared.Serialization.BSONSimpleValue.arrayValue"/> and ensures the array has correct size, because pooled array may be greater than actual array.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValue">
            <summary>Base class for <see cref="T:Eco.Shared.Serialization.BSONSimpleValue"/>, <see cref="T:Eco.Shared.Serialization.BSONArray"/> and <see cref="T:Eco.Shared.Serialization.BSONObject"/>.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.BinaryValue">
            <summary>Returns array of byte values. When possible use <see cref="P:Eco.Shared.Serialization.BSONValue.ByteSpanValue"/> instead to reduce allocations with pooling. When array accessed then we can't control references on it anymore and can't return it back to pool.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.ByteSpanValue">
            <summary>Returns byte <see cref="T:System.ReadOnlySpan`1"/>, should always be preferred over <see cref="P:Eco.Shared.Serialization.BSONValue.BinaryValue"/> because latter disables pooling for the value.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.UShortArrayValue">
            <summary>Returns array of ushort values. When possible use <see cref="P:Eco.Shared.Serialization.BSONValue.UShortSpanValue"/> instead to reduce allocations with pooling. When array accessed then we can't control references on it anymore and can't return it back to pool.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.UShortSpanValue">
            <summary>Returns ushort <see cref="T:System.ReadOnlySpan`1"/>, should always be preferred over <see cref="P:Eco.Shared.Serialization.BSONValue.UShortArrayValue"/> because latter disables pooling for the value.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.IntArrayValue">
            <summary>Returns array of int values. When possible use <see cref="P:Eco.Shared.Serialization.BSONValue.IntSpanValue"/> instead to reduce allocations with pooling. When array accessed then we can't control references on it anymore and can't return it back to pool.</summary>
        </member>
        <member name="P:Eco.Shared.Serialization.BSONValue.IntSpanValue">
            <summary>Returns int <see cref="T:System.ReadOnlySpan`1"/>, should always be preferred over <see cref="P:Eco.Shared.Serialization.BSONValue.IntArrayValue"/> because latter disables pooling for the value.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewViewRef(System.Int32)">
            <summary>Creates new <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewRef"/> value.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewTypeId(System.Int32)">
            <summary>Creates new <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewTypeId"/> value.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewBsonValue(System.Collections.Generic.ICollection{System.UInt16})">
            <summary>Makes new <see cref="T:Eco.Shared.Serialization.BSONValue"/> from <paramref name="values"/> using pooled array and saving GC allocations.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.NewBsonValue(System.Collections.Generic.ICollection{System.Int32})">
            <summary>Makes new <see cref="T:Eco.Shared.Serialization.BSONValue"/> from <paramref name="values"/> using pooled array and saving GC allocations.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.SimpleValueFromArray(System.Array,Eco.Shared.Serialization.BSONValueType)">
            <summary>Private method used by other FromCollection methods to make a <see cref="T:Eco.Shared.Serialization.BSONValue"/> from <paramref name="values"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValue.SimpleValueFromCollection``1(System.Collections.Generic.ICollection{``0},Eco.Shared.Serialization.BSONValueType)">
            <summary>Private method used by other FromCollection methods to make a <see cref="T:Eco.Shared.Serialization.BSONValue"/> from <paramref name="values"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonValueBackgroundRecycler">
            <summary>BSON Values background recycler. <see cref="M:Eco.Shared.Serialization.BsonValueBackgroundRecycler.RecycleInBackground(Eco.Shared.Serialization.BSONValue)"/> may be used to move <see cref="T:Eco.Shared.Serialization.BSONValue"/> recycling out of executing thread to save CPU resources where it is critical.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonValueBackgroundRecycler.RecycleTask">
            <summary>Background worker which recycles BSON values from queue.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BsonValueBackgroundRecycler.RecycleInBackground(Eco.Shared.Serialization.BSONValue)">
            <summary>Recycles <paramref name="bsonValue"/> in background. Not guaranteed when it will be recycled. May be used in performance critical code to save CPU time on recycling, but usually it is better to use <see cref="M:Eco.Shared.Serialization.BSONValue.Recycle"/> for faster returning resources back to pool.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValueFactory`1">
            <summary>Reusable <see cref="T:Eco.Shared.Serialization.BSONValue"/> values factory.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValueFactory`1.New(Eco.Shared.Serialization.BSONValueType)">
            <summary>Either makes new <see cref="T:Eco.Shared.Serialization.BSONValue`1"/> with <see cref="F:Eco.Shared.Serialization.BSONValueFactory`1.newInstance"/> or uses recycled value from <see cref="F:Eco.Shared.Serialization.BSONValueFactory`1.recycledBsons"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.BSONValueFactory`1.Recycle(`0)">
            <summary>Recycles <paramref name="value"/> making it available for re-usage.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BSONValueType">
            <summary>Value type of <see cref="T:Eco.Shared.Serialization.BSONValue"/>. <see cref="T:Eco.Shared.Serialization.BSONValue"/> may be used to store different value types and with that enum they may be distinguished.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonAutoSerializeAttribute">
            <summary> Mark a partial class or struct to implement IBsonSerialize using automatic source generator </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonManualSerializeAttribute">
            <summary>
            Mark a class or struct to indicate to BsonSerializeGenerator that it implements IBsonSerialize manually.
            Mainly used for BSONObject which has a unique implementation.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.BsonSerializeIgnoreAttribute">
            <summary> Mark a property or field as ignored by IBsonSerialize automatic source generator </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.IBsonSerializable">
            <summary>Adds support for serializing to a <see cref="T:Eco.Shared.Serialization.BSONArray"/> instance. Should not be implemented manually, instead use <see cref="T:Eco.Shared.Serialization.BsonAutoSerializeAttribute"/></summary>
        </member>
        <member name="M:Eco.Shared.Serialization.IBsonSerializable.ToBson">
            <summary>Creates a new <see cref="T:Eco.Shared.Serialization.BSONArray"/> instance from this object.</summary>
            <returns>Object serialized into a <see cref="T:Eco.Shared.Serialization.BSONArray"/>.</returns>
        </member>
        <member name="T:Eco.Shared.Serialization.IBsonDeserializable">
            <summary>Adds support for deserializing from a <see cref="T:Eco.Shared.Serialization.BSONArray"/> instance. Should not be implemented manually, instead use <see cref="T:Eco.Shared.Serialization.BsonAutoSerializeAttribute"/></summary>
        </member>
        <member name="M:Eco.Shared.Serialization.IBsonDeserializable.FromBson(Eco.Shared.Serialization.BSONArray)">
            <summary>Reads a <see cref="T:Eco.Shared.Serialization.BSONArray"/> object instance into memory.</summary>
            <param name="bson"><see cref="T:Eco.Shared.Serialization.BSONArray"/> to read from.</param>
        </member>
        <member name="T:Eco.Shared.Serialization.IBsonSerialize">
            <summary> Adds support for serializing and deserializing from a <see cref="T:Eco.Shared.Serialization.BSONArray"/> instance. Should not be implemented manually, instead use <see cref="T:Eco.Shared.Serialization.BsonAutoSerializeAttribute"/></summary>
            <seealso cref="T:Eco.Shared.Serialization.IBsonSerializable"/>
            <seealso cref="T:Eco.Shared.Serialization.IBsonDeserializable"/>
        </member>
        <member name="T:Eco.Shared.Serialization.Internal.BsonValueWithStatsRecording">
            <summary><see cref="T:Eco.Shared.Serialization.BSONValue"/> which may be used to wrap another <see cref="T:Eco.Shared.Serialization.BSONValue"/> for encoding stats recording.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.Internal.BsonValueWithStatsRecording.EncodeElement(System.IO.MemoryStream)">
            <summary>Do the encode, and record stats about it.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedAsEnumerableAttribute">
            <summary>Custom types serialized as enumerable collections (like Dictionary or List) should have that attribute.</summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedAttribute">
            <summary> This symbol will be serialized to BSON for storage in the world file. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.ForceSerializeFullObjectAttribute">
            <summary> Used in conjunction with SerializedAttribute to designate that a member needs to be fully saved, not using references. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.UsesReferenceInHashCode">
            <summary> Used when a class needs references resolved before it can calculate its hashcode. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializedDerivedAttribute">
            <summary> Will be serialized to BSON for storage in the world file, and applies to all derived classes too. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.ThreadSafeAttribute">
            <summary>
            When serializing some types, such as enumerables, the enumeration must not change - to enforce this, some designate "threadsafe" objects use this attribute, such as the immutable collections.
            When using this attribute manually, proper locking and other checks must be used the ensure thread safety - in general, use the ThreadSafe collections, but if you are SURE that your container
            is thread safe, go ahead and add this attribute.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SerializesTypeAttribute">
            <summary> Specify that this class serializes specific object types that might not otherwise be determined through reflection. </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.JsonUseAttribute">
            <summary>
            Overrides default strategy for ExpandableObjectContractResolver, it will use this attribute even if read-only and serializeReadOnlyProperties == false.
            </summary>
        </member>
        <member name="T:Eco.Shared.Serialization.SharedBSONObject">
            <summary>
            Use this object if you have to share bson object.
            I.e. Player.animationData stored as shared object and then delivered to all clients.
            It keeps tracking of all object references and only recycle object when all references recycled.
            </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.WithStatsRecording(Eco.Shared.Serialization.BSONValue)">
            <summary>Adds stats recording to <paramref name="value"/>. Returns another <see cref="T:Eco.Shared.Serialization.BSONValue"/> object which wraps <paramref name="value"/> with stats recording loogic.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.LoadCompressed(System.ReadOnlySpan{System.Byte})">
            <summary>Loads <see cref="T:Eco.Shared.Serialization.BSONObject"/> from LZ4 compressed <paramref name="data"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DumpTo(System.IO.MemoryStream,Eco.Shared.Serialization.BSONArray)">
            <summary> Dumps BSON array to memory stream. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.RentOrCreateArray``1(Eco.Shared.Serialization.BSONSimpleValue,System.Int32,``0[]@)">
            <summary>Rents array from shared pool when it makes sense for it's size and configures <paramref name="bson"/> accordingly (set arraySize and poolingEnabled flag).</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DecodeSimpleArrayValue``1(System.IO.MemoryStream,Eco.Shared.Serialization.BSONValueType)">
            <summary>Decodes simple array value (i.e. <see cref="F:Eco.Shared.Serialization.BSONValueType.UShortArray"/> or <see cref="F:Eco.Shared.Serialization.BSONValueType.IntArray"/>) from stream.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.DecodeLocString(System.IO.MemoryStream)">
            <summary> Decodes LocString from binary data. <see cref="M:Eco.Shared.Serialization.SimpleBSON.EncodeLocString(System.IO.MemoryStream,Eco.Shared.Localization.LocString)"/> about binary format details. </summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.EncodeContent(System.IO.MemoryStream,Eco.Shared.Serialization.BSONValue)">
            <summary>Encode content of <see cref="T:Eco.Shared.Serialization.BSONValue"/>. Unlike <see cref="M:Eco.Shared.Serialization.SimpleBSON.EncodeElement(System.IO.MemoryStream,Eco.Shared.Serialization.BSONValue)"/> it doesn't support null values and doesn't encode value type.</summary>
        </member>
        <member name="M:Eco.Shared.Serialization.SimpleBSON.EncodeElement(System.IO.MemoryStream,Eco.Shared.Serialization.BSONValue)">
            <summary>Encodes element of other <see cref="T:Eco.Shared.Serialization.BSONValue"/> (i.e. <see cref="T:Eco.Shared.Serialization.BSONObject"/> or <see cref="T:Eco.Shared.Serialization.BSONArray"/>). For polymorphism support it encodes <see cref="T:Eco.Shared.Serialization.BSONValueType"/> before value content.</summary>
        </member>
        <member name="T:Eco.Shared.Services.ElectionComment">
            <summary>A custom tailored comment for use in elections web interface (ElectionController). Gets stored in Election.</summary>
        </member>
        <member name="T:Eco.Shared.Services.ExcludeFromChatAttribute">
            <summary>Don't show this category in chat tab picker</summary>
        </member>
        <member name="T:Eco.Shared.Services.InstantNotificationPosition">
            <summary> For instant notifications, position of notification in screen sent as parameter in RPC method. </summary>
        </member>
        <member name="T:Eco.Shared.Services.LockedInChinaAttribute">
            <summary> attribute for making properties readonly when ChinaLockedMode </summary>
            used mainly for testing, allowing to use props otherwise hidden
        </member>
        <member name="T:Eco.Shared.Services.VisibleForQAOnlyAttribute">
            <summary> attribute for making plugin properties visible when QA enabled </summary>
            used mainly for testing, allowing to display/interect with props otherwise hidden
            e.g.: expose ChinaLockedMode prop for QA
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.IsQAModeActive">
            <summary>Is QA mode enabled/disabled</summary>
        </member>
        <member name="M:Eco.Shared.Services.QualityAssurance.UpdateFlagsAndStatus">
            <summary>Enables/Disables all QA options</summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.BlockTags">
            <summary>Stores shortcuts to Block Tags</summary>
            <remarks>Shortcuts from this class should be used instead of directly typing a string in TagAttribute</remarks>
        </member>
        <member name="T:Eco.Shared.SharedTypes.NameAndDescription">
            <summary>General struct for passing a name and description around.</summary>
        </member>
        <member name="P:Eco.Shared.SharedTypes.NameAndDescription.Valid">
            <summary>Valid is determined by non-null (empty strings are ok)</summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.ComponentInteractionParameterNames">
            <summary> Parameters that are associated with WorldObjectComponents and affect interactions. These are sent to the client from server. </summary>
            <remarks> Typically these exist per-(WorldObject, User) combo, so different Users may have see parameters on the same WorldObject. </remarks>
        </member>
        <member name="T:Eco.Shared.SharedTypes.VehicleInteractionParameterNames">
            <summary> Vehicle Interactions parameters shared between client and server </summary>
            Do not change member list position
        </member>
        <member name="T:Eco.Shared.SharedTypes.ClientSideInteractionParameterNames">
            <summary> These parameters ONLY exist on the client and are NEVER sent to the server. The server can and should still use them though (read below). </summary>
            <remarks> Any of these keys can be added as a required parameter on the interaction definitions sent by the server, so the client can decide whether an interaction should be displayed or not. </remarks>
        </member>
        <member name="T:Eco.Shared.SharedTypes.InteractionTriggerInfo">
            <summary> Wrapper struct for a Trigger (LMB/RMB/Interact) + a Modifier (Ctrl/Alt/Shift). </summary>
            <remarks> Used to define the input needed to trigger an interaction. </remarks>
        </member>
        <member name="T:Eco.Shared.SharedTypes.InteractionParameters">
            <summary> Contains various extra parameters that can be passed from InteractionTarget to get details on the specific part of the object being targeted (e.g branch/trunk/leaf on a tree) or its state (alive/dead animal, pickupable, ..). </summary>
        </member>
        <member name="F:Eco.Shared.SharedTypes.InteractionParameters.CachedParams">
            <summary>
            <para> Changes to these cause the interaction display to rebuild, even if the target 'NetObject'/'WorldObject' is the same. </para>
            <para> This needs to happen because different parameters can indicate different interactions on the same target. </para>
            </summary>
            <remarks> Includes things like LeafID/BranchID when targeting trees or elevator buttons Up/Down/Stop. </remarks>
        </member>
        <member name="F:Eco.Shared.SharedTypes.InteractionParameters.UncachedParams">
            <summary> Changes to these won't cause the interaction display to rebuild, unlike the <see cref="F:Eco.Shared.SharedTypes.InteractionParameters.CachedParams"/>. </summary>
            <remarks> Includes parameters that can be used from the server to resolve the interaction (e.g.: slice point when targeting a trunk). </remarks>
        </member>
        <member name="M:Eco.Shared.SharedTypes.InteractionParameters.op_Addition(Eco.Shared.SharedTypes.InteractionParameters,Eco.Shared.SharedTypes.InteractionParameters)">
            <summary> returns new <see cref="T:Eco.Shared.SharedTypes.InteractionParameters"/> with all <paramref name="left"/> values and adds uniques from <paramref name="right"/> </summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.InteractionTarget">
            <summary>Struct that defines something the player is looking at.  Can be a block or object.</summary>
        </member>
        <member name="F:Eco.Shared.SharedTypes.InteractionTarget.HitPos">
            These aren't used for equality checks, make sure these are excluded from .Equals()
        </member>
        <member name="M:Eco.Shared.SharedTypes.InteractionTargetComparer.Equals(Eco.Shared.SharedTypes.InteractionTarget,Eco.Shared.SharedTypes.InteractionTarget)">
            <summary> Excluded HitPos and HitNormal so targets can be considered same even if pointer is pointing at a different spot </summary>
        </member>
        <member name="M:Eco.Shared.SharedTypes.InteractionTargetComparer.GetHashCode(Eco.Shared.SharedTypes.InteractionTarget)">
            <summary>Excluded hitpos and hitnormal from hashcode generation, hit information is not relevant to target comparison</summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.InteractionConstants">
            <summary>Shared class that contains constants used in the interaction system</summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.ClientSideEnvironmentVariables">
            <summary> Client side environment variables guaranteed to be on client at all times. </summary>
            <remarks> Can be used in a string with the %VARNAME% syntax to get replaced with the respective text in client. </remarks>
        </member>
        <member name="T:Eco.Shared.SharedTypes.MoveWorldObjectActionInfo">
            <summary> Server returns this struct as a response to a MoveWorldObject action request, when Ctrl+Clicking with the hammer. </summary>
        </member>
        <member name="T:Eco.Shared.SharedTypes.SelectionMode">
            <summary> The selection mode of a target BlockFillView. The hammer will adjust its behaviour based the Selection Mode that it uses. </summary>
        </member>
        <member name="T:Eco.Shared.States.ExpressionEmote">
            <summary> Stores the various player (facial) expression emote states. </summary>
        </member>
        <member name="T:Eco.Shared.States.AnimationEmote">
            <summary> Stores the various player (body) emote states. </summary>
        </member>
        <member name="T:Eco.Shared.States.ModularVehicleToolState">
            <summary> Stores current vehicle tool state, depending on animation/delays/etc </summary>
        </member>
        <member name="T:Eco.Shared.States.AnimationEat">
            <summary> Stores the various player eat states. Needed for 3rd person eating switches </summary>
        </member>
        <member name="T:Eco.Shared.States.AnimationEmoteHelper">
            <summary>Holds data about animation emotes that's needed on the client.</summary>
        </member>
        <member name="P:Eco.Shared.States.AnimationEmoteHelper.EmotesWithoutIK">
            <summary>Emotes in this list behave improperly when on uneven ground and avatar IK is enabled, client disables IK while playing these emotes.</summary>
        </member>
        <member name="T:Eco.Shared.Streams.FastBufferedWriteStream">
            <summary>Fast optimized alternative to <see cref="T:System.IO.BufferedStream"/> with write-only non-seekable support which allows to minimize number of checks and calculations, because of limitations.</summary>
        </member>
        <member name="T:Eco.Shared.Streams.FastReusableBufferedWriteStream">
            <summary>Extends <see cref="T:Eco.Shared.Streams.FastBufferedWriteStream"/> with re-usability logic. It allows to call <see cref="M:Eco.Shared.Streams.FastReusableBufferedWriteStream.Reset(System.IO.Stream)"/> with new backing stream instead of new buffered stream instance creation. Initially initialized with <see cref="F:System.IO.Stream.Null"/> backing stream.</summary>
        </member>
        <member name="M:Eco.Shared.Streams.FastReusableBufferedWriteStream.Reset(System.IO.Stream)">
            <summary>Use this method to Reset to another backing Stream. It won't Flush to previous stream so you should call <see cref="M:Eco.Shared.Streams.FastBufferedWriteStream.Flush"/> explicitly if needed.
            <see cref="P:Eco.Shared.Streams.FastBufferedWriteStream.Position"/> and <see cref="P:Eco.Shared.Streams.FastBufferedWriteStream.Length"/> set to 0 after call to the method.</summary>
        </member>
        <member name="T:Eco.Shared.Streams.SubStream">
            <summary>
            Wrapper around existing stream which allows to use portion of stream without copying it to another stream.
            </summary>
        </member>
        <member name="P:Eco.Shared.Streams.SubStream.CanSeek">
            <summary>
             Not supported for now, but may be implemented.
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)">
            <summary>
            Add a section.
            </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLoc(System.FormattableString,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddSectionLocStr(System.String,Eco.Shared.Text.InfoBuilder)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AddDashSectionLocStr(System.String,Eco.Shared.Text.InfoBuilder)">
            <summary>Adds '- ' to section tittle. See <see cref="M:Eco.Shared.Text.InfoBuilder.AddSection(Eco.Shared.Localization.LocString,Eco.Shared.Text.InfoBuilder)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine">
            <summary> Appends new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)">
            <summary> Appends <see cref="T:Eco.Shared.Localization.LocString"/> with new line to <see cref="T:Eco.Shared.Text.InfoBuilder"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLoc(System.FormattableString)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendDashLineLoc(System.FormattableString)">
            <summary>Adds '- ' to line. See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendLineLocStr(System.String)">
            <summary>See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Text.InfoBuilder.AppendDashLineLocStr(System.String)">
            <summary> Adds '- ' to line, See <see cref="M:Eco.Shared.Text.InfoBuilder.AppendLine(Eco.Shared.Localization.LocString)"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Threshold.IThreshold`1">
            <summary>
            Threshold value interface. May be used to update value with threshold checking to avoid spamming value change events.
            </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)">
            <summary>
            Try pass threshold with specified <paramref name="delta"/>. It will aggregate delta for multiple calls until the threshold reached then total delta value will reset.
            </summary>
            <param name="delta">delta between last value and new value.</param>
            <returns><c>true</c> if threshold passed with this (and all previous deltas), <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)">
            <summary> Updates <paramref name="value"/> to <paramref name="newValue"/>. It returns result of (see <see cref="M:Eco.Shared.Threshold.IThreshold`1.TryPass(`0)"/>) for delta between <paramref name="value"/> and <paramref name="newValue"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Threshold.IThreshold`1.ClampValue(`0@,`0,`0,`0)">
            <summary> It updates value as <see cref="M:Eco.Shared.Threshold.IThreshold`1.UpdateValue(`0@,`0)"/>, but also clamps it to specified range and if the value changed and <paramref name="newValue"/> on bounds then returns <c>true</c>. </summary>
        </member>
        <member name="T:Eco.Shared.Time.TimeLimit">
            <summary>Represents time limit which may be checked for expiration and overtime.</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.#ctor(System.Int64)">
            <summary>Creates <see cref="T:Eco.Shared.Time.TimeLimit"/> from <see cref="T:System.Diagnostics.Stopwatch"/> ticks (note they may be not same as <see cref="P:System.TimeSpan.Ticks"/>).</summary>
        </member>
        <member name="M:Eco.Shared.Time.TimeLimit.SubLimitFromTicks(System.Int64,System.Int64@)">
            <summary> Creates new limit with upper bound set to current limit. </summary>
            <param name="ticks">new limit ticks.</param>
            <param name="truncatedTicks">number of ticks truncated to match current limit.</param>
            <returns>new TimeLimit object.</returns>
        </member>
        <member name="T:Eco.Shared.Tools.AggregatedValue">
            <summary>Aggregated value. May be used for optimized calculation of Min, Max, Sum, Count and Average.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.AggregatingValueRecorder">
            <summary><see cref="T:Eco.Shared.Tools.IValueRecorder"/> aggregating data by specific period. I.e. per second or per minute. Aggregates number of recorded values and total duration per period.</summary>
        </member>
        <member name="P:Eco.Shared.Tools.AggregatingValueRecorder.AggregatedCount">
            <summary>Returns number of events per period aggregated data. I.e. per second.</summary>
        </member>
        <member name="P:Eco.Shared.Tools.AggregatingValueRecorder.AggregateDuration">
            <summary>Returns duration of all events per period aggregated data. I.e. per second.</summary>
        </member>
        <member name="P:Eco.Shared.Tools.AggregatingValueRecorder.Period">
            <summary>Aggregation period.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.AggregatingValueRecorder.FlushCompleted">
            <summary>Ensures all periods data aggregated. Usually it auto flushes when next period starts, but for rare events it may not happen and require manual flush.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.AggregatingValueRecorder.FlushCompleted(System.Int64)">
            <summary>Adds active aggregated value stats to <see cref="F:Eco.Shared.Tools.AggregatingValueRecorder.count"/> and <see cref="F:Eco.Shared.Tools.AggregatingValueRecorder.duration"/> aggregated values if <paramref name="ticks"/> after <see cref="F:Eco.Shared.Tools.AggregatingValueRecorder.nextBreakdown"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.DetectingValueRecorder">
            <summary><see cref="T:Eco.Shared.Tools.PerformanceCounter"/> which detects values which has duration over expected and emits static event for them.</summary>
        </member>
        <member name="E:Eco.Shared.Tools.DetectingValueRecorder.PerformanceIssueDetected">
            <summary>Event which reported every time when outstanding value detected. Stack trace is optional and only provided when <see cref="F:Eco.Shared.Tools.DetectingValueRecorder.GrabStacktrace"/> is <c>true</c>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.DetectingValueRecorderExtensions.WithPerformanceIssuesDetection(Eco.Shared.Tools.PerformanceCounter,System.TimeSpan,System.Boolean)">
            <summary>Adds <see cref="T:Eco.Shared.Tools.DetectingValueRecorder"/> to <see cref="T:Eco.Shared.Tools.PerformanceCounter"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.IValueRecorder.RecordValue(Eco.Shared.Tools.PerformanceCounterValue@)">
            <summary>Called for every recorded value with <see cref="T:Eco.Shared.Tools.IValueRecorder"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounter">
            <summary>
            A PerformanceCounter is a collection of values with performance data for a single topic.
            Values will be grouped together under the PerformanceCounter name, but can optionally have text associated
            with them individually too.
            </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.#ctor(System.String,System.Int32)">
            <summary>Create a PerformanceCounter with the maximum number of historical values stored.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.GetRecorders``1">
            <summary>Returns all value recorders of type <typeparamref name="T"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.String,System.Object)">
            <summary> Add a value with an optional name. Call Dispose to end duration time, or use a using block.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddValue(System.TimeSpan,System.String,System.Object)">
            <summary> Add a value with an optional name with known duration.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.AddMarker">
            <summary> Add an event marker, which is a durationless event.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.Add(System.TimeSpan,System.String,System.Object)">
            <summary>
            "Adds" new performance counter value.
            It may be added as pre-calculated value (then it should have <paramref name="initialDuration"/>) or as value start point.
            In this case returned value should be disposed to record elapsed duration.
            You can also provide optional name for the report (may be useful if you share one counter for multiple similar metrics like RPC calls for different functions).
            </summary>
            <remarks>
            This method not actually adds new value every time, but instead allocates index in pre-created array of values for optimal performance and memory allocations.
            This array of values works as cyclic buffer. Once filled it will start again from first index. Iterating through the array you will always have last <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>.
            <p><see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> always set to next write position. It uses CAS for atomic <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> updates:<ul>
            <li>get current head as value index;</li>
            <li>calculate new head as value index + 1 (or 0 if it is greater or equal than <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>);</li>
            <li>try set <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> to new head or repeat steps if <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> changed during these operations.</li>
            </ul></p>
            <p>Once <see cref="F:Eco.Shared.Tools.PerformanceCounter.Head"/> updated it checks if value index extends current value range (from 0 till <see cref="F:Eco.Shared.Tools.PerformanceCounter.MaxValues"/>). If value index greater or equal than <see cref="F:Eco.Shared.Tools.PerformanceCounter.Length"/>
            then it sets <see cref="F:Eco.Shared.Tools.PerformanceCounter.Length"/> to value index + 1.</p>
            </remarks>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.Aggregate(System.TimeSpan)">
            <summary>Get the min, max, and average for the specified period of time.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.Aggregate">
            <summary>Get the min, max, and average for the history of values.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.TryGetLastValue(System.Double@)">
            <summary>Attempts to retrieve the last value stored.</summary>
            <param name="value">Value stored if it exists. Otherwise 0</param>
            <returns><c>true</c> if a value was retrieved. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounter.WithValueRecorder(Eco.Shared.Tools.IValueRecorder)">
            <summary>Empowers <see cref="T:Eco.Shared.Tools.PerformanceCounter"/> with <paramref name="valueRecorder"/>. Do it before start using the counter to avoid multi-threading issues.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterExtensions">
            <summary> Helper extension methods for <see cref="T:Eco.Shared.Tools.PerformanceCounter"/>. </summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceCounterExtensions.AddValueIfActive(Eco.Shared.Tools.PerformanceCounter,System.String)">
            <summary> Adds new value only if <see cref="P:Eco.Shared.Tools.PerformanceManager.Active"/> is <c>true</c>. Returns <c>default</c> value otherwise which won't record any metric on <see cref="M:System.IDisposable.Dispose"/>"/>. </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValue">
            <summary>
            A single value for a performance counter.
            </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceCounterValueRef">
            <summary> A reference to a single performance counter. </summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceIssue">
            <summary>Structure containing information about performance issue detected by <see cref="T:Eco.Shared.Tools.DetectingValueRecorder"/>.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceManager">
            <summary> Class for managing performance counters (<see cref="T:Eco.Shared.Tools.PerformanceCounter"/>) and producing performance reports. </summary>
        </member>
        <member name="P:Eco.Shared.Tools.PerformanceManager.Default">
            <summary>Returns Default <see cref="T:Eco.Shared.Tools.PerformanceManager"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.AddPerformanceCounter(System.String,System.Int32)">
            <summary>Adds new performance counter. If performance counter with same name already exists then throws <see cref="T:System.InvalidOperationException"/>..</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.AddPerformanceCounter(System.String,System.Func{Eco.Shared.Tools.PerformanceCounter,Eco.Shared.Tools.PerformanceCounter})">
            <summary>Adds new performance counter. If performance counter with same name already exists then throws <see cref="T:System.InvalidOperationException"/>. Uses <paramref name="configure"/> for custom counter configuration.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.AddPerformanceCounter(System.String,System.Int32,System.Func{Eco.Shared.Tools.PerformanceCounter,Eco.Shared.Tools.PerformanceCounter})">
            <summary>Adds new performance counter. If performance counter with same name already exists then throws <see cref="T:System.InvalidOperationException"/>. Uses <paramref name="configure"/> for custom counter configuration.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.AddPerformanceCounter(Eco.Shared.Tools.PerformanceCounter)">
            <summary>Adds new performance counter. If performance counter with same name already exists then throws <see cref="T:System.InvalidOperationException"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.SaveReport(Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Saves report to PerformanceManagerReport.txt or PerformanceManagerReport.json (for Trace format).</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.GetReport(Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Returns report as string. Content depends on <paramref name="format"/>. Read details about format in <see cref="T:Eco.Shared.Tools.PerformanceReportFormat"/> documentation.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReport(System.IO.TextWriter,Eco.Shared.Tools.PerformanceReportFormat)">
            <summary>Writes report to <paramref name="writer"/>. Content depends on <paramref name="format"/>. Read details about format in <see cref="T:Eco.Shared.Tools.PerformanceReportFormat"/> documentation.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportFullFormat(System.IO.TextWriter)">
            <summary>Writes report in full format with all counter values.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportShortFormat(System.IO.TextWriter)">
            <summary>Writes report in short format. Only summary statistic (minimum, maximum and average values).</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportShorterFormat(System.IO.TextWriter)">
            <summary>Writes report in Shorter format, condensing information more than Short version, not supporting specific periods.</summary>
        </member>
        <member name="M:Eco.Shared.Tools.PerformanceManager.WriteReportTraceFormat(System.IO.TextWriter)">
            <summary>Writes report in trace format. Contains all data from counters in JSON format.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.PerformanceReportFormat">
            <summary>Enum of performance report formats.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.SumAndCount">
            <summary>Sum and count aggregation. Can be used for <see cref="P:Eco.Shared.Tools.SumAndCount.Average"/> calculation.</summary>
        </member>
        <member name="T:Eco.Shared.Tools.TotalsRecorder">
            <summary>Totals recorder for <see cref="T:Eco.Shared.Tools.PerformanceCounter"/>.</summary>
        </member>
        <member name="T:Eco.Shared.UI.MultiSelectorPopUpFlags">
            <summary> Flags for customizing The MultiSelector Pop up behavior. </summary>
        </member>
        <member name="T:Eco.Shared.Validation.PropertyValidationUtils">
            <summary>Utilities to work with ValidationAttribute. Could be used on client.</summary>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValues(System.Object)">
            <summary>Tries to fix all values to fit it's RangeAttribute's restrictions.</summary>
            <param name="propertyContainer">Iterates through propertyContainer properties with RangeAttribute set.</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.ClampRangeFloatValue(System.Object,System.String)">
            <summary>Tests if object's property contains float RangeAttribute and tries to fix that. Produces error message if invalid object was found.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Propery name to test</param>
            <returns>Returns true if object has invalid values and was modified</returns>
        </member>
        <member name="M:Eco.Shared.Validation.PropertyValidationUtils.GetPropertyFloatRange(System.Object,System.String)">
            <summary>Get object's given property float range restrictions. If it has not RangeAttribute of valid float values returns whole float range.</summary>
            <param name="propertyContainer">Object with given property</param>
            <param name="propertyName">Property name to test</param>
            <returns>Returns effective float range</returns>
        </member>
        <member name="T:Eco.Shared.View.EventSubscription">
            <summary>Subscription for <see cref="T:Eco.Shared.View.ISubscribableEvent"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.IObservable">
            <summary>Interface for objects which may be subscribed (observed) for property changes.</summary>
        </member>
        <member name="T:Eco.Shared.View.IPropertySubscription">
            <summary>Interface for property change subscriptions. Holds information about observable subject, invocation target and method. May be invoked to notify subscription.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscription">
            <summary>Interface for all subscription classes. May be either <see cref="T:Eco.Shared.View.Subscriptions"/> for subscriptions group or <see cref="T:Eco.Shared.View.IPropertySubscription"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscription.ReturnToPool">
            <summary>Optional ReturnToPool method (returns subscription to pool if possible).</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscriptions">
            <summary>Untyped version of <see cref="T:Eco.Shared.View.ISubscriptions`1"/> with <see cref="M:Eco.Shared.View.ISubscriptions.UnsubscribeAll"/> and <see cref="M:Eco.Shared.View.ISubscriptions.ReleaseSubscriptionsList"/> methods which may be useful for destroy/dispose methods which unaware of subscriptions list type.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptions.UnsubscribeAll">
            <summary>Unsubscribe all subscriptions in the subscriptions list.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptions.ReleaseSubscriptionsList">
            <summary><see cref="M:Eco.Shared.View.ISubscriptions.UnsubscribeAll"/> and release subscriptions list.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscriptions`1">
            <summary>
            This is a replacement for IAnonymousSubscriber.
            This simplifies Subscription management, because you can use it with extension methods for easy subscription management.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptions`1.GetOrCreateSubscriptionsList">
            <summary>Gets existing or creates new <see cref="P:Eco.Shared.View.ISubscriptions`1.Subscriptions"/> list.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscriptionsList">
            <summary>Base interface for subscriptions lists (may be thread-safe or thread-unsafe list implementation). It also may support pooling.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.UnsubscribeAll``1(``0)">
            <summary>Unsubscribe all subscriptions matching predicate.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.UnsubscribeFirst``1(``0)">
            <summary>Unsubscribes fist subscription matching <paramref name="predicate"/>.</summary>
            <returns><c>true</c> if a match was found and unsubscribed.</returns>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.RemoveSubscription(Eco.Shared.View.ISubscription)">
            <summary>Unsubscribes specific <paramref name="subscription"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.AddSubscription(Eco.Shared.View.ISubscription)">
            <summary>Adds new <paramref name="subscription"/> to <see cref="T:Eco.Shared.View.ISubscriptionsList"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.UnsubscribeAll">
            <summary>Unsubscribes all previously added subscriptions and cleans subscription collection.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISubscriptionsList.ReleaseSubscription(Eco.Shared.View.ISubscription)">
            <summary>Releases unsubscribed <paramref name="subscription"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISupportNestedSubscriptions`1">
            <summary>Interface which may be implemented for nested subscriptions support.</summary>
        </member>
        <member name="M:Eco.Shared.View.ISupportNestedSubscriptions`1.AddNestedSubscriptions">
            <summary>Makes and adds new nested subscriptions.</summary>
        </member>
        <member name="T:Eco.Shared.View.IThreadUnsafeSubscriptions">
            <summary>Thread-unsafe implementation of <see cref="T:Eco.Shared.View.ISubscriptions`1"/>. Suitable for client code where all subscriptions happens in main-thread.</summary>
            <inheritdoc />
        </member>
        <member name="T:Eco.Shared.View.NoOpPropertySubscription">
            <summary>
            No operation <see cref="T:Eco.Shared.View.PropertySubscription"/>. Will do nothing on callback.
            May be used as replacement for removed subscription during subscription list processing. I.e. we have list [sub1, sub2] and sub2 removed in sub1 callback.
            If we just remove it then list iteration will fail with <see cref="T:System.IndexOutOfRangeException"/> when accessing index 1 of removed sub2.
            To avoid this we can just replace removed subscription with <see cref="T:Eco.Shared.View.NoOpPropertySubscription"/> until list processing finish and then remove all no-op subscriptions from the list.
            </summary>
        </member>
        <member name="T:Eco.Shared.View.ObservableExtensions">
            <summary>Extension methods for <see cref="T:System.IObservable`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscription">
            <summary>Default property subscription implementation which works with provided subject, property name and callback.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscriptionBase">
            <summary>Base class for all property subscriptions.</summary>
        </member>
        <member name="T:Eco.Shared.View.ISubscribableEvent">
            <summary>Interface for subscribable events (i.e. <see cref="T:Eco.Shared.View.SubscribableEvent`1"/>). Declared as interface so all classes may work with common interface no matter which type of wrapped event.</summary>
        </member>
        <member name="T:Eco.Shared.View.SubscribableEvent`1">
            <summary>Typed <see cref="T:Eco.Shared.View.ISubscribableEvent"/>. Not thread-safe. Simple wrapper around <typeparamref name="T"/> delegate. Can be used with <see cref="T:Eco.Shared.View.EventSubscription"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscribableEvent`1.Add(`0)">
            <summary>Adds new handler for <see cref="F:Eco.Shared.View.SubscribableEvent`1.Event"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscribableEvent`1.Remove(`0)">
            <summary>Removes previously added handler from <see cref="F:Eco.Shared.View.SubscribableEvent`1.Event"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.SubscribableEventExtensions">
            <summary>"Syntax sugar" for <see cref="T:Eco.Shared.View.SubscribableEvent`1"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.Subscriptions">
            <summary>
            Simple subscriptions collection which may be used for holding subset of subscriptions for class.
            It also may be used as ISubscription to keep sub-collection of subscriptions and unsubscribed together with main collection.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.Subscriptions.Rent">
            <summary>Rents <see cref="T:Eco.Shared.View.Subscriptions"/> from the pool.</summary>
        </member>
        <member name="M:Eco.Shared.View.Subscriptions.Return(Eco.Shared.View.Subscriptions)">
            <summary>Returns rented <see cref="T:Eco.Shared.View.Subscriptions"/> back to pool.</summary>
        </member>
        <member name="T:Eco.Shared.View.SubscriptionsExtensions">
            <summary>Extension methods for <see cref="T:Eco.Shared.View.ISubscriptions`1"/>.</summary>
        </member>
        <member name="F:Eco.Shared.View.SubscriptionsExtensions.CreatePropertySubscription">
            <summary>Function which creates IPropertySubscription, for server it will create ImmutablePropertySubscription instead of PropertySubscription, because it is thread-safe</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll``1(Eco.Shared.View.ISubscriptions{``0},System.Func{Eco.Shared.View.ISubscription,System.Boolean})">
            <summary>Unsubscribe all subscriptions matching predicate.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeFirst``1(Eco.Shared.View.ISubscriptions{``0},System.Func{Eco.Shared.View.ISubscription,System.Boolean})">
            <summary>Unsubscribes fist subscription matching <paramref name="predicate"/>.</summary>
            <returns><c>true</c> if a match was found and unsubscribed.</returns>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll``2(Eco.Shared.View.ISubscriptions{``0},``1)">
            <summary>Unsubscribe all subscriptions matching predicate.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeFirst``2(Eco.Shared.View.ISubscriptions{``0},``1)">
            <summary>Unsubscribes fist subscription matching <paramref name="predicate"/>.</summary>
            <returns><c>true</c> if a match was found and unsubscribed.</returns>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.RemoveSubscription``1(Eco.Shared.View.ISubscriptions{``0},Eco.Shared.View.ISubscription)">
            <summary>Unsubscribes specific <paramref name="subscription"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll``1(Eco.Shared.View.ISubscriptions{``0},System.Boolean)">
            <summary>Unsubscribes all previously added subscriptions and cleans subscription collection.</summary>
            <param name="release">by default Subscriptions list will be just cleared and then may be reused without recreation of list, but if Subscriptions won't be used anymore they may be released and returned to pool.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAllForSubject``1(Eco.Shared.View.ISubscriptions{``0},Eco.Shared.View.IObservable)">
            <summary>
            Unsubscribe all subscriptions for given subject.
            </summary>
            <param name="ss">this ref.</param>
            <param name="subject">subject to unsubscribe.</param>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.MakeNestedSubscriptions``1(Eco.Shared.View.ISubscriptions{``0})">
            <summary>Makes nested subscriptions collection working as subset of <paramref name="ss"/>. It will be unsubscribed when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll``1(Eco.Shared.View.ISubscriptions{``0},System.Func{Eco.Shared.View.ISubscription,System.Boolean})"/> called on <paramref name="ss"/>, but may when <see cref="M:Eco.Shared.View.SubscriptionsExtensions.UnsubscribeAll``1(Eco.Shared.View.ISubscriptions{``0},System.Func{Eco.Shared.View.ISubscription,System.Boolean})"/> called on this it will only clear nested subscriptions.</summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.DestroyNestedSubscriptions``1(Eco.Shared.View.ISubscriptions{``0},``0)">
            <summary>
            Destroys nested subscriptions previously created with <see cref="M:Eco.Shared.View.SubscriptionsExtensions.MakeNestedSubscriptions``1(Eco.Shared.View.ISubscriptions{``0})"/>.
            It will unsubscribe all subscriptions in <paramref name="nested"/> and remove from <paramref name="subs"/>.
            Destroyed nested subscriptions can't be used, because they will be recycled and continue using it will lead to unpredictable behavior.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.TrySubscribe``1(Eco.Shared.View.ISubscriptions{``0},Eco.Shared.View.IPropertySubscription)">
            <summary> Tries to add <paramref name="subscription"/> to <paramref name="ss"/>. Internally it subscribes on <see cref="P:Eco.Shared.View.IPropertySubscription.Subject"/>. If subscription already was added to same property with same callback then it will return <c>false</c> and won't add subscription. </summary>
        </member>
        <member name="M:Eco.Shared.View.SubscriptionsExtensions.SubscribeWithoutTracking(Eco.Shared.View.IObservable,System.String,System.Action)">
            <summary>Creates a subscription but doesnt track it within a Subscriptions object. Should only be used when something is subscribing to its own properties,
            meaning both 'watched' and 'watcher' are a single object and die at the same time.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubscriptionFilter">
            <summary>Filter for property subscription with matching <see cref="F:Eco.Shared.View.PropertySubscriptionFilter.subject"/>, <see cref="F:Eco.Shared.View.PropertySubscriptionFilter.propertyName"/> and <see cref="F:Eco.Shared.View.PropertySubscriptionFilter.changedCallback"/>.</summary>
        </member>
        <member name="T:Eco.Shared.View.PropertySubjectSubscriptionFilter">
            <summary>Filter for property subscription with matching <see cref="F:Eco.Shared.View.PropertySubjectSubscriptionFilter.subject"/>.</summary>
        </member>
        <member name="F:Eco.Shared.View.View.NoOpSubscription">
            <summary> When a property callback removed during notifying the property. It will replace removed callback to avoid invoke on invalid subscription. </summary>
        </member>
        <member name="F:Eco.Shared.View.View.notifyTarget">
            <summary> Current notification target for <see cref="M:Eco.Shared.View.View.NotifyChanged(System.String)"/>. It may be used in methods like <see cref="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)"/> which modifies the callbacks collection to prevent concurrent modifications. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.HasData(Eco.Shared.View.View.ViewData)">
            <summary> Checks if view is holding <paramref name="data"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.MarkPropSubscribed(System.String)">
            <summary> Mark the prop as received, so we can verify access only occurs when its received.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.MustRequest(System.String)">
            <summary>Returns <c>true</c> if <paramref name="propertyName"/> has <see cref="F:Eco.Shared.View.SyncFlags.MustRequest"/> flag.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SubscribeToPropertyUpdatesIfRequired(System.Collections.Generic.List{Eco.Shared.View.IPropertySubscription},System.String)">
            <summary>Subscribes to <paramref name="propertyName"/> updates if it is a MustRequest property and not yet subscribed.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetOrCreatePropertySubscriptions(System.String)">
            <summary>Returns existing or creates new list of subscriptions to <paramref name="propertyName"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetSubscriptions">
            <summary>Returns all registered property subscriptions. Don't use it for notify, just for inspection!</summary>
        </member>
        <member name="M:Eco.Shared.View.View.Unsubscribe(Eco.Shared.View.IPropertySubscription)">
            <summary> Removes <paramref name="subscription"/> from <see cref="F:Eco.Shared.View.View.changedCallbacks"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.RemovePropertyCallbacksIfEmpty(System.String,System.Collections.Generic.List{Eco.Shared.View.IPropertySubscription})">
            <summary>Checks if <paramref name="propertyCallbacks"/> collection is empty for <paramref name="propertyName"/> and removes it from registered property callbacks in this case.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.NotifyAll">
            <summary> Notifies all changed callbacks for all properties. Primarily intended for debugging. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.DescribeSubscriptions(System.Text.StringBuilder,System.String)">
            <summary>Returns count of property subscriptions. Mostly for debugging purposes.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.TryGetValue``1(System.String,``0@,System.Int32)">
            <summary>Get a dynamic value by property name, querying both reflection and the list of dynamic properties sent by the server.  Returns 
            false if the property doesnt exist in either, or if referencing a list, the list index doesn't exist.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC(System.String,System.Object[])">
            <summary>Makes RPC call on the View.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC(System.String,System.Action,System.Object[])">
            <summary>Makes RPC call on the View with callback with no return value. <paramref name="response"/> callback doesn't wait while views changed with RPC synced back to the client, so you may have old View values when callback invoke. If you need to have synced values then use <see cref="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])"/> instead.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.ThrottledRPC(System.String,System.Object[])">
            <summary>Makes RPC call on the View with ensurence that it won't be sent again if server still didn't confirmed previous request. </summary> 
        </member>
        <member name="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])">
            <summary>
            Makes RPC call on the View with callback with no return value. Callback will be synced with view updates initiated by RPC. I.e. if it changes a property then that property will be synced back to the client before callback invoked.
            Should be used when RPC callback expects view changes to be synced on the client. I.e. after SetProperty you want to make some calculations based on value of that property.
            <example><code>
            view.RPC("SetDateOfBirth", () => age = DateTime.Today - view.DateOfBirth, date);
            </code></example>
            When non-synced <c>RPC</c> used there no guarantee that DateOfBirth will have new value just set with RPC, because it synced asynchronously to RPC. It may still have old value (actually in most cases it will have previous value).
            </summary>
        </member>
        <member name="M:Eco.Shared.View.View.RPC``1(System.String,System.Action{``0},System.Object[])">
            <summary>Makes RPC call on the View with callback having return value. <paramref name="response"/> callback doesn't wait while views changed with RPC synced back to the client, so you may have old View values when callback invoke. If you need to have synced values then use <see cref="M:Eco.Shared.View.View.SyncedRPC``1(System.String,System.Action{``0},System.Object[])"/> instead.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SyncedRPC``1(System.String,System.Action{``0},System.Object[])">
            <summary>
            Makes RPC call on the View with callback having return value. Callback will be synced with view updates initiated by RPC. I.e. if it changes a property then that property will be synced back to the client before callback invoked.
            See <see cref="M:Eco.Shared.View.View.SyncedRPC(System.String,System.Action,System.Object[])"/> for more details and examples.
            </summary>
        </member>
        <member name="M:Eco.Shared.View.View.ManualRPC``1(System.String,System.Action{``0},System.Int32,System.Object[])">
            <summary>Makes RPC call on view with provided <paramref name="viewId"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.CreateViewRPCPayload(System.Object[])">
            <summary>Creates ViewRPC payload from <paramref name="args"/> to be provided for ViewRPC call. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.ViewData.TryGetDynamicValue(System.String,System.Object@)">
            <summary>Get a dynamic value matching the given name, returning false if the property isnt found.</summary>
        </member>
        <member name="M:Eco.Shared.View.View.IsAvailable(System.String)">
            <summary>Check if a property is available (that is, if it needs requesting it has been received).</summary>
        </member>
        <member name="M:Eco.Shared.View.View.IsAvailable(Eco.Shared.View.ViewMemberInfo)">
            <summary>Check if a property is available (that is, if it needs requesting it has been received).</summary>
        </member>
        <member name="M:Eco.Shared.View.View.SetFieldViewData``1(``0@,Eco.Shared.View.View)">
            <summary> Sets <paramref name="field"/>'s <see cref="T:Eco.Shared.View.View.ViewData"/> from <paramref name="view"/>. We need this method because of accessibility restrictions. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Exposes access to <see cref="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)"/> from <see cref="T:Eco.Shared.View.View"/> derived classes. </summary>
        </member>
        <member name="M:Eco.Shared.View.View.Recover">
            <summary>
            Recovers <see cref="T:Eco.Shared.View.View"/> from <see cref="F:Eco.Shared.View.View.Data"/>.
            When original <see cref="T:Eco.Shared.View.View"/> was destroyed, but then a reference to it received from the server then it may need to perform some logic to correctly restore <see cref="T:Eco.Shared.View.View"/> from backup <see cref="F:Eco.Shared.View.View.Data"/>.
            </summary>
        </member>
        <member name="P:Eco.Shared.View.View.DebugName">
            <summary> Returns View name which may be used for debugging. </summary>
        </member>
        <member name="T:Eco.Shared.View.View.MustRequestPropertySubscription">
            <summary>Helper Property Subscription class for MustRequest properties. It always first in the list of such property subscriptions. And once invoked it marks property as received and auto-removes from subscriptions list.</summary>
        </member>
        <member name="T:Eco.Shared.View.ViewClassInfo">
            <summary>Represents the 'type' data about a server type, something which is also represented as a view. The server builds these
            viewclassinfos and sends them to the client, which can then use them for many purposes.  Any information about a type can be transmitted
            from server to client on this class.</summary>
        </member>
        <member name="F:Eco.Shared.View.ViewClassInfo.Name">
            <summary>Name of the client side type (IE: "UserView")</summary>
        </member>
        <member name="F:Eco.Shared.View.ViewClassInfo.ServerName">
            <summary>Name of the server side type (IE: "User")</summary>
        </member>
        <member name="F:Eco.Shared.View.ViewClassInfo.Members">
            <summary>Data about each member of this type, transmitted from server to client.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewClassInfo.SelfAndParentTypes">
            <summary>Returns the viewclassinfo of ourself and each parent</summary>
        </member>
        <member name="T:Eco.Shared.View.ViewMemberInfo">
            <summary>Contains data about an individual member (property or method) that is accessible on the server from the client.
            Its analgous to a MemberInfo reflection class, it communicates to the client the type data on properties of a ViewClassInfo.</summary>
        </member>
        <member name="T:Eco.Shared.View.ViewManager">
            <summary> Manages Views on client. Read more details about View System in ViewSystem.md. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.DerivedTypesRecursive(System.Int32,System.Boolean)">
            <summary>Returns all the derived types for the given type id.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.DerivedTypesRecursiveHelper(System.Int32,System.Boolean)">
            <summary>Helper is needed to prevent repeats (calling Distinct after it) because there can be multiple routes to a derived
            class when an interface is queried, like IProposable.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.UnpackageViewInternal(Eco.Shared.Serialization.BSONValue)">
            <summary>Unpackaged <see cref="T:Eco.Shared.View.View"/> from BSON with value type <see cref="F:Eco.Shared.Serialization.BSONValueType.View"/> or <see cref="F:Eco.Shared.Serialization.BSONValueType.ViewRef"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetOrRecoverView(Eco.Shared.View.View.ViewData)">
            <summary> Gets or recover <see cref="T:Eco.Shared.View.View"/> for <see cref="T:Eco.Shared.View.View.ViewData"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetView(System.Int32)">
            <summary>Returns the view with the given ID if we have it, otherwise null.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TryGetView(System.Int32,Eco.Shared.View.View@)">
            <summary>Try get <see cref="T:Eco.Shared.View.View"/> by id. It may not return view if it wasn't received or already released (has no active ref).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.GetOrCreateView(Eco.Shared.Serialization.BSONObject)">
            <summary>Get or create <see cref="T:Eco.Shared.View.View"/> from <paramref name="bson"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CreateAndRegisterView(Eco.Shared.View.View.ViewData)">
            <summary>Adds view for <paramref name="viewData"/>.</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectViewStats">
            <summary> Collect stats about existing views in <see cref="T:Eco.Shared.View.ViewManager"/>. May be used for statistic and leaks detection. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.CollectInvalidSubscriptions">
            <summary>Collects all invalid subscriptions. Invalid subscription is a <see cref="T:Eco.Shared.View.IPropertySubscription"/> which has <c>null</c> or destroyed target for an instance method (it is always <c>null</c> for static methods).</summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)">
            <summary> Traces existing views for references to view with specified <paramref name="viewId"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.SampleViewTraces(System.String,System.Int32,System.Int32)">
            <summary> Returns <see cref="T:Eco.Shared.Text.InfoBuilder"/> with traces for <paramref name="n"/> views of <paramref name="viewType"/> type (see <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>). Optionally it can skip firt <paramref name="skipN"/> elements. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData)">
            <summary> Traces existing views for references to <paramref name="targetData"/>. It helps to debug why some view was added to the client and why it wasn't GC. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.TraceViewRefs(Eco.Shared.View.View.ViewData,System.Text.StringBuilder,System.Collections.Generic.HashSet{Eco.Shared.View.View.ViewData})">
            <summary> Internal recursive implementation of <see cref="M:Eco.Shared.View.ViewManager.TraceViewRefs(System.Int32)"/>. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.IsReferencingViewData(System.Object,Eco.Shared.View.View.ViewData)">
            <summary> Checks if <paramref name="value"/> either is <see cref="T:Eco.Shared.View.View"/> containing <paramref name="viewData"/> or collection one of each elements is such view. </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.NotifyAllViews">
            <summary> Notifies all views about all subscribed properties changes. NOT INTENDED FOR PRODUCTION USAGE. ONLY FOR DEBUGGING! </summary>
        </member>
        <member name="M:Eco.Shared.View.ViewManager.ViewNotify(Eco.Shared.Serialization.BSONObject,Eco.Shared.View.View,System.Collections.Generic.List{Eco.Shared.View.ViewManager.ViewNotification})">
            <summary> Updates view property and adds property change notification to notifications list (if not null). </summary>
        </member>
        <member name="T:Eco.Shared.View.ApplyOnViewAttribute">
            <summary> Tag interfaces with this to make them add themselves when autogenning views. Useful for interfaces that are shared among server/client in shared code. </summary>
        </member>
        <member name="T:Eco.Shared.View.WeakPropertySubscription">
            <summary>// Weak reference wrapper class for delegate storage without user defined removal.</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.BlockID">
            <summary>
            Standard block IDs. These shared between client and server and should be read-only to be compatible with Burst.
            Client uses these block IDs as default for fully enclosed chunks or for missing chunks.
            </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.IChunkContainer`1.CollectColumn(Eco.Shared.Math.Vector2i,System.Int32,System.Collections.Generic.Queue{`0})">
            <summary>Collects all chunks in <paramref name="column"/> bounded by <paramref name="maxY"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.ChunkGrid`1.GetChunkColumn(Eco.Shared.Math.Vector2i)">
            <summary>Returns all non-empty chunks in chunk <paramref name="column"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.ChunkGrid`1.CollectChunks(Eco.Shared.Math.WorldRange,System.Collections.Generic.Queue{`0},Eco.Shared.Math.WorldRange)">
            <summary>Collects all chunks in the <paramref name="range"/>.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.ChunkGrid`1.GetChunks(System.Collections.Generic.IEnumerable{Eco.Shared.Math.WorldRange})">
            <summary>Gets all chunks in <paramref name="ranges"/> (unwrapped).</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.HashChunkContainer`1">
             <summary>
             This is an alternative class to the OctreeChunkContainer, rather than storing chunks in a tree we store them in a hash table. 
             This will use slightly more memory, but gives a faster speed lookup for single chunks, and similar speed for ranges.
            
             Note: In order to get chunk level locking, rather than lock the whole container during each update, the Count may not always be correct and should only be treaded as a guide.
             e.g. Don't use Count to create a new array, create a List instead, that way if count is wrong it wont matter as the list will auto expand itself.
             </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.HashChunkContainer`1.CollectColumn(Eco.Shared.Math.Vector2i,System.Int32,System.Collections.Generic.Queue{`0})">
            <summary>Returns all non-empty chunks in the column. Starts from 0 to <paramref name="maxY"/> (exclusive).</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.HashChunkContainer`1.CollectRange(Eco.Shared.Math.WorldRange,System.Collections.Generic.Queue{`0})">
            <summary> Gets chunks at given range to the buffer, this excludes chunks at <see cref="F:Eco.Shared.Math.WorldRange.max"/>. </summary>
            <param name="worldRange">The range to get the chunks from.</param>
            <param name="buffer">The buffer to load the resulting chunks collection to.</param>
            <returns>The count of added chunks.</returns>
        </member>
        <member name="T:Eco.Shared.Voxel.IChunkGrid">
            <summary>Interface for all Chunk Grid implementations (both on server side and client-side). Chunk Grid is 3D grid of <see cref="T:Eco.Shared.Voxel.IChunk"/> objects.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.IChunkGrid.Clear(System.Guid)">
            <summary>Removes all chunks from grid.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.ChunkGridExtensions.Clear(Eco.Shared.Voxel.IChunkGrid)">
            <summary>Shortcut for <see cref="M:Eco.Shared.Voxel.IChunkGrid.Clear(System.Guid)"/> with new <see cref="T:System.Guid"/> generated.</summary>
            <param name="chunkGrid"></param>
        </member>
        <member name="T:Eco.Shared.Voxel.Octree`1">
            <summary>
            Implements a cubic Octree.
            </summary>
            <remarks>
            An octree implemented over cubes indexed by integer values.  The tree will automatically grow to accommodate
            any added entries.  Optionally thread-safe.  Where ranges are used, they are interpreted as [min,max).
            </remarks>
            <typeparam name="T">The type of data to store in the tree.</typeparam>
        </member>
        <member name="M:Eco.Shared.Voxel.OctreeNode`1.Set(Eco.Shared.Math.Vector3i,`0)">
            <summary>
            Set the value at the specified position.
            </summary>
            <returns>True if a new value was added, false if a value was replaced.</returns>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotPos.RawXY">
            <summary>Convert the plot pos to a regular Vector2i, without doing any kind of coordinate transformation from plot space to world space.</summary>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotPos.RawX_Z">
            <summary>Convert the plot pos to a regular Vector3i, with y=0, without doing any kind of coordinate transformation from plot space to world space.</summary>
        </member>
        <member name="T:Eco.Shared.Voxel.PlotUtil">
            <summary> Functions for translating to/from property plot coordinates. </summary>
        </member>
        <member name="P:Eco.Shared.Voxel.PlotUtil.WorldPlotDims">
            <summary> Returns many plots exist in the x and z dimensions of the world. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.ToPlotPos(Eco.Shared.Math.Vector3i)">
            <summary>Converts a position in world space to a position in plot space. Performs the wrap. Ignores 'y' value.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.ToPlotPos(Eco.Shared.Math.Vector2i)">
            <summary>Converts a position in world space to a position in plot space. Performs the wrap.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.RawPlotPos(Eco.Shared.Math.Vector2i)">
            <summary>Converts a Vector2i to a plotpos structure, with no coordinate transformation at all.  Careful with this one.  Asserts its pre-wrapped.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.RawPlotPosWrap(Eco.Shared.Math.Vector2i)">
            <summary>Converts the raw value of a vector2i already in plot space to a plot pos, wrapping in the process. Needed to work with things that
            iterate on vector2is past world bounds, like WorldRange.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.PlotUtil.IntersectingPlotsExc(Eco.Shared.Math.WorldRange)">
            <summary> Get the list of Plot Positions for each plot that this range intersects. </summary>
        </member>
        <member name="T:Eco.Shared.Voxel.World">
            <summary>
            Wrapper class around the static voxel grid that represents the world.
            Essentially this class exists so its easier to do WorldCache.SomeMethod() instead of WorldCache.Obj.SomeMethod().
            Gets ChunkViews from the ChunkGrid.
            Gets Blocks from Chunks from the ChunkGrid.
            </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkPosition(Eco.Shared.Math.WrappedPosition3i)">
            <summary> Converts <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> to chunk position. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkRange(Eco.Shared.Math.WorldRange)">
            <summary> Converts <paramref name="worldRange"/> to chunk range. Works with negative min/max positions. </summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkSpace(System.Single)">
            <summary>Converts <paramref name="value"/> to chunk space. It divides value by chunk size and floors result (i.e. -1 will be -1 in chunk space, but 1 will be 0).</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkSpace(System.Int32)">
            <summary>Converts <paramref name="value"/> to chunk space. It divides value by chunk size and floors result (i.e. -1 will be -1 in chunk space, but 1 will be 0).</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkSpace(System.Numerics.Vector3)">
            <summary>Converts world space position to chunk space. Unlike <see cref="M:Eco.Shared.Voxel.World.ToChunkPosition(Eco.Shared.Math.WrappedPosition3i)"/> works with unwrapped positions and returns unwrapped chunk position.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToChunkSpace(Eco.Shared.Math.Vector3i)">
            <summary>Converts world space position to chunk space. Unlike <see cref="M:Eco.Shared.Voxel.World.ToChunkPosition(Eco.Shared.Math.WrappedPosition3i)"/> works with unwrapped positions and returns unwrapped chunk position.</summary>
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.Vector3i)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(System.Int32,System.Int32,System.Int32)">
            Warning: The coordinates are modulus/wrapping based on the chunk size, not relative to the chunk origin 
        </member>
        <member name="M:Eco.Shared.Voxel.World.ToLocalPosition(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Returns local block position within chunk space. All chunks should be aligned to <see cref="F:Eco.Shared.Voxel.Chunk.Size"/>. Using <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i"/> let us skip some check and use most optimized algorithm. </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStream">
             <summary>
             MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
             buffers.
             </summary>
             <remarks>
             This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
             objects to callers, while avoiding these specific problems:
             1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
             2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
             leads to continual memory growth as each stream approaches the maximum allowed size.
             3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
             This implementation only copies the bytes when GetBuffer is called.
             4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
             can be easily reused.
            
             The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
             additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
             object itself.
            
             The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single
             contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks
             are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,
             split by size--they are multiples of a chunk size (1 MB by default).
            
             Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the
             large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers
             are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
            
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.blocks">
            <summary>
            All of these blocks must be the same size.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.byteBuffer">
            <summary>
            This buffer exists so that WriteByte can forward all of its calls to Write
            without creating a new byte[] buffer on every call.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.dirtyBuffers">
            <summary>
            This list is used to store buffers once they're replaced by something larger.
            This is for the cases where you have users of this class that may hold onto the buffers longer
            than they should and you want to prevent race conditions which could corrupt the data.
            </summary>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStream.largeBuffer">
            <summary>
            This is only set by GetBuffer() if the necessary buffer is larger than a single block size, or on
            construction if the caller immediately requests a single large buffer.
            </summary>
            <remarks>If this field is non-null, it contains the concatenation of the bytes found in the individual
            blocks. Once it is created, this (or a larger) largeBuffer will be used for the life of the stream.
            </remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Id">
            <summary>
            Unique identifier for this stream across it's entire lifetime.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Tag">
            <summary>
            A temporary identifier for the current usage of this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.MemoryManager">
            <summary>
            Gets the memory manager being used by this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.AllocationStack">
            <summary>
            Callstack of the constructor. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.DisposeStack">
            <summary>
            Callstack of the Dispose call. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.#ctor(Microsoft.IO.RecyclableMemoryStreamManager,System.String,System.Int32,System.Byte[])">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager.</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes.</param>
            <param name="requestedSize">The initial requested size to prevent future allocations.</param>
            <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Dispose(System.Boolean)">
            <summary>
            Returns the memory used by this stream back to the pool.
            </summary>
            <param name="disposing">Whether we're disposing (true), or being called by the finalizer (false).</param>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Close">
            <summary>
            Equivalent to Dispose.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Capacity">
            <summary>
            Gets or sets the capacity.
            </summary>
            <remarks>Capacity is always in multiples of the memory manager's block size, unless
            the large buffer is in use.  Capacity never decreases during a stream's lifetime.
            Explicitly setting the capacity to a lower value than the current value will have no effect.
            This is because the buffers are all pooled by chunks and there's little reason to
            allow stream truncation.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Length">
            <summary>
            Gets the number of bytes written to this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.Position">
            <summary>
            Gets the current position in the stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanRead">
            <summary>
            Whether the stream can currently read.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanSeek">
            <summary>
            Whether the stream can currently seek.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanTimeout">
            <summary>
            Always false.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStream.CanWrite">
            <summary>
            Whether the stream can currently write.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.GetBuffer">
            <summary>
            Returns a single buffer containing the contents of the stream.
            The buffer may be longer than the stream length.
            </summary>
            <returns>A byte[] buffer.</returns>
            <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
            until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToArray">
            <summary>
            Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to
            access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
            for the sake of completeness.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the current position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeRead(System.Byte[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads from the specified position into the provided buffer.
            </summary>
            <param name="buffer">Destination buffer.</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="streamPosition">Position in the stream to start reading from.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream.
            </summary>
            <param name="buffer">Source buffer.</param>
            <param name="offset">Start position.</param>
            <param name="count">Number of bytes to write.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ToString">
            <summary>
            Returns a useful string for debugging. This should not normally be called in actual production code.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write.</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReadByte">
            <summary>
            Reads a single byte from the current position in the stream.
            </summary>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SafeReadByte(System.Int32@)">
            <summary>
            Reads a single byte from the specified position in the stream.
            </summary>
            <param name="streamPosition">The position in the stream to read from.</param>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">value is negative or larger than MaxStreamLength.</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position to the offset from the seek location.
            </summary>
            <param name="offset">How many bytes to move.</param>
            <param name="loc">From where.</param>
            <returns>The new position.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is larger than MaxStreamLength.</exception>
            <exception cref="T:System.ArgumentException">Invalid seek origin.</exception>
            <exception cref="T:System.IO.IOException">Attempt to set negative position.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Synchronously writes this stream's bytes to the parameter stream.
            </summary>
            <param name="stream">Destination stream.</param>
            <remarks>Important: This does a synchronous write, which may not be desired in some situations.</remarks>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStream.ReleaseLargeBuffer">
            <summary>
            Release the large buffer (either stores it for eventual release or returns it immediately).
            </summary>
        </member>
        <member name="T:Microsoft.IO.RecyclableMemoryStreamManager">
             <summary>
             Manages pools of RecyclableMemoryStream objects.
             </summary>
             <remarks>
             There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
             as they write more data.
            
             For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
             multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
             usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
             </remarks>
        </member>
        <member name="F:Microsoft.IO.RecyclableMemoryStreamManager.largePools">
            <summary>
            pools[0] = 1x largeBufferMultiple buffers
            pools[1] = 2x largeBufferMultiple buffers
            etc., up to maximumBufferSize.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor">
            <summary>
            Initializes the memory manager with the default block/buffer specifications.
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the memory manager with the given block requiredSize.
            </summary>
            <param name="blockSize">Size of each block that is pooled. Must be > 0.</param>
            <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
            <param name="maximumBufferSize">Buffers larger than this are not pooled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
            <exception cref="T:System.ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple.</exception>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.BlockSize">
            <summary>
            The size of each block. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBufferMultiple">
            <summary>
            All buffers are multiples of this number. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumBufferSize">
            <summary>
            Gets or sets the maximum buffer size.
            </summary>
            <remarks>Any buffer that is returned to the pool that is larger than this will be
            discarded and garbage collected.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolFreeSize">
            <summary>
            Number of bytes in small pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallPoolInUseSize">
            <summary>
            Number of bytes currently in use by stream from the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolFreeSize">
            <summary>
            Number of bytes in large pool not currently in use.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargePoolInUseSize">
            <summary>
            Number of bytes currently in use by streams from the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.SmallBlocksFree">
            <summary>
            How many blocks are in the small pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.LargeBuffersFree">
            <summary>
            How many buffers are in the large pool.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeSmallPoolBytes">
            <summary>
            How many bytes of small free blocks to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumFreeLargePoolBytes">
            <summary>
            How many bytes of large free buffers to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.MaximumStreamCapacity">
            <summary>
            Maximum stream capacity in bytes. Attempts to set a larger capacity will
            result in an exception.
            </summary>
            <remarks>A value of 0 indicates no limit.</remarks>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.GenerateCallStacks">
            <summary>
            Whether to save callstacks for stream allocations. This can help in debugging.
            It should NEVER be turned on generally in production.
            </summary>
        </member>
        <member name="P:Microsoft.IO.RecyclableMemoryStreamManager.AggressiveBufferReturn">
            <summary>
            Whether dirty buffers can be immediately returned to the buffer pool. E.g. when GetBuffer() is called on
            a stream and creates a single large buffer, if this setting is enabled, the other blocks will be returned
            to the buffer pool immediately.
            Note when enabling this setting that the user is responsible for ensuring that any buffer previously
            retrieved from a stream which is subsequently modified is not used after modification (as it may no longer
            be valid).
            </summary>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetBlock">
            <summary>
            Removes and returns a single block from the pool.
            </summary>
            <returns>A byte[] array.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetLargeBuffer(System.Int32,System.String)">
            <summary>
            Returns a buffer of arbitrary size from the large buffer pool. This buffer
            will be at least the requiredSize and always be a multiple of largeBufferMultiple.
            </summary>
            <param name="requiredSize">The minimum length of the buffer.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <returns>A buffer of at least the required size.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnLargeBuffer(System.Byte[],System.String)">
            <summary>
            Returns the buffer to the large pool.
            </summary>
            <param name="buffer">The buffer to return.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool).</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.ReturnBlocks(System.Collections.Generic.ICollection{System.Byte[]},System.String)">
            <summary>
            Returns the blocks to the pool.
            </summary>
            <param name="blocks">Collection of blocks to return to the pool.</param>
            <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">blocks is null.</exception>
            <exception cref="T:System.ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager.</exception>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream">
            <summary>
            Retrieve a new MemoryStream object with no tag and a default initial capacity.
            </summary>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and a default initial capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32,System.Boolean)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
            a single contiguous underlying buffer.
            </summary>
            <remarks>Retrieving a MemoryStream which provides a single contiguous buffer can be useful in situations
            where the initial size is known and it is desirable to avoid copying data between the smaller underlying
            buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
            on the underlying stream.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:Microsoft.IO.RecyclableMemoryStreamManager.GetStream(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
            buffer. The provided buffer is not wrapped or used after construction.
            </summary>
            <remarks>The new stream's position is set to the beginning of the stream when returned.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="buffer">The byte buffer to copy data from.</param>
            <param name="offset">The offset from the start of the buffer to copy from.</param>
            <param name="count">The number of bytes to copy from the buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
    </members>
</doc>
