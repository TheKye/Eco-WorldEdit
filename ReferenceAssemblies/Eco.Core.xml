<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eco.Core</name>
    </assembly>
    <members>
        <member name="M:Eco.Core.AWS.S3Storage.DeleteAsync(Amazon.S3.IAmazonS3,System.String,System.String)">
            <summary>
            Deletes all the files in this directory as well as this directory.  If recursive is set to true then all sub directories will be
            deleted as well.
            </summary>
        </member>
        <member name="T:Eco.Core.AWS.S3StoragePlugin">
            <summary><see cref="T:Eco.Core.Plugins.Interfaces.IFileStoragePlugin"/> implementation to allow Eco server access to an S3 bucket for backup retention on SLG services.</summary>
            <seealso cref="T:Eco.Core.Plugins.Interfaces.IFileStoragePlugin"/>
        </member>
        <member name="M:Eco.Core.Backup.BackupPlugin.GetBackupStoragesAsync(System.String)">
            <summary>Returns all backup storages ordered by chronological order.</summary>
        </member>
        <member name="M:Eco.Core.Backup.BackupPlugin.RestoreMostRecentBackupAsync(System.String,System.Func{System.String,System.Boolean})">
            <summary>Restores most recent backup for <paramref name="gameName"/>. It starts with head backup and then continues with every backup in reverse chronological
            order using <paramref name="checkBackup"/> for backup validation. If the check function not provided then just returns first backup.
            It copies backup to Storage directory before each call to the check function.</summary>
        </member>
        <member name="M:Eco.Core.Backup.BackupPlugin.ShutdownAsync">
            <summary>
            Need to make head backup just before server shutdown, it will guarantee we will be able to start from the same place.
            </summary>
        </member>
        <member name="M:Eco.Core.Backup.BackupPlugin.Run">
            <summary>
            Starts backups, we don't want to do make it in constructor or Initialize section because in case of long start-up we don't want to have backups during this phase.
            </summary>
        </member>
        <member name="T:Eco.Core.Collections.UniquePriorityQueue`2">
            <summary> Thread-unsafe Unique Priority Queue implementation. It only allows to put non-null unique elements. </summary>
        </member>
        <member name="M:Eco.Core.Collections.UniquePriorityQueue`2.EnqueueUnique(`0,`1)">
            <summary> Enqueues new item with given priority. Item ignored if already present in queue and method returns false in this case. </summary>
        </member>
        <member name="M:Eco.Core.Collections.UniquePriorityQueue`2.TryDequeue(`0@,`1@)">
            <summary> Tries to dequeue item from the queue (if any). Returns <c>true</c> and item with it's priority as output parameters. <c>false</c> otherwise. </summary>
        </member>
        <member name="M:Eco.Core.Collections.UniquePriorityQueue`2.Clear">
            <summary> Clears whole queue. </summary>
        </member>
        <member name="T:Eco.Core.Controller.AutoGenClassBuilder">
            <summary> Helper class for <see cref="T:Eco.Core.Controller.ViewCodeGenerator"/> which responsible for building View class code. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.BeginDataClass">
            <summary> Begins backing Data class generation. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.EndDataClass">
            <summary> Ends backing Data class generation. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.BeginClass">
            <summary> Begins View class generation. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.BeginPropertiesSection">
            <summary> Begins properties section. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.BeginMethodPropertiesSection">
            <summary> Begins properties section which generated from methods. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.BeginRPCSection">
            <summary> Begins RPC section. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.AppendProperty(System.Type,System.String,System.String,Eco.Shared.View.SyncFlags,System.String)">
            <summary> Appends code for property. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.AppendRPC(Eco.Shared.Networking.RPCMethod)">
            <summary> Appends code for RPC. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.EndClass">
            <summary> Finishes class generation and adds class prolog. </summary>
        </member>
        <member name="M:Eco.Core.Controller.AutoGenClassBuilder.AppendRecoveryMethod">
            <summary> Appends Recovery method if any recovery property assignments was added. </summary>
        </member>
        <member name="M:Eco.Core.Controller.CoreAttributeExtensions.IsPropSyncToView(Eco.Core.Controller.IController,System.String)">
            <summary>See if a given property name on this type will be getting updates from controller system</summary>
        </member>
        <member name="T:Eco.Core.Controller.ViewClassAttribute">
            <summary>Flags on view classes.</summary>
        </member>
        <member name="T:Eco.Core.Controller.AutogenClassAttribute">
            <summary> A class that has its view autogennerated.  Applying this attribute will prevent it from generating a view class in the view autogen file.</summary>
        </member>
        <member name="T:Eco.Core.Controller.HasIconAttribute">
            <summary> This class has an icon to represent it on the client. </summary>
        </member>
        <member name="T:Eco.Core.Controller.HasStaticIconAttribute">
            <summary>Set this when theres a custom icon name built from a static call. Function should take a type and return a string.</summary>
        </member>
        <member name="T:Eco.Core.Controller.NoIconAttribute">
            <summary> If a parent has HasIcon and we want to override and block that, apply this tag. </summary>
        </member>
        <member name="T:Eco.Core.Controller.DerivedMustDefineIcon">
            <summary> THis attribute requires all children to have a [HasIcon] or [NoIcon]. Implement check on Initialization of a class it is applied to. </summary>
        </member>
        <member name="T:Eco.Core.Controller.CreateComponentTabLoc">
            <summary>For WorldObjectComponents, ensures that a tab is created in the UI for it. The client looks for a property named ComponentTabName to determine the name. If not available then it will use class DisplayName. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ForceCreateViewAttribute">
            <summary> Tag for the view system to create a view even if there are no synctoview properties in the class.</summary>
        </member>
        <member name="T:Eco.Core.Controller.ForceCreateViewAllDerivedAttribute">
            <summary> Tag for the view system to create a view even if there are no synctoview properties in the class, affects all derived classes too. </summary>
        </member>
        <member name="T:Eco.Core.Controller.NegatedNameAttribute">
            <summary> For boolean properties that serve as context, this will be the negated name that we also add to context (so the bool 'Bought' can have a negated context name 'Sold' that is shown to the player).
            Note: if you want a dynamic name for the tab, create a property named ComponentTabName in the class and make it synctoview.
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.ViewMemberAttribute">
            <summary>
            Flags on members of synced classes that can inform the client about how the member can be displayed and used.
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.ViewSelectorAttribute">
            <summary> Additional set of flags since <see cref="T:Eco.Core.Controller.ViewMemberAttribute"/> doesn't have much free space. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ShowFullObjectAttribute">
            <summary> Apply this when you want to not display the reference selector, and just show the contents itself. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ClientInterfacePropertyAttribute">
            <summary> Specially tag interface members that should be created on the client. We cant mark them
            synctoview because the view system doesn't handle inherited properties well.</summary>
        </member>
        <member name="T:Eco.Core.Controller.DontCloneAttribute">
            <summary> Tag properties that should not be cloned. </summary>
        </member>
        <member name="T:Eco.Core.Controller.UITypeNameAttribute">
            <summary> Override the UI that is used to autogenerate this view. </summary>
        </member>
        <member name="T:Eco.Core.Controller.UIListTypeNameAttribute">
            <summary> Override the UI that is used to autogenerate the list that contains this view. </summary>
        </member>
        <member name="T:Eco.Core.Controller.DynamicTitleAttribute">
            <summary> Override the UI that is used to autogenerate the list that contains this view. Define a parameter that we query to get the name of this element. </summary>
        </member>
        <member name="T:Eco.Core.Controller.RequiredTagAttribute">
            <summary> Only allow selection of this parameter among things with this tag. </summary>
        </member>
        <member name="T:Eco.Core.Controller.VisibilityParamAttribute">
            <summary> Specifies the name of another property on this same object that determines the bool visbility state of this property. </summary>
        </member>
        <member name="T:Eco.Core.Controller.EnabledParamAttribute">
            <summary> Specifies the name of another property on this same object that determines if this UI should be enabled or not.
            If the property using this is a list, its expcted the property pointed to is also a list.</summary>
        </member>
        <member name="T:Eco.Core.Controller.AutogenAttribute">
            <summary> Can pass in the name of the UI that will be used on the client, if you want to override the default.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ViewCodeGenerator.ProcessSharedTypes(Eco.Core.Controller.Generators.AotCodeGen)">
            <summary>Processes shared types (available both on server and client).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ViewCodeGenerator.GenerateViewProperties(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{Eco.Shared.View.ViewMemberInfo},Eco.Core.Controller.ControllerMarshalerService)">
            <summary>Generates view properties for SyncToView properties and methods from <paramref name="members"/>.</summary>
        </member>
        <member name="T:Eco.Core.Controller.BlobController">
            <summary> The whole point of this class is to avoid sending same heavy data. Currently its used to avoid sending repeated strings and LocStrings that are ofter sent several times.
            Instead of sending same string again and again, it will save it as a byte[] and send just an id of that byte array. This way there are will be no need to send same data twice. </summary>
        </member>
        <member name="T:Eco.Core.Controller.BsonCachedPropertyAttribute">
            <summary>
            Should be used with property having <see cref="F:Eco.Shared.View.SyncFlags.Cached"/>, specifies which property used as a cached counterpart of the attributed property. May be set manually or will be automatically added by <c>Eco.Fody.SyncToViewCacheWeaving</c> for every property with the flag.
            Then the getter of the cached property will be used by <see cref="T:Eco.Core.Controller.SyncPropertyInfo"/> instead of the property getter.
            When added manually then user code is responsible for cached value invalidation. May be preferred over auto-weaving when cached value is immutable or class doesn't match auto-weaving conditions.
            <example><code><![CDATA[
            public class Foo
            {
                BSONCachedValue CachedItems { get; set; }
                [SyncToView(SyncFlags.Cached), BsonCachedProperty("CachedItems")] public List<Item> Items { get; }
                public Foo(IEnumerable<Item> items)
                {
                   this.Items = items.ToList();
                   this.CachedItems = BSONCachedValue.Cache(this.Items.ToBson());
                }
            }
            ]]></code></example>
            Read more details about auto-caching in `Eco.Fody/README.md`.
            </summary>
        </member>
        <member name="P:Eco.Core.Controller.BsonCachedPropertyAttribute.CachedPropertyName">
            <summary>Name of cached property which will be used instead of the property during view synchronization.</summary>
        </member>
        <member name="T:Eco.Core.Controller.CachedAttribute">
             <summary>Can be used to enable caching for property. Once evaluated the property won't be recalculated until receive PropertyChanged event. It uses Fody weaving for property body replacement generation.</summary>
             <example><code><![CDATA[
             public class Sample : INotifyPropertyChanged
             {
                public event PropertyChangedEventHadler PropertyChanaged;
             
                [Cached] public DateTime CachedDateTime => Date.Now; 
             }
             // will be transformed to
             public class Sample : INotifyPropertyChanged
             {
                public event PropertyChangedEventHadler PropertyChanaged;
                DateTime? <CachedDateTime>k_Cached;
            
                public Sample()
                {
                    PropertyChanged += Cache_OnPropertyChanged; 
                }
            
                public void Cache_OnPropertyChanged(object source, PropertyChangedEventArgs args)
                {
                    if (args.PropertyName == "CachedDateTime") this.<CachedDateTime>k_Cached = null;
                }
             
                [Cached] public DateTime CachedDateTime => this.<CachedDateTime>k_Cached ??= Date.Now; 
             }
             ]]></code></example>
        </member>
        <member name="T:Eco.Core.Controller.ControllerInstanceInfo">
            <summary>Class containing additional information about controller bounded to one or more clients.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.IsBoundedToClient(Eco.Core.Controller.IMvcNetClient)">
            <summary>Checks if controller bounded to client no matter if controller's view synced or not.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.IsSyncedToClient(Eco.Core.Controller.IMvcNetClient)">
            <summary>Checks if controller bounded to client and view synced (or in pending views). May be used to ensure that usage of controller reference is safe.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.IsFullySyncedToClient(Eco.Core.Controller.IMvcNetClient)">
            <summary>Checks if controller bounded to client and view fully synced (or in pending views) with all <see cref="F:Eco.Shared.View.SyncFlags.MustRequest"/> properties. May be used to ensure that usage of fully synced controller reference is safe.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.BindClient(Eco.Core.Controller.IMvcNetClient)">
            <summary>Binds controller to client.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.UnbindClient(Eco.Core.Controller.IMvcNetClient)">
            <summary>Unbinds controller from client.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.SetSyncedTo(Eco.Core.Controller.IMvcNetClient,Eco.Core.Controller.Internal.ControllerBoundingLevel,Eco.Core.Controller.Internal.ControllerBoundingLevel)">
            <summary>Sets controller as synced to client. The client should be bounded with <see cref="M:Eco.Core.Controller.ControllerInstanceInfo.BindClient(Eco.Core.Controller.IMvcNetClient)"/> before that.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerInstanceInfo.Cleanup">
            <summary>Unbinds all disconnected clients.</summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerInstanceInfo.BoundedClients">
            <summary>
            We have this nested class for reason of reducing allocated objects number. <see cref="T:Eco.Core.Controller.ControllerInstanceInfo"/> survives GC and ends up in Generation 2.
            Every object in Generation 2 increases time of full GC scan and it's size. With inheritance from <see cref="T:System.Collections.Generic.Dictionary`2"/> and moving state fields
            to that inherited class we replace ControllerInstanceInfo + Dictionary allocation with just Dictionary allocation because <see cref="T:Eco.Core.Controller.ControllerInstanceInfo"/>
            is a struct and is allocation free.
            A.B.: After experiments I decided to use <see cref="T:System.Collections.Generic.Dictionary`2"/> with RW lock instead of one of concurrent collection alternatives.
            We may review this solution in future versions. All write locks are short - like Bind/Unbind controller - so read operations shouldn't suffer from these.
            At same time write operations only happen from cleanup code, at binding code which already heavy enough because of encoding
            and even if fight for lock with controller notification code may wait without significant impact on total execution time.
            For cleanup code it also totally uncritical to stay in a lock.
            <see cref="T:Eco.Shared.Concurrent.ReadWriteSpinSemaphore"/> used instead of <see cref="T:System.Threading.ReaderWriterLockSlim"/> or <see cref="T:System.Threading.ReaderWriterLock"/> because
            of big overhead per single lock object which we want to avoid because we may have hundred of thousands or even millions of bounded controllers.
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.ClientNotification">
            <summary> This is used to notify several clients at same time. It saves shared value which will be converted to network packet and send to all of Related Clients via broadcasting. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerManager">
            <summary>Manages all controllers on server-side. Controllers are server objects which has view on the client. See ContorllerPacking.md for details. </summary>
            <remarks>For debugging purposes you may run build with /p:DefineConstants=LOG_VIEW_SYSTEM or you can enable it in .csproj file. In this mode it will produce ViewData-{date}.txt file with sorted view data in stable order.</remarks>
        </member>
        <member name="P:Eco.Core.Controller.ControllerManager.MarshalersBasestTypes">
            <summary> Find basest types which implements both IPropertyChanged and INotifyPropertyChanged </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeWithoutTracking(Eco.Core.Controller.IController,System.String,System.Action)">
            <summary>Creates a subscription but doesnt track it within a Subscriptions object. Should only be used when something is subscribing to its own properties,
            meaning both 'watched' and 'watcher' are a single object and die at the same time.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeController(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <summary>Subscribes to controller and registers subscription in <paramref name="subscriptions"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeControllerAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <summary>Subscribes to controller, registers subscription in <paramref name="subscriptions"/> and calls <paramref name="changedCallback"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeControllerUnique(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <summary>Subscribes to controller (unique) and registers subscription in <paramref name="subscriptions"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeControllerUniqueAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <summary>Subscribes to controller, registers subscription in <paramref name="subscriptions"/> and calls <paramref name="changedCallback"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.NotifyPropertyForClient(Eco.Core.Controller.IController,System.String,Eco.Core.Controller.IMvcNetClient)">
            <summary> Used when needed to notify property to specific client. I.e. when he requested property with attribute MustRequest. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.SubscribeController(Eco.Core.Controller.IController,System.String,System.Action,System.Boolean)">
            <summary>Subscribe on property <paramref name="propName"/> changes for the <paramref name="controller"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.TryUnbindController(Eco.Core.Controller.IController,Eco.Core.Controller.IMvcNetClient)">
            <summary>Remove the controller from the given client, and remove it from the list of bound controllers if there are no other bound clients. Return true if it was bound to the client
            and is now removed..</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.PackageChanges(Eco.Core.Controller.IController,System.String,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Core.Controller.ClientNotification},Eco.Core.Controller.IMvcNetClient[])">
            <summary>Package all changes into bson. It generates BSON->Clients since same BSON can be notifies to multiply clients.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.PackageController(Eco.Core.Controller.IController,Eco.Shared.Networking.INetClient,Eco.Core.Controller.PackageFlags)">
            <summary> You can use it when you don't carry about recollection of related views </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.RegisterPropertyChangedHandlers">
            <summary>
            Registers global PropertyChanged handler for all controller types (inherited from <see cref="T:Eco.Core.Controller.IController"/>) delegating to <see cref="M:Eco.Core.Controller.ControllerPacker.OnControllerPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)"/>.
            When any property on any controller instance changes it triggers PropertyChanged event (either explicitly by <see cref="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(System.Object,System.String)"/> or by PropertyChanged.Fody weaving which fires change via invoker for all controllers implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>).
            <see cref="M:Eco.Core.Controller.ControllerPacker.OnControllerPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)"/> will only proceed with properties which marked for client synchronization (having [SyncToView] or [Eco] attribute).
            </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.GetControllerTypeId(System.Type)">
            <summary> Returns controller type id (<see cref="F:Eco.Shared.View.ViewClassInfo.TypeID"/>) for <paramref name="type"/>. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerManager.HasViewType(System.Type)">
            <summary>Checks if corresponding View type exists for the controller.</summary>
            <remarks>Generic types can't have views themselves, so in their case this method checks if generic type definition has a view.</remarks>
        </member>
        <member name="T:Eco.Core.Controller.ConstantViewAttribute">
            <summary> By applying this attribute to a controller you are assuming that it will never change and its fine to cache at first access and directly send it any future time.
            It also will pack to the client all related views to ensure that he can refer these views. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerMarshaler">
            <summary><see cref="T:Eco.Core.Controller.ControllerMarshaler"/> helps to convert controller to client view.</summary>
            <inheritdoc cref="T:Eco.Core.Controller.IControllerMarshaler"/>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshaler.GetAllInterfaces">
            <summary>Returns own implemented interfaces (not inherited from base types).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshaler.GetOwnInterfaces">
            <summary>Returns own implemented interfaces (not inherited from base types).</summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerMarshalerService">
            <summary>
            Service for managing <see cref="T:Eco.Core.Controller.IControllerMarshaler"/> creation and providing marshaling info for <see cref="T:Eco.Core.Controller.ControllerManager"/> and <see cref="T:Eco.Core.Controller.ViewCodeGenerator"/>.
            Marshaling info then used for generating views for the client and syncing view data using <see cref="T:Eco.Core.Controller.ISyncMemberInfo"/> members.
            </summary>
            <sample>
            // controller class
            class MyObject : IController
            {
                [SyncToView] public string Name { get; set; }
            }
            // view generated for the client by info gathered by ControllerMarshalerService using ViewCodeGenerator
            class MyObjectView : View
            {
                public string Name { get; set; }
            }
            </sample>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetMarshalers">
            <summary>Returns all unique controller marshalers. Only available after <see cref="M:Eco.Core.Controller.ControllerMarshalerService.CreateMarshalers"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.TryGetSyncMemberInfo(System.Type,System.String,Eco.Core.Controller.ISyncMemberInfo@)">
            <summary>Returns <paramref name="syncPropertyInfo"/> for <paramref name="propertyName"/> (either property or sync-to-view method) of <paramref name="controllerType"/> if available.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetMarshalingTypes">
            <summary>Returns all marshaling types (which may be marshaled to client).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.CreateMarshalers">
            <summary> Calculate and cache all the data needed to manage syncing of controllers. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.PreAssignNameIDs">
            <summary>Ensures all name IDs assigned to same numbers no matter of parallel execution order.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.SortMarshalers">
            <summary>Ensures all marshalers same order no matter of execution order.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.AddBasicTypes">
            <summary>Used to create view class infos for basic types, will create as BooleanView, SingleView, StringVew, Vector3iView, etc.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.AddBasicMarshaler(System.Type,System.String)">
            <summary>Adds basic marshaler for one of standard types (like string, Boolean etc).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.EnsureMarshaler(System.Type)">
            <summary>Returns <see cref="T:Eco.Core.Controller.ControllerMarshaler"/> for the <paramref name="type"/>. That marshaler can be used to generate View and serialize to BSON.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetOrAddClassMarshalerRecursive(System.Type)">
            <summary>Get or adds <see cref="M:Eco.Core.Controller.ControllerMarshalerService.EnsureMarshaler(System.Type)"/> for <paramref name="type"/>. If the type shouldn't have own <see cref="T:Eco.Core.Controller.IControllerMarshaler"/> then it will reuse base class marshaler.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.TryGetMarshaler(System.Type,Eco.Core.Controller.IControllerMarshaler@)">
            <summary>Returns existing <see cref="T:Eco.Core.Controller.IControllerMarshaler"/> (previously created with <see cref="M:Eco.Core.Controller.ControllerMarshalerService.CreateMarshalers"/>).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.TryGetOrAddClassMarshaler(System.Type,Eco.Core.Controller.IControllerMarshaler@)">
            <summary>Same as <see cref="M:Eco.Core.Controller.ControllerMarshalerService.GetOrAddClassMarshalerRecursive(System.Type)"/>, but checks if <paramref name="type"/> is not null and is <see cref="T:Eco.Core.Controller.IController"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.WillHaveView(System.Type)">
            <summary>Checks if View should be generated for <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.AddViewMemberInfo(Eco.Core.Controller.IControllerMarshaler,System.Reflection.MemberInfo)">
            <summary>Creates <see cref="T:Eco.Shared.View.ViewMemberInfo"/> from <paramref name="memberInfo"/> and adds it to <see cref="P:Eco.Core.Controller.ControllerMarshaler.NameToProperty"/> mapping.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildProperties(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds properties info for <paramref name="marshaler"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildMethods(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds methods info for <paramref name="marshaler"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildDependencies(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds member dependencies mapping between sync member and properties which depends on it.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildRPCs(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds RPCs list for <paramref name="marshaler"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildViewClassInfo(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds <see cref="T:Eco.Shared.View.ViewClassInfo"/> for <paramref name="marshaler"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.BuildClassMarshaler(Eco.Core.Controller.ControllerMarshaler)">
            <summary>Builds internal info for <paramref name="marshaler"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetDependencies(System.Type,System.String)">
            <summary>Get dependent properties/methods, if any.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.CreateViewMemberInfo(System.Reflection.MemberInfo)">
            <summary>Creates <see cref="T:Eco.Shared.View.ViewMemberInfo"/> from <paramref name="info"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.RegisterName(System.String)">
            <summary>Add the <paramref name="name"/> (if missing) to the <see cref="F:Eco.Core.Controller.ControllerMarshalerService.MemberNameToID"/> lookup and returns mapped IDs.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetLegacyViewTypeName(System.Type)">
            <summary>Returns view type name compatible with old controller type based implementation (returning view type name if it doesn't exists on the client). Should be eventually refactored.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GetViewTypeName(System.Type)">
            <summary>Returns view type name for <paramref name="type"/> either from corresponding marshaler or auto-generated with <see cref="M:Eco.Core.Controller.ControllerMarshalerService.GenerateDefaultViewTypeName(System.Type)"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerMarshalerService.GenerateDefaultViewTypeName(System.Type)">
            <summary>Generates default view type name for <paramref name="type"/>.</summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerPacker">
            <summary>Manages all controllers on server-side. Controllers are server objects which has view on the client.</summary>
            <remarks>For debugging purposes you may run build with /p:DefineConstants=LOG_VIEW_SYSTEM or you can enable it in .csproj file. In this mode it will produce ViewData-{date}.txt file with sorted view data in stable order.</remarks>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageChangesInternal(Eco.Core.Controller.IController,System.String,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Core.Controller.ClientNotification},Eco.Core.Controller.IMvcNetClient[])">
            <summary>Package all changes into bson. It generates BSON->Clients since same BSON can be notifies to multiply clients.
            Pass specific clients if you want to restrict notification to somebody in particular. Otherwise it will create notifications for all subscribed clients to that property.
            Its Needed for optimizations reasons, so it wont notify everybody just because somebody subscribed to mustrequest property. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageIndividualChange(Eco.Core.Controller.IController,System.String,Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Core.Controller.ClientNotification},Eco.Core.Controller.IMvcNetClient[])">
            <summary> This packages properties that needs to be synced only to 1 particular client. By example if there are only 1 subscribed client. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageChange(Eco.Core.Controller.IController,System.ValueTuple{System.String,System.Boolean}[],Eco.Shared.Pools.Collections.PoolableListWrapper{Eco.Core.Controller.ClientNotification},Eco.Core.Controller.IMvcNetClient[])">
            <summary>Gets all data that needs to be sent <paramref name="members"/> list. Individual Syncing means that member must be sent per client because it's a method that accepts User\Player as first argument </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.GetDependencies(Eco.Core.Controller.IController,System.String)">
            <summary>Returns <paramref name="property"/> dependencies (properties with <see cref="T:Eco.Core.Controller.DependsOnControllerAttribute"/>).</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.GetSyncedMembers(Eco.Core.Controller.IController,System.String)">
            <summary>Returns array of synced properties (marked as Eco or SyncToView) notified by change of <paramref name="memberName"/> on <paramref name="controller"/> including dependencies.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.BuildSyncedPropertiesArray(System.Type,System.String)">
            <summary>Builds array of synced properties (marked as Eco or SyncToView) notified by change of <paramref name="memberName"/> on <paramref name="controllerType"/> including dependencies.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageValue(Eco.Shared.Serialization.BsonSerializationContext@,System.Object,System.Int32)">
            <summary> Creates a pair (NameId,Value) </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageControllerAndGetPendingViews(Eco.Core.Controller.IController,Eco.Shared.Serialization.BsonSerializationContext@,Eco.Core.Controller.PackageFlags)">
            <summary> Entry point into packing. It collects all views related to packing and sends them at once to pending views of client. It won't be called recursively. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageControllerRecursivelyAndCollectPendingViews(Eco.Core.Controller.IController,Eco.Shared.Serialization.BsonSerializationContext@,Eco.Core.Controller.PackageFlags)">
            <summary>Package up the given controller for the given client. In difference of PackageControllerInternal it may be called recursively.
            This function will:
             - Generate an ID for the controller if it doesnt exist
             - Generate a ControllerInstanceInfo and add it to the 'controllers' dictionary if it's not in there yet.
             - Bind the client to the controller, if they aren't already bound.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.IsControllerSyncedToClient(System.Int32,Eco.Core.Controller.IMvcNetClient,Eco.Core.Controller.Internal.ControllerBoundingLevel)">
            <summary> Checks if a controller with <paramref name="controllerID"/> synced to <paramref name="client"/> with <paramref name="requiredSyncLevel"/>. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.SyncController(Eco.Core.Controller.IMvcNetClient,Eco.Core.Controller.IController,Eco.Shared.Serialization.BsonSerializationContext@,Eco.Core.Controller.Internal.ControllerBoundingLevel)">
            <summary>Packages view, adds it to PendingViews and bounds controller to client. Context includes client and hashset of dependency views if needs to be collected. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.TryStartControllerSync(System.Int32,Eco.Core.Controller.IMvcNetClient,Eco.Core.Controller.Internal.ControllerBoundingLevel,Eco.Core.Controller.ControllerInstanceInfo@,Eco.Core.Controller.Internal.ControllerBoundingLevel@)">
            <summary>Try to start controller synchronization to <paramref name="mvcClient"/>. It either creates new <see cref="T:Eco.Core.Controller.ControllerInstanceInfo"/> if this client not bounded to any client or updates existing. If client already bounded then it checks if sync level satisfies <paramref name="requiredSyncLevel"/> and only starts synchronization when it below required.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackageViewWithMembers(Eco.Core.Controller.IController,Eco.Shared.Serialization.BsonSerializationContext@,Eco.Core.Controller.IControllerMarshaler,System.Boolean,System.Boolean)">
            <summary> Used when client dont yet have the controller and needs initial packing. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PackControllerForBroadcasting(System.Collections.Generic.IEnumerable{Eco.Core.Controller.IMvcNetClient},Eco.Core.Controller.IController,System.String)">
            <summary> Package a controller into Bson {id, properties} so it can be sent to all clients at once. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.OnControllerPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Used in <see cref="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalSubscribe(System.Type,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)"/> as all controllers property changes handler.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerPacker.PropertySyncs(Eco.Core.Controller.IControllerMarshaler,System.String,System.Boolean@)">
            <summary>Return true if the property is syncs to the client (marked SyncToView or Eco) </summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerPropertyNameAttribute">
            <summary>
            Attribute marking a parameter as a controller property name for static analysis (i.e. ControllerSubscribeAnalyzer). Requires controller passed as an another parameter of same method.
            By default uses previous parameter as controller, but the controller parameter may be explicitly specified with optional <see cref="P:Eco.Core.Controller.ControllerPropertyNameAttribute.ControllerParameterName"/> property.
            A property with the attribute should exists on subject and have sync attributes like [SyncToView] or [Eco]. If property isn't constant (string literal) then it should be either
            parameter reference for a parameter with <see cref="T:Eco.Core.Controller.ControllerPropertyNameAttribute"/> or should be suppressed with disable warning or SuppressMessage attribute.
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.ControllerSubscriptions">
            <summary>Holds controller subscriptions for <see cref="T:Eco.Core.Controller.ControllerManager"/>. Compatible with <see cref="T:Eco.Shared.View.IObservable"/> interface for Subscriptions System.</summary>
        </member>
        <member name="P:Eco.Core.Controller.ControllerSubscriptions.DebugName">
            <summary> Name used for debug purposes. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.SubscribeUnique(Eco.Shared.View.IPropertySubscription)">
            <summary>Adds <paramref name="newSubscription"/> if it wasn't already added. Returns <c>false</c> if existed.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.IsSubscribed(System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription},Eco.Shared.View.IPropertySubscription)">
            <summary>Checks if <paramref name="subscription"/> is in list of <paramref name="subscriptions"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.Subscribe(Eco.Shared.View.IPropertySubscription)">
            <summary>Same as <see cref="M:Eco.Core.Controller.ControllerSubscriptions.SubscribeUnique(Eco.Shared.View.IPropertySubscription)"/>, but will report fail in Debug mode if subscription isn't unique. It won't add new subscription though!</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.Unsubscribe(Eco.Shared.View.IPropertySubscription)">
            <summary>Removes previously added with <see cref="M:Eco.Core.Controller.ControllerSubscriptions.Subscribe(Eco.Shared.View.IPropertySubscription)"/> or <see cref="M:Eco.Core.Controller.ControllerSubscriptions.SubscribeUnique(Eco.Shared.View.IPropertySubscription)"/> subscription.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.Unsubscribe(System.String,System.Action)">
            <summary>Removes all subscriptions with <paramref name="callback"/> for <paramref name="propertyName"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.RemoveSubscriptions``1(System.String,``0,System.Func{``0,System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription},System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription}})">
            <summary>Unsubscribe helper. Removes subscription(s) with <paramref name="remove"/> function and cleanups mapping if it was last subscription for property.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.RemoveFromSubscriptions``1(System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription},System.String,``0,System.Func{``0,System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription},System.Collections.Immutable.ImmutableList{Eco.Shared.View.IPropertySubscription}})">
            <summary>Removes subscription(s) with <paramref name="remove"/> function and cleanups mapping if it was last subscription for property. Tries with <paramref name="subscriptions"/> first, but in case of concurrent modification will re-fetch value from <see cref="P:Eco.Core.Controller.ControllerSubscriptions.ChangedCallbacks"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.NotifyChanged(System.String)">
            <summary>Notifies all subscriptions about property change.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.HasProperty(System.String)">
            <summary>Checks if <see cref="F:Eco.Core.Controller.ControllerSubscriptions.controllerType"/> has property with specified name.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerSubscriptions.Cleanup">
            <summary>Removes all "dead" subscriptions.</summary>
        </member>
        <member name="T:Eco.Core.Controller.Generators.AotCodeGen">
            <summary>
            <see cref="T:Eco.Core.Controller.Generators.AotCodeGen"/> generates dummy calls to generic methods to ensure these methods will be available after AOT via reflection.
            AOT (ahead of time compilation) used on client side for IL2CPP build. AOT only compiles methods which may be discovered during compilation,
            but if some method only called via reflection then in runtime it won't be available and an exception will be thrown instead.
            To avoid the issue we need to hint AOT code gen with all possible generic method variants - for that we generate fake method calls
            based on <see cref="F:Eco.Core.Controller.Generators.AotCodeGen.toBsonTypes"/> and <see cref="F:Eco.Core.Controller.Generators.AotCodeGen.fromBsonTypes"/> which may be used during BSON serialization/deserialization.
            </summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.AddToBsonType(System.Type)">
            <summary>Adds type which will be used in ToBson methods (during serialization).</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.AddFromBsonType(System.Type)">
            <summary>Adds type which will be used in FromBson methods (during deserialization).</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.GetEnumerableTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>Collects all types which implements <see cref="T:System.Collections.IEnumerable"/> interface with element type (if it may be determined).</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.CollectEnumerableTypes(System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.HashSet{System.Type},System.Collections.Generic.HashSet{System.ValueTuple{System.Type,System.Type}})">
            <summary>Collects list and dictionary types to be used in <see cref="M:Eco.Core.Controller.Generators.AotCodeGen.GenerateFromBsonHelper(System.Text.StringBuilder)"/> and <see cref="M:Eco.Core.Controller.Generators.AotCodeGen.GenerateToBsonHelper(System.Text.StringBuilder,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.GenerateFromBsonHelper(System.Text.StringBuilder)">
            <summary>Generates FromBsonHelper having calls to all reflection invoked methods for AOT.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.GenerateToBsonHelper(System.Text.StringBuilder,System.Boolean)">
            <summary>Generates ToBsonHelper having calls to all reflection invoked methods for AOT.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.AotCodeGen.Generate(System.Text.StringBuilder)">
            <summary>Generates AotCodeGen content to <paramref name="template"/>.</summary>
        </member>
        <member name="T:Eco.Core.Controller.Generators.RPCMethodGenerationHelper">
            <summary><see cref="T:Eco.Shared.Networking.RPCMethod"/> generation helper for return type string and method signature.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.RPCMethodGenerationHelper.GenerateReturnType(Eco.Shared.Networking.RPCMethod,Eco.Core.Controller.ControllerMarshalerService)">
            <summary>Generates return type string for <paramref name="rpc"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.RPCMethodGenerationHelper.GenerateMethodSignature(Eco.Shared.Networking.RPCMethod,Eco.Core.Controller.ControllerMarshalerService)">
            <summary>Generates method signature for <paramref name="rpc"/>.</summary>
        </member>
        <member name="T:Eco.Core.Controller.Generators.TypeGenerationHelper">
            <summary>Helper class with utility functions for View types generation.</summary>
        </member>
        <member name="M:Eco.Core.Controller.Generators.TypeGenerationHelper.GenerateViewTypeName(System.Type,Eco.Core.Controller.ControllerMarshalerService)">
            <summary>Generates type name for view.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.WatchPropDeprecated(System.ComponentModel.INotifyPropertyChanged,System.String,System.Action{System.Object})">
            <summary>Watch for a property changing through the fody system.
            DEPRECATED. Use ChangeWatcher class.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.WatchPropDeprecated(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Watch for a property changing through the fody system, using a passed handler.
            DEPRECATED. Use ChangeWatcher class.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.UnwatchAll(System.Collections.Generic.IEnumerable{System.ComponentModel.PropertyChangedEventHandler},System.ComponentModel.INotifyPropertyChanged)">
            <summary>Unsubsribe to all event handlers on the given property notifier.</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.WatchPropertyOnAllEntries``1(System.Collections.Generic.IEnumerable{``0},Eco.Core.Utils.TrackingCallbacks,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Makes sure <paramref name="handler"/> is called whenever value of any property changes in any element of <paramref name="collection"/></summary>
            <param name="callbacks"><see cref="T:Eco.Core.Utils.TrackingCallbacks"/> for <paramref name="collection"/></param>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.WatchPropertyOnAllEntries``1(System.Collections.Generic.IEnumerable{``0},Eco.Core.Utils.TrackingCallbacks,System.String,System.Action{System.Object})">
            <summary>Makes sure <paramref name="onChange"/> is called whenever value of property with name <paramref name="propertyName"/> changes in any element of <paramref name="collection"/></summary>
            <param name="callbacks"><see cref="T:Eco.Core.Utils.TrackingCallbacks"/> for <paramref name="collection"/></param>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.ChangedSafe(Eco.Core.Controller.IController,System.String)">
            <summary>Alternative to <see cref="M:Eco.Core.Controller.ControllerExtensions.Changed(Eco.Core.Controller.IController,System.String)"/> with null check for property name. It should be removed when all places which may pass null as property name fixed,</summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SetProperty``1(Eco.Core.Controller.IController,``0@,``0,System.String)">
            <summary> Set a property if it's changed and notify it's changed. No need to set name if used in a propery. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.Subscribe(Eco.Core.Controller.IController,System.String,System.Action)">
            <summary> Relay subscription calls to the controller object. </summary>
            <remarks> Subscriptions require the Controller object exists, so try to bind them here. </remarks>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeAndCall(Eco.Core.Controller.IController,System.String,System.Action)">
            <summary> Relay subscription calls to the controller object, then call the method. </summary>
            <remarks> Subscriptions require the Controller object exists, so try to bind them here. </remarks>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeUnique(Eco.Core.Controller.IController,System.String,System.Action)">
            <summary> Relay subscription calls to the controller object, if a subscription with the same callback is not already bound. </summary>
            <remarks> Subscriptions require the Controller object exists, so try to bind them here. </remarks>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.Unsubscribe(Eco.Core.Controller.IController,System.String,System.Action)">
            <summary> Unsubscribe previously subscribed controller. Returns false if there wasn't such subscription. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.Subscribe(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <inheritdoc cref="M:Eco.Core.Controller.ControllerManager.SubscribeController(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)"/>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <inheritdoc cref="M:Eco.Core.Controller.ControllerManager.SubscribeControllerAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)"/>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeUnique(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <inheritdoc cref="M:Eco.Core.Controller.ControllerManager.SubscribeControllerUnique(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)"/>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeUniqueAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)">
            <inheritdoc cref="M:Eco.Core.Controller.ControllerManager.SubscribeControllerUniqueAndCall(Eco.Core.Controller.IController,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.String,System.Action)"/>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeAllRecursive(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Controller.IController,System.Action{System.Reflection.PropertyInfo,System.Object},System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Reflection.PropertyInfo)">
            <summary> Subscribe to ALL sync parameters, and ALL the children of those sync parameters that are also controllers. </summary>
        </member>
        <member name="M:Eco.Core.Controller.ControllerExtensions.SubscribeAllPropsRecursive(System.Collections.Generic.IEnumerable{Eco.Core.Controller.IController},Eco.Core.Utils.TrackingCallbacks,Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.Action{System.Reflection.PropertyInfo,System.Object})">
            <summary>Watch of changes of all properties marked with <see cref = "T:Eco.Shared.Networking.ScanPropAttribute" /> in the collection recursively, which can be useful for updates in complex structures with nested objects, like Election. <b>NOTE: As it subscribes for everything it's very ineffective method. Avoid if possible.</b></summary>
        </member>
        <member name="T:Eco.Core.Controller.IController">
            <summary>
            1. Needs this block to implement the interfaces
            int IHasUniversalID.ControllerID { get; set; }
            2. Add [SyncToView] to properties/methods you wish to synchronize with the view.
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.ReadOnlyControllerAttribute">
            <summary> Marks when a controller is read-only, which prevents recursive subscriptions from delving into it.</summary>
        </member>
        <member name="T:Eco.Core.Controller.DependsOnControllerAttribute">
            <summary> This attribute says that this view value depends on another's, so send that result as well
            when it changes. Note that dependencies which are not 'synctoview' will not be found.
            NOTE: There is another [DependeOn] attribute that is similar, but uses fody property change detection instead.
            That one is faster, doing it when the change occurs, while this one will queue it up for a later change call.</summary>
        </member>
        <member name="T:Eco.Core.Controller.IControllerMarshaler">
            <summary>Base interface for all controller marshalers (enums, IController classes, primitive types).</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.GetSyncMemberInfos">
            <summary>Returns all sync property infos for the marshaled type as pairs of (nameId, memberSyncInfo).</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.TryGetSyncMemberInfo(System.Int32,Eco.Core.Controller.ISyncMemberInfo@)">
            <summary>Tries to get sync info for member with <paramref name="nameId"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.TryGetDependentMembers(System.String,System.String[]@)">
            <summary>Tries to get other members which depends on <paramref name="memberName"/>.</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.GetAllInterfaces">
            <summary>Returns all interfaces implemented by class.</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.GetOwnInterfaces">
            <summary>Returns only own interfaces implemented by class (non-inherited).</summary>
        </member>
        <member name="M:Eco.Core.Controller.IControllerMarshaler.CreateInstance">
            <summary>Creates instance of controller.</summary>
        </member>
        <member name="T:Eco.Core.Controller.ImmutablePropertySubscription">
            <summary>Immutable implementation of <see cref="T:Eco.Shared.View.IPropertySubscription"/> used by controller to prevent concurrent modifications (i.e. <see cref="T:Eco.Shared.View.PropertySubscription"/> may be recycled and destroy it's state).</summary>
        </member>
        <member name="P:Eco.Core.Controller.IMvcNetClient.PendingMessages">
            <summary>Packaged messages which should be delivered to client before any other message. Used for views and data blobs.</summary>
        </member>
        <member name="T:Eco.Core.Controller.Internal.ControllerBoundingLevel">
            <summary>Level of controller bounding to client. Each next level includes all previous levels and can be used in comparison.</summary>
        </member>
        <member name="T:Eco.Core.Controller.ISyncMemberInfo">
            <summary>Interface for <see cref="T:Eco.Core.Controller.SyncToViewAttribute"/> members info. Used by <see cref="T:Eco.Core.Controller.ControllerManager"/> for serialization.</summary>
        </member>
        <member name="P:Eco.Core.Controller.ISyncMemberInfo.PerPlayerMember">
            <summary> Set to true if its a method that accepts the player, meaning a different result for each player </summary>
        </member>
        <member name="T:Eco.Core.Controller.NotifyAttribute">
            <summary>Attribute which may be used to mark a property/method as controller property which may be used in Subscribe/Changed methods. By default only properties with <see cref="N:Eco"/>, <see cref="T:Eco.Core.Controller.SyncToViewAttribute"/> and <see cref="T:Eco.Core.Controller.ClientInterfacePropertyAttribute"/> notified, but if you still need to subscribe to property without syncing to client then the attribute may be used.</summary>
        </member>
        <member name="T:Eco.Core.Controller.RelatedFeatureAttribute">
            <summary>Used to highlight that the class/member is dependant on one of the features and hide/show it from client</summary>
            <remarks>Note: Name of the feature must be the exactly the same as in Eco.Gameplay.Systems.FeatureConfig</remarks>
        </member>
        <member name="M:Eco.Core.Controller.RelatedFeatureAttribute.#ctor(System.String,System.Boolean)">
            <summary>Accepts the name of the feature and a bool if it should be required or not required.</summary>
        </member>
        <member name="M:Eco.Core.Controller.SubscriptionUtils.UpdateSubject``1(``0@,``0,System.String,System.Action)">
            <summary>
            Updates subscription subject (action emitter). It is thread-safe and ensures old subscription removed from <paramref name="subject"/> even in concurrent environment.
            It possible though that both <paramref name="newSubject"/> and <paramref name="subject"/> subscribed. it is very rare case, but you should aware of it.
            It happens if action removed from old subject, but subject changed in another thread after this, before new subject assigned (it will be removed anyway because of interlocked change, but it may exists for short period of time).
            </summary>
        </member>
        <member name="T:Eco.Core.Controller.SyncMemberInfoBase">
            <summary>Base class for <see cref="T:Eco.Core.Controller.ISyncMemberInfo"/> implementations with shared logic.</summary>
        </member>
        <member name="M:Eco.Core.Controller.SyncMemberInfoBase.GetAccessMethodInfo(System.Reflection.MethodInfo)">
            <summary>Returns <see cref="T:System.Reflection.MethodInfo"/> which may be used for getter generation. For generic type definitions it will try to use declaring type (base type or interface).</summary>
            <exception cref="T:System.ArgumentException">If this member may not be accessed via both reflected and declaring type.</exception>
        </member>
        <member name="T:Eco.Core.Controller.SyncMethodInfo">
            <summary><see cref="T:Eco.Core.Controller.ISyncMemberInfo"/> for [SyncToView] methods.</summary>
        </member>
        <member name="M:Eco.Core.Controller.SyncMethodInfo.CreateDelegate(System.Reflection.MethodInfo)">
            <summary>Creates compiled delegate for call of <paramref name="methodInfo"/> for sync-to-view value access. Works with no-arg methods and methods with single argument (for observer).</summary>
        </member>
        <member name="M:Eco.Core.Controller.SyncMethodInfo.ConvertToObserverArg(System.Linq.Expressions.Expression,System.Type)">
            <summary>Converts <paramref name="client"/> to observer arg <see cref="T:System.Linq.Expressions.Expression`1"/> for <see cref="F:Eco.Core.Controller.SyncMethodInfo.getValue"/> delegate.</summary>
        </member>
        <member name="T:Eco.Core.Controller.SyncPropertyInfo">
            <summary>Builds info about a given property that is marked SyncToView, and synced between the server an client.</summary>
        </member>
        <member name="M:Eco.Core.Controller.SyncPropertyInfo.CreateDelegate(System.Reflection.PropertyInfo)">
            <summary>Creates compiled delegate for call of <paramref name="propertyInfo"/> for sync-to-view value access. Works with no-arg methods and methods with single argument (for observer).</summary>
        </member>
        <member name="M:Eco.Core.Controller.SyncPropertyInfo.GetAccessPropertyInfo(System.Reflection.PropertyInfo)">
            <summary>Returns property info via which value may be accessed. May be different if original property info type is generic type definition.</summary>
        </member>
        <member name="T:Eco.Core.Controller.SyncToViewAttribute">
            <summary> SyncToView denotes a property or method result as a value that exists in the view on the client. </summary>
        </member>
        <member name="T:Eco.Core.Controller.ViewTypeAttribute">
            <summary>Defines View Type which should be used on client side instead of that type. Should be used when server and client side have same BSON serialization format, but different classes on server side and on the client. That type won't be generated and should be manually created on the client.</summary>
        </member>
        <member name="T:Eco.Core.DebugStatistic.Collectors.EventMetricCollector">
            <summary>Base class for all <seealso cref="T:System.Diagnostics.Tracing.EventListener"/> based <seealso cref="T:Eco.Core.DebugStatistic.Collectors.IMetricCollector"/> instances.</summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.Collectors.EventMetricCollector.listenerKeyword">
            <summary>Integer keyword value used to initialize our <seealso cref="T:System.Diagnostics.Tracing.EventListener"/> instance.</summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.Collectors.EventMetricCollector.metricPrefix">
            <summary>Represents the prefix value used to store metrics with <seealso cref="T:Eco.Core.DebugStatistic.PerformancePlugin"/>. MetricPrefix.XXXX = Value.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.EventMetricCollector.StoreMetric(System.String,System.Double)">
            <inheritdoc cref="M:Eco.Core.DebugStatistic.PerformancePlugin.StoreValueMetric(System.String,System.Double)"/>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.EventMetricCollector.GetMetric(System.String)">
            <inheritdoc cref="M:Eco.Core.DebugStatistic.PerformancePlugin.GetValueMetric(System.String)"/>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.EventMetricCollector.StoreEventData(System.Diagnostics.Tracing.EventWrittenEventArgs)">
            <summary>Stores the payload of an <seealso cref="T:System.Diagnostics.Tracing.EventWrittenEventArgs"/> object from the <seealso cref="T:System.Diagnostics.Tracing.EventListener"/> as metrics in the <seealso cref="T:Eco.Core.DebugStatistic.PerformancePlugin"/> singleton instance.</summary>
            <param name="eventData">Event payload to store as metrics.</param>
        </member>
        <member name="T:Eco.Core.DebugStatistic.Collectors.GCEventId">
            <summary>
            <para>Represents all supported GC event ids under Keyword 0x0000001.</para>
            <para>These values were taken from https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events</para>
            </summary>
        </member>
        <member name="T:Eco.Core.DebugStatistic.Collectors.GCMetricCollector">
            <summary>Implementation of <see cref="T:Eco.Core.DebugStatistic.Collectors.IMetricCollector"/> for collecting information and metrics about the .NET Garbage Collector.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.GCMetricCollector.StoreTimedEventMetric(System.String,Eco.Core.DebugStatistic.Collectors.GCEventId,Eco.Core.DebugStatistic.Collectors.GCEventId,Eco.Core.DebugStatistic.Collectors.GCEventId)">
            <summary>Updates/Stores a timed metric value based on the event being triggered.</summary>
            <param name="label">Metric label/name to modify</param>
            <param name="triggerEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> id currently being triggered.</param>
            <param name="startEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> responsible for starting the timer.</param>
            <param name="endEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> responsible for stopping the timer.</param>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.GCMetricCollector.StoreCountEventMetric(System.String,Eco.Core.DebugStatistic.Collectors.GCEventId,Eco.Core.DebugStatistic.Collectors.GCEventId,Eco.Core.DebugStatistic.Collectors.GCEventId)">
            <summary>Increments/Decrements a metric value based on the type of event being processed.</summary>
            <param name="label">Metric label/name to modify</param>
            <param name="triggerEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> id currently being triggered.</param>
            <param name="incrementEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> responsible for incrementing the metric value.</param>
            <param name="decrementEvent">The <seealso cref="T:Eco.Core.DebugStatistic.Collectors.GCEventId"/> responsible for decrementing the metric value.</param>
        </member>
        <member name="T:Eco.Core.DebugStatistic.Collectors.IMetricCollector">
            <summary>Base interface for all metric collectors used by <seealso cref="T:Eco.Core.DebugStatistic.PerformancePlugin"/>.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.IMetricCollector.Initialize">
            <summary>Performs setup/initialization operations on the metric collector instance.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.Collectors.IMetricCollector.Shutdown">
            <summary>Performs shutdown operations on the metric collector instance.</summary>
        </member>
        <member name="T:Eco.Core.DebugStatistic.PerformanceIntervalStat">
            <summary>Custom interval stat counter used by <seealso cref="T:Eco.Core.DebugStatistic.PerformancePlugin"/> for generating reports.</summary>
        </member>
        <member name="T:Eco.Core.DebugStatistic.PerformancePlugin">
            <summary>Tracks potential performance problems in the server and generates a report.  Eventually we can make these reports output from the server and track them across builds.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.SetCaptureData(System.Boolean)">
            <summary> Enable/disable performance reports data collection </summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.PerformancePlugin.IntervalTimes">
            <summary>Configured interval times used by the PerformancePlugin. These values must be multiples of each other.</summary>
        </member>
        <member name="P:Eco.Core.DebugStatistic.PerformancePlugin.CollectControllerStats">
            <summary> Flag to collect controller stats when a data is being captured or the controller stats tab is open. </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.AddMetricCollector``1">
            <summary>Registers a new metric collector with the performance plugin instance.</summary>
            <typeparam name="T"><seealso cref="T:Eco.Core.DebugStatistic.Collectors.IMetricCollector"/> type to instantiate/register</typeparam>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.HasMetricCollector(System.Type)">
            <summary></summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.RemoveMetricCollector(System.Type)">
            <summary>Removes an existing metric collector instance from the performance plugin.</summary>
            <param name="type"><seealso cref="T:Eco.Core.DebugStatistic.Collectors.IMetricCollector"/> type to remove.</param>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.StoreValueMetric(System.String,System.Double)">
            <summary>Stores a generic key/value metric for generating reports/publishing to external sources.</summary>
            <param name="name">Name of the metric to store</param>
            <param name="value">Current value of the metric.</param>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GetValueMetric(System.String)">
            <summary>Retrieves the generic key/value metric currently being stored for reports/publishing.</summary>
            <param name="name">Name of the metric to retrieve</param>
            <returns>Stored value if the metric exists. Otherwise 0.</returns>
        </member>
        <member name="F:Eco.Core.DebugStatistic.PerformancePlugin.newPerformanceIntervalStat">
            <summary>Stores an interval metric and values for use in the Controller Metrics Report.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GetMonitoredMetrics">
            <summary>Retrieves the currently stored metrics and metrics being tracked by our <seealso cref="T:Eco.Shared.Tools.PerformanceManager"/> instance for use in external metric publishing.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.Run">
            <summary>Starts our <seealso cref="T:Eco.Core.Utils.Threading.IWorker"/> instance for generating performance reports.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GenerateIntervalsReport">
            <summary>Generates a report of the currently tracked intervals for displaying on the "Controller Stats" GUI tab.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GetControllerMetricsReport">
            <summary>Returns the Controller Metrics report for displaying on the "Controller Stats" DisplayTab for the server GUI.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GetPerformanceManagerReport">
            <summary>Returns the <seealso cref="T:Eco.Shared.Tools.PerformanceManager"/> GetReport results for displaying on the "Performance Manager" DisplayTab for the server GUI.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.GetMetricsReport">
            <summary>Generates and returns the report used in the "Metrics Stats" DisplayTab for the server GUI.</summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.PerformancePlugin.ToString">
            <summary>Returns a string that represnets this object. Used by the Eco server to properly localize the plugin instance.</summary>
            <returns>Returns a string that represnets this object. </returns>
        </member>
        <member name="T:Eco.Core.DebugStatistic.RepeatedValueTracker">
            <summary>
            GlobalSubscribes to a provided list of types and analyzes notifications for these, 
            tracking repeated notifications of the same Controller member with the same value as the last notification
            <br>Use <see cref="P:Eco.Core.DebugStatistic.RepeatedValueTracker.RepeatCounts"/> to get current count of repetitions of each Type.Member</br>
            <br>Only tracks Server-Client notifications, not Server sided communications (ControllerID == 0)</br>
            </summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.RepeatedValueTracker.types">
            <summary> Types being tracked for repeated notification analysis </summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.RepeatedValueTracker.previousSent">
            <summary>ControllerID Member pair and its object from last notification </summary>
        </member>
        <member name="F:Eco.Core.DebugStatistic.RepeatedValueTracker.memberRepeatCount">
            <summary>Track number of times a ControllerID Member pair repeats notifications for the same object </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <param name="types"> Types to analyze for repeated notifications </param>
        </member>
        <member name="P:Eco.Core.DebugStatistic.RepeatedValueTracker.RepeatCounts">
            <summary> Sequence of pairs Type.Member and Number of repetitions </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.TryGetFieldOrProperty(System.Object,System.String,System.Object@,System.String@)">
            <summary>
            Get Property or Field of <paramref name="controller"/> with name <paramref name="memberName"/>.
            <br>Returns true if found a Property or Field with name <paramref name="memberName"/> in <paramref name="controller"/></br>
            <br>Outputs <paramref name="member"/> with value of found Property or Field or null if not found,
            and <paramref name="memberDescription"/> describing the type: "Type.Member"</br>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AnalyzeNewNotification(Eco.Core.Controller.IController,System.String)">
            <summary>
            Analyze new notification of <paramref name="memberName"/> of <paramref name="controller"/>
            and track if it has the same value as the last notification of the same <paramref name="memberName"/> 
            and <paramref name="controller"/>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AddNotificationValueType(System.ValueTuple{System.Int32,System.String},System.String,System.Object)">
            <summary> 
            AddNotification(...) for Value type.
            <br>Stores a copy of the value and compares with new value using Equals</br>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AddNotificationRefType(System.ValueTuple{System.Int32,System.String},System.String,System.Object)">
            <summary> 
            AddNotification(...) for reference type.
            <br>Stores a WeakReference of the value and compares with new value to old WeakReference.Target</br>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AddNotificationValueEnumerable(System.ValueTuple{System.Int32,System.String},System.String,System.Object)">
            <summary> 
            AddNotification(...) for IEnumerable of value types.
            <br>Stores a copy of the List of values and compares with new IEnumerable of values using SequenceEqual</br>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AddNotificationRefEnumerable(System.ValueTuple{System.Int32,System.String},System.String,System.Object)">
            <summary> 
            AddNotification(...) for IEnumerable of reference types.
            <br>Stores a List of WeakReferences to the values and compares with new IEnumerable of values using SequenceEqual of WeakReference.Target</br>
            </summary>
        </member>
        <member name="M:Eco.Core.DebugStatistic.RepeatedValueTracker.AddNotification(System.ValueTuple{System.Int32,System.String},System.String,System.Object,System.Func{System.Object,System.Boolean})">
            <summary> 
            Add new <paramref name="notification"/> of <paramref name="tracked"/>. 
            <br>If it's a repeated notification compare new and old <paramref name="tracked"/> object using <paramref name="equality"/></br>
            </summary>
        </member>
        <member name="T:Eco.Core.Ecopedia.EcopediaUtils">
            <summary> Ecopedia utils. </summary>
        </member>
        <member name="M:Eco.Core.Ecopedia.EcopediaUtils.GetPageName(System.Type,Eco.Core.Items.EcopediaAttribute)">
            <summary> Returns page name for <paramref name="type"/>. If this type is in a subpage, it actually returns the name of the parent page.</summary>
        </member>
        <member name="M:Eco.Core.Ecopedia.EcopediaUtils.GetPageDisplayName(System.Type,Eco.Core.Items.EcopediaAttribute)">
            <summary> Returns page display name for <paramref name="type"/>. </summary>
        </member>
        <member name="T:Eco.Core.Ecopedia.ICustomEcopediaPage">
            <summary>
            By default, ecopedia page displayed in a toolip is defined by a class itself.
            </summary>
        </member>
        <member name="T:Eco.Core.FileStorage.AbsolutePathAwareStorage">
            <summary>
            Checks if fileName is absolute path and uses file system in this case
            otherwise it uses backing file storage.
            </summary>
        </member>
        <member name="T:Eco.Core.FileStorage.FileSystemStorage">
            <summary>
            File system storage. Uses target directory as constructor argument and works with relative paths.
            </summary>
        </member>
        <member name="T:Eco.Core.Items.TagAttribute">
            <summary> Tags can be added to types or properties to allow other systems to identify them and use them if they want to.
            <para>    For example the interaction system heavily uses tags to determine what interactions are valid for the targeted object. </para>
            </summary>
            <remarks> We prefer using tags over attributes on IControllers because tags are being sent over view IDs instead of strings. </remarks>
        </member>
        <member name="F:Eco.Core.Items.TagAttribute.Unset">
            <summary>When true, then we REMOVE the tag instead of adding it.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEnumerableExtensions.MaxAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},``0)">
            <summary> Returns max value for task results. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEnumerableExtensions.ToAsyncEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary> Adapts <see cref="T:System.Collections.Generic.IEnumerable`1"/> to <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEnumerableExtensions.ToAsyncEnumerable``1(System.Threading.Tasks.Task{``0}[])">
            <summary> Makes <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> from array of <see cref="T:System.Threading.Tasks.Task"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEnumerableExtensions.ToList``1(System.Collections.Generic.IAsyncEnumerable{``0})">
            <summary> Resolves <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> to <see cref="T:System.Collections.Generic.List`1"/>. </summary>
        </member>
        <member name="T:Eco.Core.Utils.Async.AsyncEvents`1">
             <summary>
             Helper class for working with C# events as async stream of event values. It works as a bridge between event-based APIs and async/await based APIs.
             
             For example we have NAT device discovery library with <c>StartDiscovery</c>, <c>StopDiscovery</c> methods and a <c>DeviceDiscovered</c> event and then
             we need to discover an appropriate NAT device in async method. NAT Device itself has async methods which we need to use to check if the device is an appropriate.
             An application may be adapted to event based API, but in case if your existing code is already uses async/await pattern or you just prefer to use async/await code
             for better readability and less errors then you can use <see cref="T:Eco.Core.Utils.Async.AsyncEvents`1"/>.
            
             Classic approach with events may look like:
             <example><code><![CDATA[
             class NATDeviceDiscoverer
             {
                 Task<bool> discoveryInProgress;
                
                 public event Action<NATDevice> AppropriateDeviceDiscovered;
            
                 void DiscoverAppropriateDevice()
                 {
                     NATLib.DeviceDiscovered += OnDeviceDiscovered;
                     NATLib.StartDiscovery();
                 }
            
                 void OnDeviceDiscovered(object subject, NATDeviceDiscoveredArgs args)
                 {
                     var device = args.Device;
                     if (discoveryInProgress != null)
                        discoveryInProgress.ContinueWith(t => t.IsCompleted && !t.Result ? CheckDevice(device) : Task.CompletedTask); // don't need to check if already found appropriate device
                     else
                        discoveryInProgress = CheckDevice(device);
                 }
            
                 async Task<bool> CheckDevice(NATDevice device)
                 {
                     var isAppropriate = await device.Check();
                     if (!isAppropriate) return false;
                     NATLib.DeviceDiscovered -= OnDeviceDiscovered;  
                     NATLib.StopDiscovery();
                     AppropriateDeviceDiscovered.Invoke(device);
                     return isAppropriate;
                 }
             }
             ]]></code></example>
             and if you need to add a timeout it become even more complex.
            
             With <see cref="T:Eco.Core.Utils.Async.AsyncEvents`1"/> you can rewrite it much simpler:
             <example><code><![CDATA[
             class NATDeviceDiscoverer
             {
                 async Task<NATDevice> DiscoverAppropriateDevice()
                 {
                     using var discoveredDevices = AsyncEvents<NATDevice>.Subscribe<Action<NATDevice>>(discoverNext => (_, args) => discoverNext(args.Device), handler => NATLib.DeviceDiscovered += handler, handler => NATLib.DeviceDiscovered -= handler);
                     NATLib.StartDiscovery();
                     try
                     {
                         await foreach (var device in discoveredDevices)
                         {
                             if (await device.Check())
                                return device;
                         }
                     }
                     finally
                     { 
                        NATLib.StopDiscovery();
                     }
                 }
             }
             ]]></code></example>
             </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEvents`1.Subscribe``1(System.Func{System.Func{`0,System.Boolean},``0},System.Action{``0},System.Action{``0})">
            <summary>Subscribes to events of type <typeparamref name="TEventHandler"/>. <paramref name="handlerFactory"/> should create an event handler which invokes callback with an item received from event.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncEvents`1.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <summary>Returns <see cref="T:System.Collections.Generic.IAsyncEnumerator`1"/> which returns all items received from events as infinite async stream.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Async.AsyncFactory">
            <summary>
            AsyncFactory creates Task from different async objects.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.AsyncFactory.FromWaitHandle(System.Threading.WaitHandle,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates Task from <see cref="T:System.Threading.WaitHandle"/>.
            Used code sample from https://stackoverflow.com/questions/24119429/rework-eventwaithandle-to-asynchronously-await-signal.
            </summary>
            <returns>Returns <c>true</c> if event was signaled and <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Eco.Core.Utils.Async.SingleObjectWaiter">
            <summary>Helper class for async operations which need to wait for <see cref="T:System.Threading.WaitHandle"/> in asynchronous manner. Not intended to be used directly, instead use <see cref="M:Eco.Core.Utils.Async.AsyncFactory.FromWaitHandle(System.Threading.WaitHandle)"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.SingleObjectWaiter.WaitAsync(System.Threading.WaitHandle,System.Int64,System.Threading.CancellationToken)">
            <summary>Waits until <paramref name="handle"/> notified or until <paramref name="millisecondsTimeoutInterval"/> expired. Returns <see cref="T:System.Threading.Tasks.ValueTask"/> which will be set to <c>true</c> when timeout and to <c>false</c> otherwise.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.SingleObjectWaiter.Unregister">
            <summary>Unregisters <see cref="F:Eco.Core.Utils.Async.SingleObjectWaiter.registration"/> if any currently active.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.SingleObjectWaiter.RegisterCancellation(System.Threading.CancellationToken)">
            <summary>Registers with the cancellation token to transition the source to a canceled state.</summary>
            <param name="cancellationToken">The cancellation token with which to register.</param>
        </member>
        <member name="M:Eco.Core.Utils.Async.SingleObjectWaiter.UnregisterCancellation">
            <summary>Disposes <see cref="F:Eco.Core.Utils.Async.SingleObjectWaiter.cancellationTokenRegistration"/> and returns <c>true</c> if it wasn't yet requested.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.TaskUtils.EnsureComplete``1(System.Threading.Tasks.Task{``0})">
            <summary> Excepts if the task is unfinished, and returns the result otherwise. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.TaskUtils.WithExceptionLog(System.Threading.Tasks.Task)">
            <summary>Ensures that if <paramref name="task"/> fails with exception then the exception will be recorded in log.</summary>
            <remarks>Usually you should avoid to run detached tasks (like `async void Something()`), but if for some reason that necessary then instead make two methods: `void Something() => SomethingAsync().WithExceptionLog("category");` and convert former to proper async method with Task result `async Task SomethingAsync()`.
            Implemented that way you will be able to use both async version where it supported and at least have exception logging for detached async methods (which will silently fail otherwise).</remarks>
        </member>
        <member name="M:Eco.Core.Utils.Async.TaskUtils.RunWithExceptionLog(System.Action)">
            <summary> Runs <paramref name="action"/> in background with <see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>, but wraps call in try-catch for exception logging. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Async.TaskUtils.RecordTaskException(System.Exception)">
            <summary>Records Task exception from <see cref="M:Eco.Core.Utils.Async.TaskUtils.WithExceptionLog(System.Threading.Tasks.Task)"/> or from <see cref="M:Eco.Core.Utils.Async.TaskUtils.RunWithExceptionLog(System.Action)"/>.</summary>
        </member>
        <member name="T:Eco.Core.Utils.CodeGen.DelegateUtils">
            <summary>Class containing utility methods that provide faster alternatives to using relfection in the runtime.</summary>
            <remarks>For more information see the wiki page at https://github.com/StrangeLoopGames/Eco/wiki/Delegate-Utils.</remarks>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodDelegateFactory``1(System.Reflection.MethodInfo)">
            <summary>
            Creates delegate factory for <paramref name="methodInfo"/> allowing fast delegate creation bounded to an instance.
            It generates and returns compiled <see cref="T:System.Reflection.Emit.DynamicMethod"/> as:
            <code>
            public TDelegate MethodDelegateFactory(object obj) => obj.Method;
            </code>
            Performance of such generated method is about same as if write a same statically compiled method.
            Alternative approach with <c>(TDelegate)Delegate.CreateDelegate(typeof(TDelegate), obj, methodInfo)</c> is ~24 times slower (6.7728ns vs 161.0455ns).
            May be used when you need to create a delegate with same method, but a different instance.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodInvoker``1(System.Reflection.MethodInfo)">
            <summary>Creates delegate that can invoke given method on an instance passed to it. Using returned delegate is ~40 times faster than calling Invoke on MethodInfo.</summary>
            <typeparam name="TDelegate">
            Type of the created delegate. Must have the same return type as method for which it is generated and
            take instance on which the method will be called as its first parameter. Other parameters must match parameters taken by the method.
            </typeparam>
            <param name="methodInfo">Method for which delegate will be created.</param>
            <remarks>If method is to be called multiple times on the same instance <see cref="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodDelegateFactory``1(System.Reflection.MethodInfo)"/> can be used for better performance.</remarks>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateCastingMethodInvoker``1(System.Reflection.MethodInfo)">
            <summary>Creates a delegate that can invoke given method on an instance passed to it. Using returned delegate is ~40 times faster than calling Invoke on MethodInfo.</summary>
            <typeparam name="TDelegate">
            Type of the created delegate. Must return object if method for which it is generated has any return type and
            take object reference pointing to instance on which the method will be called as its first parameter.
            Other parameters must also be of object type and their count has to match the number of parameters taken by the method.
            </typeparam>
            <param name="methodInfo">Method for which delegate will be created.</param>
            <remarks>This method creates a delegates that take objects as parameters and return nothing or an object. If you know parameter types and return type at compile time use <see cref="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodInvoker``1(System.Reflection.MethodInfo)"/> instead.</remarks>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreatePropertyValueGetter``2(System.Reflection.PropertyInfo)">
            <summary>Creates a delegate that returns value of given property on instance that is passed to it. Using returned delegate is ~25 times faster than calling GetValue on PropertyInfo.</summary>
            <typeparam name="TDeclaring">Type which declares the property.</typeparam>
            <typeparam name="TProperty">Type of the property.</typeparam>
            <param name="propertyInfo">Property for which delegate will be created.</param>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateCastingPropertyValueGetter(System.Reflection.PropertyInfo)">
            <summary>Creates a delegate that returns value of given property on instance that is passed to it. Using returned delegate is ~25 times faster than calling GetValue on PropertyInfo.</summary>
            <param name="propertyInfo">Property for which delegate will be created.</param>
            <remarks>This method creates a delegate that takes and returns an object. If you know declaring type and type of the property at compile time use <see cref="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreatePropertyValueGetter``2(System.Reflection.PropertyInfo)"/> instead.</remarks>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodDelegateFactory(System.Reflection.MethodInfo)">
            <summary>Same as <see cref="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodDelegateFactory``1(System.Reflection.MethodInfo)"/>, but returns untyped delegate.</summary>
        </member>
        <member name="M:Eco.Core.Utils.CodeGen.DelegateUtils.CreateMethodDelegateFactoryForGenericTypeDefinition(System.Reflection.MethodInfo)">
            <summary>Special version of method delegate factory for generic type definition. Maintains internal cache of types constructed from that definition and makes constructed type factory on demand.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ConcurrentExtensions.Consume``1(System.Collections.Concurrent.IProducerConsumerCollection{``0},System.Int32)">
            <summary>
            Consumes maxAmount elements from <paramref name="queue"/> and returns as array.
            It is thread-safe if <paramref name="queue"/> is thread-safe.
            MaxAmount = -1 means take all elements.
            If will take up to number of elements as available when function called.
            If during function call queue consumed by other threads and in the queue less or equals elements than was when initially requested then result will contain all available elements.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ControllerHashSet`1.RemoveAndGet(System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>We the specified function to remove a specific range of entries and raise the events accordingly.</summary>
        </member>
        <member name="T:Eco.Core.Utils.ControllerList`1">
            <summary>A thread-safe list of items, which automatically handles changed calls when mutating the list. Initialize must be called before use.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ControllerList`1.TryAdd(Eco.Shared.Networking.INetObject)">
            <summary>Add and use the callbacks if they exist.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ControllerList`1.RemoveAtAndReturn(System.Int32)">
            <summary>Remove the indexed element atomically and return it (and call callbacks on it)</summary>
        </member>
        <member name="T:Eco.Core.Utils.Debugging.CollectionDebugView`1">
            <summary>Allows viewing custom lists better in debugger.  See https://www.codeproject.com/Articles/28405/Make-the-debugger-show-the-contents-of-your-custom</summary>
        </member>
        <member name="T:Eco.Core.Utils.Dirtyable`1">
            <summary>Helps to track value dirty state. When <see cref="P:Eco.Core.Utils.Dirtyable`1.Value"/> assigned and if it not equals to previous value then <see cref="F:Eco.Core.Utils.Dirtyable`1.Dirty"/> flag sets.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Dirtyable`1.TryGetDirtyValueAndClear(`0@)">
            <summary>Tries to get dirty value (if value is <see cref="F:Eco.Core.Utils.Dirtyable`1.Dirty"/>) and then clears <see cref="F:Eco.Core.Utils.Dirtyable`1.Dirty"/> flag. Returns <c>false</c> if value wasn't dirty. Outputs current value in <paramref name="currentValue"/> no matter of return value.</summary>
        </member>
        <member name="T:Eco.Core.Utils.DirtyFlag">
            <summary>Handles tracking a dirty state, and now allowing to 'SetDirty' while its in the process of being updated. This way, if a dirty flag tries
            to set while its doing the dirty processing, it will make it dirty even after dirty processing complete.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtyFlag.SetDirty">
            <summary>Set the flag dirty, taking care of multithreading where the dirty processing may be happening concurrently.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtyFlag.IfDirty(System.Action)">
            <summary>If dirty, execute the action, then clear the dirty flag.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtyFlag.TryStartUpdate">
            <summary>Tries to start update for <see cref="T:Eco.Core.Utils.DirtyFlag"/>. Returns <c>false</c> if flag isn't set and update not needed.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtyFlag.FinishUpdate">
            <summary>Finishes update started with <see cref="M:Eco.Core.Utils.DirtyFlag.TryStartUpdate"/>. Clears the flag if it wasn't <see cref="M:Eco.Core.Utils.DirtyFlag.SetDirty"/> during the update.</summary>
        </member>
        <member name="T:Eco.Core.Utils.DirtySet`1">
            <summary>Component class to maintain a 'dirty' set of entries of type T that will periodically process and clear.
            It will check whenever ticked, and whenever CleanTimer is ready, which must be initialized in the implementing class.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtySet`1.#ctor(System.Double)">
            <summary>Initialize with a value for how long to wait between cleanings.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtySet`1.MarkDirty(System.Collections.Generic.IEnumerable{`0})">
            <summary>Mark a list of entires as dirty, to be processed at intervals in bulk.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtySet`1.MarkDirty(`0)">
            <summary>Mark a an entry as dirty, to be processed at intervals in bulk.</summary>
        </member>
        <member name="M:Eco.Core.Utils.DirtySet`1.DirtiesReadyToProcess">
            <summary>Returns a list of entries when they're ready to be processed, removing them from the list.
            Will only return when CleanTimer has expired, and CleanTimer continuously resets even when no entries 
            are in the dirty list (this it to allow entries to 'queue up', so they can be processed in bulk, 
            meant for systems where a flurry of changes will happen in quick succession, such that the processing
            shouldnt be done immediately after the first change).</summary>
        </member>
        <member name="T:Eco.Core.Utils.Dispository">
            <summary>
            Dispository (Disposable Repository) used for objects with IDisposable interface which won't be disposed in usual way,
            because they are singletons in example. In shutdown logic you should call DisposeAll to proper dispose all registered objects.
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.DoubleEnumerationGuard">
            <summary>
            Utility class which prevents double-enumeration for <see cref="T:System.Collections.IEnumerable"/>. Some enumerable may not allow double enumeration which leads to invalid state and may use this class for asserts.
            I.e. EnumerableSerializer creates enumerable for Steam. If double enumerated then Stream will return elements from current Stream read position which is invalid after first enumeration.
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.CoreEnumerableExtensions">
            <summary>Extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/> which aware about Eco.Core collections.</summary>
        </member>
        <member name="M:Eco.Core.Utils.CoreEnumerableExtensions.AsSnapshot``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns snapshot of <paramref name="enumerable"/> using optimized representation if possible.
            It assumes that non thread safe collections (<see cref="T:System.Collections.Generic.List`1"/>, <see cref="T:System.Collections.Generic.HashSet`1"/> and <see cref="T:System.Collections.Generic.Queue`1"/>) not modified from another threads and so returns as is.
            For <see cref="T:Eco.Core.Utils.ThreadSafeList`1"/>, <see cref="T:Eco.Core.Utils.ThreadSafeHashSet`1"/> and <see cref="T:Eco.Core.Utils.ThreadSafeQueue`1"/> it uses <c>Snapshot</c> property.
            With snapshot it guaranteed that you won't have multiple enumeration what ensures stable result and performance for complex LINQ chains.
            It also ensures you won't have collection modified from another threads to avoid inconsistent results.
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.HandleEvent">
            <summary> An event that can have callbacks removed via a passed handle. </summary>
        </member>
        <member name="M:Eco.Core.Utils.InitializableExtension.ChainTo(Eco.Core.Utils.Initializer,Eco.Core.Utils.Initializer,System.Action)">
            <summary>Runs an action when two initializers are initialized.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ImmutableHelper.ApplyImmutableReturn``2(``0@,System.Func{``0,System.ValueTuple{``0,``1}})">
            <summary> Applies a passed function to an immutable container, and returns the given value that comes back through the tuple.</summary>
            <typeparam name="T">The immutable container</typeparam>
            <typeparam name="TResult">The result of the operation. Can be a bool for success, or some other type (like a list for extracting values)</typeparam>
            <param name="original">The immutable container this is being run upon</param>
            <param name="apply">A function run on every entry of the container, which will return a tuple: (the new updated container, the value to pass back to the caller)</param>
            <returns>Returns the result of the application of the func over the container.</returns>
        </member>
        <member name="M:Eco.Core.Utils.ClientControllerExtensions.Remove(Eco.Core.Utils.IClientControlledContainer,Eco.Shared.Networking.INetObject,System.Object,System.Reflection.PropertyInfo)">
            <summary>An extension that allows ClientControlledContainers to be told to delete stuff by the client.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ClientControllerExtensions.RemoveAt(Eco.Core.Utils.IClientControlledList,Eco.Shared.Networking.INetObject,System.Int32,System.Reflection.PropertyInfo)">
            <summary>An extension that allows ClientControlledContainers to be told to remove an index by the client.</summary>
        </member>
        <member name="T:Eco.Core.Utils.ISnapshotable">
            <summary>Interface which may be implemented by collection which supports snapshots of elements (this snapshot is safe to use in thread-safe environment).</summary>
        </member>
        <member name="T:Eco.Core.Utils.ISnapshotable`1">
            <summary>Interface which may be implemented by collection which supports snapshots of elements (this snapshot is safe to use in thread-safe environment).</summary>
        </member>
        <member name="T:Eco.Core.Utils.LazyResult">
            <summary>Simple struct for tracking a result that holds off generating a string till requested</summary>
        </member>
        <member name="P:Eco.Core.Utils.LazyResult.Success">
            <summary>Check if <see cref="T:Eco.Core.Utils.Result"/> is success.</summary>
        </member>
        <member name="M:Eco.Core.Utils.LazyResult.#ctor(Eco.Core.Utils.Result)">
            <summary>Constructs <see cref="T:Eco.Core.Utils.LazyResult"/> for stateless <see cref="T:Eco.Core.Utils.Result"/>. Best to be used with reusable cached result defined as static lass member. In that case it has zero-allocations even when resolved with <see cref="M:Eco.Core.Utils.LazyResult.Resolve"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.LazyResult.#ctor(System.Boolean,System.Object,System.Func{System.Object,Eco.Core.Utils.Result})">
            <summary>Constructs <see cref="T:Eco.Core.Utils.LazyResult"/> for context aware <see cref="T:Eco.Core.Utils.Result"/>, usually when you need to build a message with link to some context object like a User, or Account, or Deed, or whatever. Ensure that <paramref name="success"/> is always in sync with generated result <see cref="P:Eco.Core.Utils.Result.Success"/>.</summary>
            <example><code>new LazyResult(false, user, user => Result.FailLoc($"Failed for {user.UILink()}"));</code></example>
        </member>
        <member name="M:Eco.Core.Utils.LazyResult.CreateResult">
            <summary>Creates new <see cref="T:Eco.Core.Utils.Result"/> from <see cref="T:Eco.Core.Utils.LazyResult"/>. Don't use it unless really necessary, prefer to use other functions on <see cref="T:Eco.Core.Utils.LazyResult"/> to check result state and it's message. You still may need this function if you need to pass the Result to another function and use it to merge another results into it.</summary>
        </member>
        <member name="M:Eco.Core.Utils.LazyResult.Resolve">
            <summary>Resolves the result if needed using Result generator. Otherwise just returns predefined/cached result.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ServerListExtensions.PairsNoSame``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Return pairs between list1 and list2, omitting ones where the values are equal.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ServerListExtensions.RemoveAndLogErrors``1(System.Collections.Generic.IList{``0},System.String,System.Func{``0,System.Boolean})">
            <summary> This function is used to ensure correct state of lists. By default it will remove all null elements. It's usefull to not crash the game if there were some errors on saving/migrations. Anyway these errors needs to be investigated.  </summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.ClientLogEventTrigger">
            <summary>Implementation of <see cref="T:Eco.Shared.Utils.ILogWriter"/> that will trigger a log to an event, which is watched by the chatserver and sent 
            to the client.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.ConsoleLogWriter">
            <summary>Implementation of <see cref="T:Eco.Shared.Utils.ILogWriter"/> to show log messages in console.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.EcoMicrosoftLogger">
            <summary><see cref="T:Microsoft.Extensions.Logging.ILogger"/> implementation for passing through ILogger based messages to Eco's built in logging system.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.EcoMicrosoftLoggerConfiguration">
            <summary>Configuration object for <see cref="T:Eco.Core.Utils.Logging.EcoMicrosoftLogger"/>. It is currently unused however required to exist for the ILogger implementation.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.EcoMicrosoftLoggerExtensions">
            <summary>Extensions for <see cref="T:Microsoft.Extensions.Logging.ILoggingBuilder"/></summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.EcoMicrosoftLoggerExtensions.AddEcoMicrosoftLogger(Microsoft.Extensions.Logging.ILoggingBuilder)">
            <summary>Registers the <see cref="T:Eco.Core.Utils.Logging.EcoMicrosoftLogger"/> <see cref="T:Microsoft.Extensions.Logging.ILogger"/> instance with the <see cref="T:Microsoft.Extensions.Logging.ILoggingBuilder"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.EcoMicrosoftLoggerExtensions.AddEcoMicrosoftLogger(Microsoft.Extensions.Logging.ILoggingBuilder,System.Action{Eco.Core.Utils.Logging.EcoMicrosoftLoggerConfiguration})">
            <inheritdoc cref="M:Eco.Core.Utils.Logging.EcoMicrosoftLoggerExtensions.AddEcoMicrosoftLogger(Microsoft.Extensions.Logging.ILoggingBuilder)"/>
            <param name="configure"><see cref="T:Eco.Core.Utils.Logging.EcoMicrosoftLoggerConfiguration"/> configuration to use for this logger instance.</param>
        </member>
        <member name="T:Eco.Core.Utils.Logging.EcoMicrosoftLoggerProvider">
            <summary><see cref="T:Microsoft.Extensions.Logging.ILoggerProvider"/> implementation for registering and using the <see cref="T:Eco.Core.Utils.Logging.EcoMicrosoftLogger"/> object.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.EcoMicrosoftLoggerProvider.Dispose(System.Boolean)">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin">
            <summary>Exception monitoring plugin for EcoServer based on Sentry. Responsible for remote error and issue monitoring on deployed instances.</summary>
        </member>
        <member name="F:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.SentryDsn">
            <summary>Constant public url used to ingest data relating to EcoServer</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.LogExceptionWithSentry(System.Exception,System.String,Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser)">
            <summary>Logs an exception with Sentry using our provided metadata.</summary>
            <param name="exception">Exception to report</param>
            <param name="dumpFile">Dump file to associate with the exception.</param>
            <param name="user">Optional user associated with this exception.</param>
            <returns>The <see cref="T:Sentry.SentryId"/> associated with the logged exception.</returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.CaptureException(System.Exception,Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser,System.Boolean)">
            <summary>Captures an exception and reports it to Sentry while also creating a local dump file</summary>
            <param name="exception">Exception to report</param>
            <param name="user">Optional user associated with this dump.</param>
            <param name="silent">Optional parameter to silently report without logging to console.</param>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.CaptureException(System.Exception,Eco.Shared.Authentication.LoginSession,System.Net.IPAddress,System.Boolean)">
            <inheritdoc cref="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.CaptureException(System.Exception,Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser,System.Boolean)"/>
            <param name="session"><see cref="T:Eco.Shared.Authentication.LoginSession"/> to associate with the exception report.</param>
            <param name="address">Optional <see cref="T:System.Net.IPAddress"/> that the error came from.</param>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.CreateDumpFile(System.Exception)">
            <summary>Creates a local dump file from an exception</summary>
            <param name="exception">Exception to report</param>
            <returns>Filename of the created dump file if created.</returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.Initialize(Eco.Core.Utils.TimedTask)">
            <summary>Initializes our Sentry Sdk with our given Dsn and configuration</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportingPlugin.ShutdownAsync">
            <summary>Instructs Sentry to flush any remaining events still in the queue prior to shutdown.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportSession">
            <summary><see cref="T:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser"/> implementation for reporting <see cref="T:Eco.Shared.Authentication.LoginSession"/>'s as users.</summary>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportSession.ReportUserId">
            <inheritdoc cref="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportUserId"/>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportSession.ReportUsername">
            <inheritdoc cref="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportUsername"/>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.ErrorReportSession.ReportIpAddress">
            <inheritdoc cref="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportIpAddress"/>
        </member>
        <member name="T:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser">
            <summary>Represents a user associated with an exception event.</summary>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportUserId">
            <summary>Universal unique identifier to report to the monitoring server.</summary>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportUsername">
            <summary>Name of the user to report to the monitoring server.</summary>
        </member>
        <member name="P:Eco.Core.Utils.Logging.ErrorReporting.IErrorReportUser.ReportIpAddress">
            <summary>Ip address to associate with the report.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.LogFileManager">
            <summary>Utility log manager for accessing information about logs stored in a directory.</summary>
        </member>
        <member name="F:Eco.Core.Utils.Logging.LogFileManager.LogDirectory">
            <summary>Represents the server's logging directory.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetRelativeToLogFolder(System.String)">
            <summary>Creates relative path from an absolute log file path.</summary>
            <param name="path">Absolute path of a log file.</param>
            <returns>Relative path string of the log file.</returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetRelativeToLogFolder(System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc cref="M:Eco.Core.Utils.Logging.LogFileManager.GetRelativeToLogFolder(System.String)"/>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetLogCategories(System.String,System.IO.SearchOption)">
            <summary>Returns all log category folder paths currently on the server.</summary>
            <param name="category">Root directory to search for category folders.</param>
            <param name="options"><seealso cref="T:System.IO.SearchOption"/> to use in the file search</param>
            <returns>Array containing all discovered category folders.</returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetLogCategories(System.IO.SearchOption)">
            <inheritdoc cref="M:Eco.Core.Utils.Logging.LogFileManager.GetLogCategories(System.String,System.IO.SearchOption)"/>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetLogFiles(System.String,System.IO.SearchOption)">
            <summary>Retrieves a list of all log files in a log folder/category.</summary>
            <param name="category">Category/folder to search. Leaving this as an empty string searches the entire log directory.</param>
            <param name="options"><seealso cref="T:System.IO.SearchOption"/> to use in the file search</param>
            <returns></returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetLogFiles(System.IO.SearchOption)">
            <inheritdoc cref="M:Eco.Core.Utils.Logging.LogFileManager.GetLogFiles(System.String,System.IO.SearchOption)"/>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.GetLogFilePath(System.String)">
            <summary>Retrieves the full path to a local log file using its relative path. This also performs sub path validation.</summary>
            <param name="path">Relative or absolute log file path to retrieve/validate.</param>
            <returns>Full string path to the log file.</returns>
        </member>
        <member name="M:Eco.Core.Utils.Logging.LogFileManager.ThrowIfNotSubPath(System.String)">
            <summary>Throws a new <seealso cref="T:System.ArgumentException"/> if the requested path is not a subdirectory of <seealso cref="F:Eco.Core.Utils.Logging.LogFileManager.LogDirectory"/></summary>
            <param name="root"></param>
        </member>
        <member name="T:Eco.Core.Utils.Logging.MulticastLogWriter">
            <summary>Implementation of <see cref="T:Eco.Shared.Utils.ILogWriter"/> allowing to write message to any number of different loggers.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Logging.NLogManager">
            <summary>
            <see cref="T:Eco.Core.Utils.Logging.NLogManager"/> class provides high level API with pre-configured defaults for <see cref="T:Eco.Core.Utils.Logging.NLogWriter"/> creation.
            <see cref="T:Eco.Core.Utils.Logging.NLogWriter"/> is implementation of <see cref="T:Eco.Shared.Utils.ILogWriter"/> interface wrapping NLog library <see cref="T:NLog.Logger"/>.
            To get default logger you may use <see cref="M:Eco.Core.Utils.Logging.NLogManager.GetEcoLogWriter"/> and if you need separate log (i..e admin commands log, chat log etc) then you can use <see cref="M:Eco.Core.Utils.Logging.NLogManager.GetLogWriter(System.String)"/> with any valid file name.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.NLogManager.GetLogWriter(System.String)">
            <summary>Returns custom <see cref="T:Eco.Core.Utils.Logging.NLogWriter"/> outputting to Logs/{name}/ directory. If <paramref name="name"/> is "Eco" then it will return default logger which output files to Logs directory.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.NLogManager.GetEcoLogWriter">
            <summary>Returns default Eco log writer configured to produce log files in Logs directory and output same messages to console with <see cref="T:Eco.Core.Utils.Logging.ConsoleLogWriter"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.NLogManager.ConfigureLogging">
            <summary>Configures default logging rules. If nlog.config file exists then default rules won't be created, but instead populated from the file.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Logging.NLogManager.Flush">
            <summary>Synchronously flushes all pending disk changes.</summary>
        </member>
        <member name="M:Eco.Core.Utils.LongPaths.GetDirectoryName(System.String)">
            <summary> Returns the directory name of the <paramref name="path"/>. </summary>
        </member>
        <member name="T:Eco.Core.Utils.OptimizedActivator">
            <summary>
            https://rogerjohansson.blog/2008/02/28/linq-expressions-creating-objects/
            https://stackoverflow.com/a/16162475
            https://stackoverflow.com/questions/13041674/create-func-or-action-for-any-method-using-reflection-in-c
            Check above links for details.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.OptimizedActivator.BuildDelegate``1(System.Reflection.MethodInfo,System.Object[])">
            <summary>Builds compiled delegate of type <typeparamref name="T"/> (much faster than reflection) for call to <paramref name="method"/>. If <typeparamref name="T"/> has less arguments than method then <paramref name="missingParamValues"/> will be used or default values supplied.</summary>
        </member>
        <member name="M:Eco.Core.Utils.OptimizedActivator.ConvertDelegateParam(System.Linq.Expressions.ParameterExpression,System.Type)">
            <summary>Creates expression which converts <paramref name="delegateParam"/> to <paramref name="targetType"/>. There special case for <see cref="T:System.Collections.IEnumerable"/> when cast to <see cref="T:System.Collections.Generic.IEnumerable`1"/> </summary>
        </member>
        <member name="T:Eco.Core.Utils.RelativePriorityAttribute">
            <summary>Base class for attributes that define priority relatively.</summary>
        </member>
        <member name="T:Eco.Core.Utils.PriorityAfterAttribute">
            <summary>Allows defining priority based on another type's priority. IE, you can say 'this type should be higher priority value than that type'.</summary>
        </member>
        <member name="T:Eco.Core.Utils.PriorityBeforeAttribute">
            <summary>Allows defining prirority based on another type's priority. IE, you can say 'this type should be lower priority value than that type'.</summary>
        </member>
        <member name="M:Eco.Core.Utils.PriorityExtensions.OrderByPriority``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Order a list of objects by their type's priority, calculating relative priorities as needed.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ProcessorUtils.GetAvailableProcessorCount">
            <summary>Returns number of available processors. Uses processor affinity if platform supports it (windows or linux) or <see cref="P:System.Environment.ProcessorCount"/> otherwise.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ProcessorUtils.GetAvailableProcessorCountUsingProcessorAffinity">
            <summary>Returns number of available cores using processor affinity (basically number of set bits).</summary>
        </member>
        <member name="T:Eco.Core.Utils.PropertyScanning.BulkContextObject">
            <summary>
            Context object with cache, which could be used for example for bulk query data for all users instead of doing query per user. 
            It's useful to save data between evaluations of GameValue, so it will make first all calculations that are needed for all users, and then just return them from cache. 
            Especially useful in case of DB operations: it's too slow to make query per user, so if you can make bulk query with all users once, it will save a lot of time. 
            Implemented because of lag investigation at White Tiger server: it fixes not working civic ticks due to too slow database requests.    
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.RecursiveSubscriptions">
            <summary>Helper object for implementing proper recursive subscriptions for the complex structures. For example, it is used in Election.cs for updating Description which includes information about different civics objects.</summary>
        </member>
        <member name="M:Eco.Core.Utils.RecursiveSubscriptions.SubscribeRecursive(Eco.Core.Controller.IController)">
            <summary>Subscribe for the controller recursively, so changes in the nested objects are tracked too. Remember subscriptions for this controller for the future Unsubscribe process.</summary>
        </member>
        <member name="M:Eco.Core.Utils.RecursiveSubscriptions.UnsubscribeRecursive(Eco.Core.Controller.IController)">
            <summary>Clear all subscriptions for the controller. We won't forget anything cause all subscriptions were properly stored.</summary>
        </member>
        <member name="M:Eco.Core.Utils.CoreReflectionUtils.IsReference(System.Reflection.MemberInfo,System.Int32)">
            <summary>Is the given thing a referene?  Return FALSE if it's a container, even if it contains references.</summary>
        </member>
        <member name="M:Eco.Core.Utils.CoreReflectionUtils.IsReferenceOrReferenceContainer(System.Reflection.MemberInfo,System.Int32)">
            <summary>Is the given thing a referene?  Return TRUE if it's a container that can contain references.</summary>
        </member>
        <member name="M:Eco.Core.Utils.CoreReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Object)">
            <summary>Given a method info, make a delegate that calls it on the given target. Handles methods with or without return values,
            as well as variable numbers of parameters.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Result.IsFailed(Eco.Shared.Localization.LocString@)">
            <summary>
            Check if result failed and saves fail message into output parameter.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Result.TapToIfNotSet(Eco.Core.Utils.Result@)">
            <summary>
            Taps this to another <paramref name="result"/> if <paramref name="result"/> has no value and returns this.
            Useful in workflow where you want to check multiple results sequentially and remember first result.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.RPCUtils.RPCFoldout(Eco.Shared.Localization.LocString,Eco.Core.Systems.IHasSerializableID,System.String)">
            <summary>RPC foldout is like a foldout list, but the contents are sent from the server, by the client calling the given RPC on the given view.</summary>
        </member>
        <member name="M:Eco.Core.Utils.RPCUtils.RPCFoldoutNeverSerialized(Eco.Shared.Localization.LocString,Eco.Core.Systems.IHasUniversalID,System.String)">
            <summary>An RPC foldout which the caller guarantees will never be serialized.  Allows us to create RPC calls to something with a transient ID.  This is useful in things like tooltip text
            where there's no change the text will be serialized.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.ConcatStream">
            <summary>Allow to concat two streams together. When the first stream fully read it will continue to read from the second stream.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.ReadOnlyForkStream">
            <summary>
            Read-only stream which "forks" data which was read to <see cref="F:Eco.Core.Utils.Streams.ReadOnlyForkStream.fork"/> stream.
            "Fork" means it will have copy of all data which was read from <see cref="T:System.IO.Stream"/>.
            It doesn't take ownership of <see cref="F:Eco.Core.Utils.Streams.ReadOnlyForkStream.fork"/> and you should Dispose it on you own.
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.ReadOnlyStream">
            <summary>Base class for read-only stream wrappers.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.ReadOnlyWrapperStream">
            <summary>Base class for read-only stream wrappers.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.StreamWithLength">
            <summary>Adds Length and Position (get) support to Stream.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Streams.WrapperStream">
            <summary>
            Can be used as base class for other stream wrappers.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.StringUtils.JoinSafe(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.String,System.String)">
            <summary> Postfix will be added at the end of the <paramref name="other"/> if it is set. 
            For a demo see how AccountsChangeSet.DescribeChange wraps amount description with parenthesis. </summary>
        </member>
        <member name="M:Eco.Core.Utils.StringUtils.TryRemoveFromEnd(System.String,System.String,System.String@)">
            <summary>If the specified string is used at the end of the current string, we return the new string without that part else we just return false.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.AsAsyncAction(System.Action)">
            <summary> Represents <see cref="T:System.Action"/> as async action with immediate execution (invokes the <paramref name="action"/> and returns <see cref="P:System.Threading.Tasks.Task.CompletedTask"/>). </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.AsAsyncCancellableAction(System.Action)">
            <summary> Represents <see cref="T:System.Action"/> as async cancellable action with immediate execution (invokes the <paramref name="action"/> and returns <see cref="P:System.Threading.Tasks.Task.CompletedTask"/>). </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.TryInvokeAll``1(System.Collections.Generic.IEnumerable{System.Action{``0}},``0,System.Collections.Generic.List{System.Exception}@)">
            <summary>Try to invoke actions passing parameter to each of them. Return true if they all succeed and false if any of them fails with an exception.</summary>
            <param name="exceptions">Exceptions thrown by actions. Null if none were thrown.</param>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.TryInvokeAll``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1},System.Collections.Generic.List{System.Exception}@)">
            <summary>Try to invoke actions by passing them along with parameter to invoke function. Return true if they all succeed and false if any of them fails with an exception.</summary>
            <param name="exceptions">Exceptions thrown by actions. Null if none were thrown.</param>
            <param name="invoke">Function that will be called to invoke each action.</param>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.TryInvoke``1(System.Action{``0},``0,System.Exception@)">
            <summary>Try to invoke action. Return true if it succeeds and false if it fails with an exception.</summary>
            <param name="exception">Exception thrown by action. Null if no exception is thrown.</param>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionUtils.TryInvoke``2(System.Action{``0,``1},``0,``1,System.Exception@)">
            <summary>Try to invoke action. Return true if it succeeds and false if it fails with an exception.</summary>
            <param name="exception">Exception thrown by action. Null if no exception is thrown.</param>
        </member>
        <member name="T:Eco.Core.Utils.Threading.ActionWorker">
            <summary> Wraps asynchronous action to <see cref="T:Eco.Core.Utils.Threading.IWorker"/> interface. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.ActionWorker.DoWork(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Eco.Core.Utils.Threading.WorkerBase.DoWork(System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Eco.Core.Utils.Threading.EventDrivenWorker">
            <summary> Worker which controlled by <see cref="F:Eco.Core.Utils.Threading.EventDrivenWorker.autoResetEvent"/>. It will wait until <see cref="F:Eco.Core.Utils.Threading.EventDrivenWorker.autoResetEvent"/> set before every call to <see cref="M:Eco.Core.Utils.Threading.EventDrivenWorker.DoRepeatableWork(System.Threading.CancellationToken)"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Action,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with infinite timeout between events.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Threading.AutoResetEvent,System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with infinite timeout between events.
            <paramref name="autoResetEvent"/> should be set for initial <paramref name="doWork"/> execution on <see cref="M:Eco.Core.Utils.Threading.WorkerBase.Start"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Int32}},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with infinite timeout between events.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Threading.AutoResetEvent,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Int32}})">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with infinite timeout between events.
            <paramref name="autoResetEvent"/> should be set for initial <paramref name="repeatableAction"/> execution on <see cref="M:Eco.Core.Utils.Threading.WorkerBase.Start"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Func{System.Int32},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with timeout between events defined by return value of <paramref name="repeatableAction"/> function in milliseconds.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.#ctor(System.Threading.AutoResetEvent,System.Func{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Utils.Threading.EventDrivenWorker"/> class with timeout between events defined by return value of <paramref name="repeatableAction"/> function in milliseconds.
            <paramref name="autoResetEvent"/> should be set for initial <paramref name="repeatableAction"/> execution on <see cref="M:Eco.Core.Utils.Threading.WorkerBase.Start"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.EventDrivenWorker.DoRepeatableWork(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Eco.Core.Utils.Threading.RepeatableWorkerBase.DoRepeatableWork(System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Eco.Core.Utils.Threading.IntervalActionWorker">
            <summary> Executes an action with specific interval (it will adjust delay between executions based on the action execution time). </summary>
        </member>
        <member name="P:Eco.Core.Utils.Threading.IntervalActionWorker.Interval">
            <summary> Interval between <see cref="P:Eco.Core.Utils.Threading.RepeatableActionWorker.RepeatableAction"/> executions. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.IntervalActionWorker.DoRepeatableWork(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Eco.Core.Utils.Threading.RepeatableActionWorker.DoRepeatableWork(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.Create(System.TimeSpan,System.Action)">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.RepeatableActionWorker"/> class with specified delay between executions.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.CreateWithInterval(System.TimeSpan,System.Action)">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.RepeatableActionWorker"/> class with specified execution interval.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.CreateWithInterval(System.TimeSpan,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.RepeatableActionWorker"/> class from async action with specified execution interval.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.Create(System.TimeSpan,System.Action{System.Threading.CancellationToken})">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.RepeatableActionWorker"/> class with specified interval between executions with cancellation support.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.Create(System.Func{System.TimeSpan})">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.PeriodicWorkerFactory"/> class from function which returns delay before next work.</summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.PeriodicWorkerFactory.Create(System.Func{System.Threading.Tasks.Task{System.TimeSpan}})">
            <summary>Creates a new instance of the <see cref="T:Eco.Core.Utils.Threading.PeriodicWorkerFactory"/> class from function which returns delay before next work.</summary>
        </member>
        <member name="T:Eco.Core.Utils.Threading.RepeatableActionWorker">
            <summary> Performs repeatable async action until cancelled. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.RepeatableActionWorker.DoRepeatableWork(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Eco.Core.Utils.Threading.RepeatableWorkerBase.DoRepeatableWork(System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Eco.Core.Utils.Threading.RepeatableWorkerBase">
            <summary> Base class for workers which implements default repeatable Worker workflow. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.RepeatableWorkerBase.DoRepeatableWork(System.Threading.CancellationToken)">
            <summary> Performs repeatable work, may be cancelled with <paramref name="token"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.RepeatableWorkerBase.DoWork(System.Threading.CancellationToken)">
            <summary> Main work loop which repeats <see cref="M:Eco.Core.Utils.Threading.RepeatableWorkerBase.DoRepeatableWork(System.Threading.CancellationToken)"/> until cancelled. </summary>
        </member>
        <member name="T:Eco.Core.Utils.Threading.WorkerBase">
            <summary> Base class for workers which implements default Worker workflow. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.WorkerBase.DoWork(System.Threading.CancellationToken)">
            <summary> Actual work performed in this method. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.WorkerBase.Start">
            <summary> Starts worker with default <see cref="T:System.Threading.Tasks.TaskFactory`1"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.WorkerBase.Start(System.Threading.Tasks.TaskFactory)">
            <summary> Starts worker with <paramref name="taskFactory"/> <see cref="T:System.Threading.Tasks.TaskFactory`1"/>. </summary>
        </member>
        <member name="M:Eco.Core.Utils.Threading.WorkerBase.ShutdownAsync">
            <summary> Shutdowns worker by setting cancellation token <see cref="F:Eco.Core.Utils.Threading.WorkerBase.cts"/> and waiting for <see cref="F:Eco.Core.Utils.Threading.WorkerBase.task"/> to be completed. </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeActions.UpdateSubject``2(``0@,``0,System.Func{``0,Eco.Core.Utils.ThreadSafeActionBase{``1}},``1)">
            <summary>
            Updates <see cref="T:Eco.Core.Utils.ThreadSafeActionBase`1"/> subject (action emitter). It is thread-safe and ensures old subscription removed from <paramref name="subject"/> even in concurrent environment.
            It possible though that both <paramref name="newSubject"/> and <paramref name="subject"/> subscribed. it is very rare case, but you should aware of it.
            It happens if action removed from old subject, but subject changed in another thread after this, before new subject assigned (it will be removed anyway because of interlocked change, but it may exists for short period of time).
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeActions.UpdateSubject``2(``0@,``0,System.Action{``0,``1},System.Action{``0,``1},``1)">
            <summary>
            Updates subject (action emitter). It uses addAction and removeAction operations for adding action to new subject and removing from the old.
            It is thread-safe and ensures old subscription removed from <paramref name="subject"/> even in concurrent environment.
            It possible though that both <paramref name="newSubject"/> and <paramref name="subject"/> subscribed for short period of time. It is very rare case, but you should aware of it.
            It happens if action removed from old subject, but subject changed in another thread after this, before new subject assigned (it will be removed anyway because of interlocked change, but it may exists for short period of time).
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeBidirectionalMap`2.GetOrAdd(`0,System.Func{`1})">
            <summary>
            Thread-safe implementation of GetOrAdd pattern with <paramref name="valueFactory"/>.
            Please be aware that <paramref name="valueFactory"/> may be called even when value not inserted, because of nature of lock-free algorithms.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeBidirectionalMap`2.GetOrAdd(`0,`1)">
            <summary>Thread-safe implementation of GetOrAdd pattern.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>Sets the specified key to <paramref name="newValue"/> if the specified key already is set to <paramref name="comparisonValue"/>.</summary>
            <returns>True if update succeeds.</returns>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Remove the specified keys from the dictionary. Returns a list of all the removed keys or null if no key was removed.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes <paramref name="item"/> from dictionary if it matches both key and value of <paramref name="item"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeHashSet`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary> Removes all items matching <paramref name="match"/> predicate and returns count of removed items. </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeHashSet`1.RemoveAllAndReturn(System.Func{`0,System.Boolean})">
            <summary>Remove from the hashset any entries passing the given match test, and return them.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeHashSet`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Remove all items contained in <paramref name="range"/> if they are present in the hash set.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeHashSet`1.RemoveRangeAndReturn(System.Collections.Generic.IEnumerable{`0})">
            <summary>Remove all items contained in <paramref name="range"/> if they are present in the hash set.</summary>
            <returns>Items that were removed.</returns>
        </member>
        <member name="T:Eco.Core.Utils.ThreadSafeLimitedHistory`1">
            <summary>
            Limited size history which automatically ejects old elements when more than N elements added.
            New elements added to top of the history (as most recent) and will be returned first while enumeration.
            Elements can't be directly removed from history one by one, but you can <see cref="M:Eco.Core.Utils.ThreadSafeLimitedHistory`1.Clear"/> whole history.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeLimitedHistory`1.Add(`0)">
            <summary>Adds new <paramref name="element"/> and ejects any elements which is behind <see cref="F:Eco.Core.Utils.ThreadSafeLimitedHistory`1.size"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeLimitedHistory`1.GetEnumerator">
            <summary>Returns elements in order they was added. If you need to get most recent elements first then you need to use Reverse function.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.ToArray">
            <summary> Makes atomic ToArray operation. It isn't safe to use <see cref="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})"/>, because it gets <see cref="P:Eco.Core.Utils.ThreadSafeList`1.Count"/> as a separate operation (and count may be modified in between). </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.ToList">
            <summary> Makes atomic ToList operation. It isn't safe to use <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})"/>, because it gets <see cref="P:Eco.Core.Utils.ThreadSafeList`1.Count"/> as a separate operation (and count may be modified in between). </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.RemoveAt(System.Int32)">
            <summary>Removes an element but doesnt return it (needed for implementing IList).</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.RemoveAtAndReturn(System.Int32)">
            <summary>Remove the indexed element atomically and return it.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.AddOrReplace(`0,System.Predicate{`0})">
            <summary>Replaces first element matching the <paramref name="matcher"/> with <paramref name="item"/> or adds new <paramref name="item"/> if no one matched.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.RemoveFirst(System.Predicate{`0})">
            <summary>Removes first item matching the <paramref name="matcher"/>. Returns <c>true</c> if item was removed.</summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.RemoveAll(System.Predicate{`0},System.Collections.Immutable.ImmutableList{`0}@)">
            <summary>
            Removes all elements by <paramref name="match"/> and returns <paramref name="removed"/> elements in output parameter.
            This operation is atomic and ensures that all returned elements belonging to this remove operation.
            In example if you do something like
            <code>var l = items.ToList(); /* items may be added or removed */ items.RemoveAll(predicate); /* items may be added or removed */ var removed = l.Except(items);</code>
            then you may have inconsistent results where in `removed` will be items which was added since call to `RemoveAll` or removed since call to `ToList` and may match the predicate
            or you may miss some removed items if they added after call to ToList or added back to items since call to RemoveAll.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.WithSnapshot``1(System.Func{System.Collections.Generic.IReadOnlyList{`0},``0})">
            <summary>
            Allows to execute action with immutable list for thread-safe calculations
            I.e. you may want to get Count first and then make some calculations based on number of elements.
            For separate Count and GetEnumerator operations you may have state changed between these two calls.
            </summary>
            <param name="action">Function to execute with read-only list.</param>
            <typeparam name="TResult">Result of function applied to immutable list.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeList`1.WithSnapshot(System.Action{System.Collections.Generic.IReadOnlyList{`0}})">
            <summary>
            Same as <see cref="M:Eco.Core.Utils.ThreadSafeList`1.WithSnapshot``1(System.Func{System.Collections.Generic.IReadOnlyList{`0},``0})"/> but for action.
            </summary>
            <param name="action">Action to execute with read-only list.</param>
        </member>
        <member name="P:Eco.Core.Utils.ThreadSafeList`1.Snapshot">
            <summary>
            Gets current list read-only snapshot. May be used to get consistent result between different access calls.
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.ThreadSafeQueue`1">
            <summary>
            Only use this collection when absolutely necessary when you can't use <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> instead.
            It known to have very bad performance and memory usage for often updated big collections, because all new elements added to stack which then reversed when you need to dequeue element.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.ThreadSafeQueue`1.TryDequeue(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Tries to dequeue item from the <see cref="T:Eco.Core.Utils.ThreadSafeQueue`1"/> if it is matching <paramref name="predicate"/>.
            It is atomic thread-safe alternative of sequence <code>if (!queue.IsEmpty &amp;&amp; predicate(queue.Peek())) value = queue.Dequeue();</code>
            </summary>
        </member>
        <member name="T:Eco.Core.Utils.ThreadSafeSubscriptions">
            <summary>Thread safe implementation of <see cref="T:Eco.Shared.View.ISubscriptionsList"/> for server-side code.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TimedTask.ReportProgress(System.String)">
            <summary> Write the progress to the console, needs to be called inside ConsoleSynchronizationContext. </summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackedCollectionExtensions.OnCurrentAndFutureEntries``1(Eco.Core.Utils.ITrackedEnumerable,System.Action{Eco.Shared.Networking.INetObject,``0},Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.Action{Eco.Shared.Networking.INetObject,``0})">
            <summary> Use watcher in order to have easy way to unsubscribe by Unwatch in object. </summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackedCollectionExtensions.NotifyChanged(Eco.Core.Utils.ITrackedControllerEnumerable)">
            <summary>We notify the parent of this controller list and the list itself that it was changed (somethings were adedd/removed).</summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackedCollectionExtensions.ApplyChange(Eco.Core.Utils.ITrackedControllerEnumerable,System.Action)">
            <summary>We apply the specified changes and then notify.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackedCollectionExtensions.ApplyChange``1(Eco.Core.Utils.ITrackedControllerEnumerable,System.Func{``0})">
            <summary>We apply the specified changes and return what's needed and then notify.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackedCollectionExtensions.ApplyChangeConditional(Eco.Core.Utils.ITrackedControllerEnumerable,System.Func{System.Boolean})">
            <summary>We try to apply the changes and if we were succesful we notify. We return whether we were able to apply the changes or not.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackingCallbacks.SubscribeAddRemove(System.Action{Eco.Shared.Networking.INetObject,System.Object})">
            <summary>Subscribe to <see cref="P:Eco.Core.Utils.TrackingCallbacks.OnAdd"/> and <see cref="P:Eco.Core.Utils.TrackingCallbacks.OnRemove"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TrackingCallbacks.UnsubscribeAddRemove(System.Action{Eco.Shared.Networking.INetObject,System.Object})">
            <summary>Unsubscribe to <see cref="P:Eco.Core.Utils.TrackingCallbacks.OnAdd"/> and <see cref="P:Eco.Core.Utils.TrackingCallbacks.OnRemove"/>.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TypeUtils.GetEcoTypesInfo">
            <summary>Collect all type Infos in assemblies with Eco namespace.</summary>
        </member>
        <member name="M:Eco.Core.Utils.TypeUtils.GetEcoTypes">
            <summary>Collect all types in assemblies with Eco namespace.</summary>
        </member>
        <member name="T:Eco.Core.Utils.IContainsDynamicFlags">
            <summary> Properties with [DynamicFlags] attribute will result client side's selector to try to look for this container in their parent.
            If there is an entry with the same name, then selector will use contained flags instead of the default ones.
            Nothing will be replaced if there is no such entry.
            For a demo see how wages declare their WagesPaidFromAccount and how AppointedTitle clears its GovernmentAccess flag. </summary>
        </member>
        <member name="M:Eco.Core.Utils.ViewExtensions.SetFlags(Eco.Core.Utils.IContainsDynamicFlags,System.String,Eco.Shared.View.ViewSelectorFlags)">
            <summary> Sets view selector flags for the property in the container. 
            For a demo see how ElectedTitle sets GovernmentAccess flag for its wages source account. </summary>
        </member>
        <member name="T:Eco.Core.Utils.WeakKeyConcurrentDictionary`2">
            <summary>
            Concurrent dictionary which uses weak references for key values. This way you may add mapping without care key referenced object will never be released.
            You need eventually call <see cref="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.Cleanup"/> to ensure entries with dead references removed.
            </summary>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)"/>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.TryRemove(`0,`1@)">
            <inheritdoc cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)"/>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.Clear">
            <summary>Removes all entries no matter if alive or not.</summary>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.Cleanup">
            <summary>Removes all "dead" key entries.</summary>
        </member>
        <member name="T:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey">
            <summary>Private <c>TKey</c> wrapper which only holds weak reference, but inherits <see cref="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey.GetHashCode"/> and <see cref="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey.Equals(System.Object)"/> from wrapped object.</summary>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey.TryGetTarget(`0@)">
            <summary>Tries to obtain <paramref name="target"/> value (if not yet garbage collected).</summary>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey.Equals(System.Object)">
            <summary>Equality which works both with <see cref="T:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey"/> and referenced object.</summary>
        </member>
        <member name="M:Eco.Core.Utils.WeakKeyConcurrentDictionary`2.WeakReferenceKey.GetHashCode">
            <summary>Shared hash code with referenced object.</summary>
        </member>
        <member name="T:Eco.Core.Plugins.ApplicationExitCodes">
            <summary>
            Enum containing all standardized and understood Eco server exit codes. Ranging from 0-255.
            This Enum contains all options currently used by the Eco server instance. This enum should avoid overlappin with standard application exit codes.
            </summary>
            <remarks>
            Eco specific exit codes should be aware of the reserved exit codes used by various operating systems. A rough layout of these codes is as follows
            
            <list type="bullet">
            <item>0 - Normal exit.</item>
            <item>1-2 - Standardized Failure.</item>
            <item>126 - A command was found but cannot be executed.</item>
            <item>127 - A command could not be found.</item>
            <item>128-255 - Failure.</item>
            <item>256 and above - A command has exited because of reciept of a signal.</item>
            </list>
            Eco is free to utilize exit codes between 3 and 125.
            </remarks>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.NormalShutdown">
            <summary>Succesful application termination.</summary>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.GeneralApplicationError">
            <summary>Catchall for general errors.</summary>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.MisuseOfShellBuiltin">
            <summary>
            Exit code 2 signifies invalid usage of some shell built-in command. Examples of built-in commands include. 
            This is only here to reserve the exit code as Eco Server should never return this code on its own.
            </summary>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.ApplicationRestart">
            <summary>Fired off when Eco server attempts to restart. Generally handled by the maintenance plugin.</summary>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.ApplicationUpdate">
            <summary>Fired off when Eco server attempts to update. Generally handled by the maintenance plugin.</summary>
        </member>
        <member name="F:Eco.Core.Plugins.ApplicationExitCodes.IntegrationTestsFailed">
            <summary>Called when the integration test's plugin shuts down the server with an unsuccessful result.</summary>
        </member>
        <member name="T:Eco.Core.Plugins.DisplayTab">
            <summary>Simple implementation of <see cref="T:Eco.Core.Plugins.Interfaces.IDisplayTab"/> interface which may be used as POCO for <see cref="P:Eco.Core.Plugins.Interfaces.IHasDisplayTabs.DisplayTabs"/>.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.DisplayTab.OnDisplayTabVisibilityChange(System.Boolean)">
            <inheritdoc cref="M:Eco.Core.Plugins.Interfaces.IDisplayTab.OnDisplayTabVisibilityChange(System.Boolean)"/>
        </member>
        <member name="M:Eco.Core.Plugins.DisplayTab.GetDisplayTitle">
            <inheritdoc cref="M:Eco.Core.Plugins.Interfaces.IDisplayTab.GetDisplayTitle"/>
        </member>
        <member name="M:Eco.Core.Plugins.DisplayTab.GetDisplayText">
            <inheritdoc cref="M:Eco.Core.Plugins.Interfaces.IDisplayTab.GetDisplayText"/>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.ICommandablePlugin">
            <summary>
            Displays menu item for the plugin.
            </summary>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.ICustomUIPlugin">
            <summary>
            Interface for a plugin to show a custom UI tab.
            </summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.ICustomUIPlugin.GetCustomUIControl">
            <summary>
            Return a Control that will be displayed in the tab. If the plugin is also a ITabPage it will get tab page enter/leave events.
            </summary>
            <returns>A Control</returns>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.ICustomUIPlugin.GetCustomUIName">
            <summary>
            The name of the tab.
            </summary>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.IDisplayTab">
            <summary>Interface for Display tabs with methods returning title and content. It also has callback handler called when tab visibility changes (i.e. if you want to avoid expensive calculation when tab is invisible).</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IDisplayTab.OnDisplayTabVisibilityChange(System.Boolean)">
            <summary>Callback to be called when tab become visible or hidden.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IDisplayTab.GetDisplayTitle">
            <summary>Returns title which will be used as UI tab title.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IDisplayTab.GetDisplayText">
            <summary>Returns current content of UI tab.</summary>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.IHasDisplayTabs">
            <summary>
            Interface which may be used by plugins which provides generates custom display text.
            Plugin should return enumerable of <see cref="T:Eco.Core.Plugins.Interfaces.IDisplayTab"/> objects each of which represents a display tab.
            </summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IInitializablePlugin.Initialize(Eco.Core.Utils.TimedTask)">
            <summary>Called by the <seealso cref="T:Eco.Core.PluginManager"/> to initialize the <seealso cref="T:Eco.Core.Plugins.Interfaces.IServerPlugin"/> instance.</summary>>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.IServerPlugin">
            <summary>Base interface for all server plugins.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IServerPlugin.GetStatus">
            <summary>Returns the current status string for displaying in the Server's console.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IServerPlugin.GetCategory">
            <summary>Returns the category string associated with this plugin. Used in Server UI sorting.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IPluginManager.FireShutdown(Eco.Core.Plugins.ApplicationExitCodes)">
            <summary>
            Initiates shutdown procedure, but doesn't wait until it complete. It doesn't terminate code execution and so instruction after this call will be executed as usual.
            Optional <paramref name="exitCode"/> contains application exit code.
            </summary>
            <param name="exitCode">Exit code to return to the host operating system.</param>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.ITabPage">
            <summary>
            Interface for a plugin to be notified if the user enters or leaves their ICustomUIPlugin tab.
            </summary>
        </member>
        <member name="T:Eco.Core.Plugins.Interfaces.IWebPlugin">
            <summary>Interface for a plugin to allow web based content serving on the elections Website.</summary>
            <remarks>It is not recommended to write IWebPlugin implementations that are not compiled to a DLL assembly prior to server start.</remarks>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWebPlugin.GetMenuTitle">
            <summary>Returns the name that this plugin should represent on the websites side navigation.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWebPlugin.GetPluginIndexUrl">
            <summary>Returns the index url to load into the website when this plugin is selected. If not provided it will load the index.html out of the the plugin's file providers.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWebPlugin.GetFontAwesomeIcon">
            <summary>Returns the optional font awesome class to use for the menu link. More information about FontAwesome and the list of available icons can be found here https://fontawesome.com/</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWebPlugin.GetStaticFilesPath">
            <summary>
            Returns the optional path to the local static files that should be served by the web plugin's url resource path.
            This folder should be relative to the mod's DLL location.
            </summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWebPlugin.GetEmbeddedResourceNamespace">
            <summary>Returns the optional namespace of the embedded DLL resources that should be served by the web plugin's url resource path.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.Interfaces.IWorkerPlugin.DoWork(System.Threading.CancellationToken)">
            <summary>
            Performs one unit of work. There no delay between <see cref="M:Eco.Core.Plugins.Interfaces.IWorkerPlugin.DoWork(System.Threading.CancellationToken)"/> calls, it works pretty much like one iteration of loop.
            Usually you need to maintain delay between calls with <see cref="M:System.Threading.Tasks.Task.Delay(System.Int32)"/> or <see cref="M:Eco.Core.Utils.Async.SingleObjectWaiter.WaitAsync(System.Threading.WaitHandle,System.Int64,System.Threading.CancellationToken)"/> or other async wait methods to only perform work as often as required.
            Try to avoid idle loops and do work only when required. In some cases it may be preferred to use <see cref="T:Eco.Core.Utils.Threading.PeriodicWorkerFactory"/> instead for more flexible worker creation.
            Work may be interrupted between <see cref="M:Eco.Core.Plugins.Interfaces.IWorkerPlugin.DoWork(System.Threading.CancellationToken)"/> calls or provided <paramref name="token"/> can be used to check if work should be cancelled within <see cref="M:Eco.Core.Plugins.Interfaces.IWorkerPlugin.DoWork(System.Threading.CancellationToken)"/>.
            </summary>
            <param name="token">cancellation token.</param>
        </member>
        <member name="T:Eco.Core.Plugins.Internal.SampleCollection`1">
            <summary>Collection of samples with sum, count and last sample. Used by <see cref="T:Eco.Core.Plugins.PluginTickTimer`1"/>.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.PluginConfig`1.SaveAsync">
            <summary> Saves config file asynchronously. Safe for Wait() from UI thread. </summary>
        </member>
        <member name="M:Eco.Core.Plugins.PluginConfig`1.SaveAsAsync(System.String)">
            <summary> Saves config file asynchronously to specific filename. Safe for Wait() from UI thread. </summary>
        </member>
        <member name="M:Eco.Core.Plugins.PluginConfig`1.ResetAsync">
            <summary> Resets config to default. </summary>
        </member>
        <member name="T:Eco.Core.Plugins.PluginPriorities">
            <summary>This determines the initialization order of plugins.</summary>
        </member>
        <member name="T:Eco.Core.Plugins.PluginTickTimerBase">
            <summary>Base class for all <see cref="T:Eco.Core.Plugins.PluginTickTimer"/> implementations.</summary>
        </member>
        <member name="P:Eco.Core.Plugins.PluginTickTimerBase.PluginName">
            <summary>The name of the plugin we are currently monitoring.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.PluginTickTimerBase.StoreTickMetric(System.Double,System.Double)">
            <summary>Posts our metrics to ElasticSearch under our configured plugin name.</summary>
            <param name="averageTime">The total average time of the tick.</param>
            <param name="totalTime">The total tick time.</param>
        </member>
        <member name="T:Eco.Core.Plugins.PluginTickTimer`1">
            <summary>Typedef variant of the <seealso cref="T:Eco.Core.Plugins.PluginTickTimer"/> class for monitoring and collecting tick averages.</summary>
            <typeparam name="T">Plugin type to monitor</typeparam>
        </member>
        <member name="T:Eco.Core.Plugins.PluginTickTimer">
            <summary>Generic tick timer for collecting and storing average tick metrics.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.StorageManager.LoadSaveAsync(System.Boolean)">
            <summary>Loads save from <see cref="P:Eco.Core.Plugins.StorageManager.SaveName"/>. If flag <paramref name="restoreBackupIfSaveMissing"/> is set then it will use backup for the <see cref="P:Eco.Core.Plugins.StorageManager.SaveName"/> if no save file exists.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.StorageManager.UnlockPersistAsync">
            <summary>Unlocks storage for writing and persists everything.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.StorageManager.PersistAsync">
            <summary> Persists all pending storages asynchronously. </summary>
        </member>
        <member name="M:Eco.Core.Plugins.StorageManager.LoadAndRemove``1(System.String,System.Action{``0,System.String})">
            <summary>Loads object and removes entries from <see cref="F:Eco.Core.Plugins.StorageManager.dataStore"/>. May be used during conversion pass from old zip entries to new zip entries.</summary>
        </member>
        <member name="M:Eco.Core.Plugins.StorageManager.InitializeAsync(System.Boolean)">
            <summary>Initializes <see cref="T:Eco.Core.Plugins.StorageManager"/>. May optionally disable backups if <paramref name="enableBackups"/> set to <c>false</c>.</summary>
        </member>
        <member name="T:Eco.Core.Plugins.TickSamples.TotalTimeTickSample">
            <summary> Tick Sampler to use for tick analysis. </summary>
        </member>
        <member name="T:Eco.Core.Properties.ChangeWatcher">
            <summary>The one and only service that should be used for the server to monitor updates of properties.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchProp(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watches a member called 'memberName' on object 'watch'. This member must be a property, and fody property notification is used to notify changes.
            Maintains subscription on 'subs' (though null can be passed in which case the subscription isnt tracked).</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.Unwatch(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged)">
            <summary>Finds the subscriptions using the given callback and removes it for the given watch</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchAllProps(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watches for any property change on a given object.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchPropOnAllInstances(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watch a given property on ALL instances of a given type.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchAllPropsOnAllInstances(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.Type,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watch ALL properties on ALL instances of a given type.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.UnwatchSubject(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged)">
            <summary>Go through the subscriptions and remove any that watch the given subject.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchEvent(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction,System.Action)">
            THREADSAFEACTION subscriptions.
            Pack of ThreadSafeAction watch/unwatch (rolled out so we can use mulitple params)
            <summary>Subscribe to a regular PropertyChangedBeforeAfterEventHandler and track it.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchEvent``1(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0},System.Action{``0})">
            <summary>Subscribe to a regular PropertyChangedBeforeAfterEventHandler and track it.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchEvent``2(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0,``1},System.Action{``0,``1})">
            <summary>Subscribe to a regular PropertyChangedBeforeAfterEventHandler and track it.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchEvent``3(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0,``1,``2},System.Action{``0,``1,``2})">
            <summary>Subscribe to a regular PropertyChangedBeforeAfterEventHandler and track it.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchEnumerable(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ITrackedEnumerable,System.Action)">
            <summary>Make a subscription to track an enumerable that implements the <see cref="T:Eco.Core.Utils.ITrackedEnumerable"/> interface and call the callback whenever its entries get changed.</summary>
            <param name="ss">The object that we want to add the subscription to.</param>
            <param name="enumerable">The enumerable that we want to watch.</param>
            <param name="callback">The action that will be called whenever the property that we're watching get changed.</param>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchPropInsideEnumerable(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ITrackedEnumerable,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Make a subscription to track a specified property for all the entries that are inside the specified enumerable (the enumerable must implement the <see cref="T:Eco.Core.Utils.ITrackedEnumerable"/> interface).</summary>
            <param name="ss">The object that we want to add the subscription to.</param>
            <param name="enumerable">The enumerable that we want to watch its entries properties.</param>
            <param name="propertyName">The name of the property that we want to track for all the entries.</param>
            <param name="callback">The action that will be called whenever the property that we're watching get changed.</param>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchAllPropInsideEnumerable(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ITrackedEnumerable,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Make a subscription to track all properties for all entries that are inside the specified enumerable (the enumerable must implement the <see cref="T:Eco.Core.Utils.ITrackedEnumerable"/> interface).</summary>
            <param name="ss">The object that we want to add the subscription to.</param>
            <param name="enumerable">The enumerable that we want to watch its entries properties.</param>
            <param name="callback">The action that will be called whenever the property that we're watching get changed.</param>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.Unwatch(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction,System.Action)">
            <summary>Unsubscribe, using the target and callback as handles.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.Unwatch``1(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0},System.Action{``0})">
            <summary>Unsubscribe, using the target and callback as handles.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.Unwatch``2(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0,``1},System.Action{``0,``1})">
            <summary>Unsubscribe, using the target and callback as handles.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.Unwatch``3(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},Eco.Core.Utils.ThreadSafeAction{``0,``1,``2},System.Action{``0,``1,``2})">
            <summary>Unsubscribe, using the target and callback as handles.</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchPropOnProp(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged,System.String,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Here we do a nested watch: we watch for a given property *on* an instance specified by another property.
            For example, settlement may want to watch when Settlement.Leader.MarkedupName changes.  This requires a nested watch,
            as it must trigger both
              1) when Leader changes or
              2) when Leader.MarkedupName changes.
            It also handles the weak-reference subscription and unsubscrition of all parts involved.
            Note: unlike WatchMember, 'subs' must be non-null, because tracking member-of-member subscriptions is always necessary</summary>
        </member>
        <member name="M:Eco.Core.Properties.ChangeWatcher.WatchAllPropsOnProp(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.ComponentModel.INotifyPropertyChanged,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watches for when a given member changes, and maintains a subscription to *every* property on that instance, removing old subscriptions.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.ChangeWatcherUtils.IsPropFodyNotifiable(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>See if a given property name on this type will be getting updates from fody</summary>
        </member>
        <member name="T:Eco.Core.Properties.Internal.GlobalPropertySubscription">
            <summary>Subscription tracking for wathing all instances.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.GlobalPropertySubscription.#ctor(System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Create a subscription to a given member on ALL instances of a given type.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.GlobalPropertySubscription.#ctor(System.Type,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Create a subscription to ALL members on ALL instances of a given type.</summary>
        </member>
        <member name="T:Eco.Core.Properties.Internal.PropertyChangedSubscription">
            <summary>A subscription that watches a property changing triggered by fody.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.PropertyChangedSubscription.#ctor(System.ComponentModel.INotifyPropertyChanged,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watch for a specific named property changing by subscribing to the event raised by fody.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.PropertyChangedSubscription.#ctor(System.ComponentModel.INotifyPropertyChanged,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Watch for ANY property changing, as raised by fody.</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.PropertyChangedSubscription.Unsubscribe">
            <summary>Unsubscribe, if our weak ref is still active (object wasnt deleted already).</summary>
        </member>
        <member name="M:Eco.Core.Properties.Internal.PropertyChangedSubscription.IsSubject(System.ComponentModel.INotifyPropertyChanged)">
            <summary>Return true if the instance being watched is the passed in value.</summary>
        </member>
        <member name="T:Eco.Core.Properties.ThreadSafeActionSubscription">
            <summary> A threadsafe action subscription. Stores the target and callback so it can be found be those too</summary>
        </member>
        <member name="T:Eco.Core.Properties.ThreadSafeActionSubscription`1">
            <summary> A threadsafe action subscription. Stores the target and callback so it can be found be those too</summary>
        </member>
        <member name="T:Eco.Core.Properties.ThreadSafeActionSubscription`2">
            <summary> A threadsafe action subscription. Stores the target and callback so it can be found be those too</summary>
        </member>
        <member name="T:Eco.Core.Properties.ThreadSafeActionSubscription`3">
            <summary> A threadsafe action subscription. Stores the target and callback so it can be found be those too</summary>
        </member>
        <member name="T:Eco.Core.Properties.TrackedListPropSubscription">
            <summary>Used to subscribe and track a specific property of different entries saved inside an enumerable that implement the <see cref="T:Eco.Core.Utils.ITrackedEnumerable"/> interface.</summary>
        </member>
        <member name="T:Eco.Core.Properties.TrackedListSubscription">
            <summary>Used to subscribe and track enumerables that implement the ITrackedList interface.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.DependsOnSubMemberAttribute">
            <summary>An override for fody's 'DependsOn' attirbute that allows watching a specific sub prop, and the prop or subprop could either be events.
            See wiki guide here: https://github.com/StrangeLoopGames/Eco/wiki/Watching-System /// </summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.DependsOnMemberAttribute">
            <summary>[PropertyChanged.DependsOn] will only perform triggers on properties. This attribute does the same, but can provide triggers on methods as well.
            It also can watch things besides props: events and anything notifying.
            See wiki guide here: https://github.com/StrangeLoopGames/Eco/wiki/Watching-System </summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.DependsOnMemberBaseAttribute">
            <summary>Abstract root to share an implementation for our watchers that trigger change notifications.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker">
            <summary>Interface for external invocation of <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker.InvokePropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Invokes <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event handlers.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.Internal.GenericTypeSubscriptions">
            <summary>Internal class used by <see cref="T:Eco.Core.PropertyHandling.PropertyChanges"/> for global subscriptions (per-property and all-properties) for generic types. Has reference to generic type definition subscriptions.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.Internal.TypeSubscriptions">
            <summary>Internal class used by <see cref="T:Eco.Core.PropertyHandling.PropertyChanges"/> for global subscriptions (per-property and all-properties).</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.TypeSubscriptions.Invoke(System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>Invokes all type subscriptions (both per property and for all properties).</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.TypeSubscriptions.Add(System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Adds <paramref name="handler"/> as callback for changes of <paramref name="propertyName"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.TypeSubscriptions.Remove(System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Removes <paramref name="handler"/> from callbacks for changes of <paramref name="propertyName"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.TypeSubscriptions.Add(Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Adds <paramref name="handler"/> as callback for any property changes.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.TypeSubscriptions.Remove(Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Removes <paramref name="handler"/> from any property changes handlers.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.rootType">
            <summary>The root type we're meant to watch.  May be differnet than the property/extension method target that we're assigned to.
            If null, try to get it from the context of the attribute instead.
            EX when you want a tooltip on Title to update when a derived type ElectedTitle's property changes.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.MemberName">
            <summary>Which property we're watching, or 'determine from context' if null.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.WatchAllMembers">
            <summary>If set, ignore the SubPropName and instead watch all properties on the root.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.SubMemberName">
            <summary>Which sub member we're watching, or none if null.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.WatchAllSubMembers">
            <summary>If set, ignore the SubMemberName and watch all sub properties.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.MemberTypeMustDerive">
            <summary>Only watch types that are derived from this specific class or interface.</summary>
            Ex. ElectedTitle has a property of type IAlias called EligibleCandidates (it can accept values of type User, ElectedTitle,...) but we only want to watch the property if it implement the IProposable interface.
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.TriggerCallbackWhenRootPropertyChanges">
            <summary>When watching sub members, do we also trigger the callback when the root property (which contains the submembers) changes?
            This needs to be 'off' in the case of DependsOnSubProp, since it's callback will fire a Property Changed notification, which, if we do
            on the root property change, will become infinitely recursive.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.OverridenType">
            <summary>
            This is used with <see cref="T:Eco.Core.PropertyHandling.TooltipAffectedByAttribute"/> and specifically when watching an event on a method that has a NewTooltip attribute and an override type.
            This can be removed when we move the NewTooltip to Eco.Core, which then we can just make a function as an extansion of <see cref="T:System.Reflection.MethodInfo"/>
            which give us the real root type of that method (Detect whether that method has a NewTooltip attribute and return the Override property.
            </summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.GetCallback(System.Reflection.MemberInfo,System.Type@)">
            <summary>Child class must define what this does.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.GetRootTypeAndMember(System.Reflection.MemberInfo)">
            <summary>Give the member we're an attribute on, determine what root type and property we're subscribing to.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.GetWatchedPropType(System.Reflection.MemberInfo)">
            <summary>Get the type of the property that we're watching.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.ObjectIsExpectedType(System.Object)">
            <summary>We check if the type of the object is what we are expecting using any specified conditions.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchBaseAttribute.PassEventFirstParamToCallback(System.Type,System.Type)">
            <summary>
            This is used when watching an event with a param to see whether we want to pass the param of that event to the callback or pass type of the root class instead.
            True  -> assign param.
            False -> assign type.
            </summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.Internal.WatchUtils">
            <summary>Utils for watching properties on properties.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.Internal.WatchUtils.AllInstanceMembersBindingFlags">
            <summary>Binding flags for getting all instance members (public, private and inherited)</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.RegisterWatching(System.Type[])">
            <summary>Adds global subscriptions for all types inherited from INotifyPropertyChanged and having properties with WatchSubMemberAttribute.
            Accepts list of types to register (or all, if empty).</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.RegisterWatchHandler(System.Reflection.MemberInfo,Eco.Core.PropertyHandling.Internal.WatchBaseAttribute)">
            <summary>Create subscriptions to global property change detection that will setup this watching attribute, and perform
            the desired callback.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.DoSubscribe(System.Reflection.MemberInfo,Eco.Core.PropertyHandling.Internal.WatchBaseAttribute,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler,System.Type)">
            <summary>Calls the given callback whenever the property designated by the passed attr changes.</summary>
            <param name="callback">The callback to call when that subproperty changes (or when the referencing property changes)</param>
            <param name="expectedCallbackParam">For sanity checks, we pass the parmater the callback takes, and make sure it matches what the subscription is providing.</param>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.SubscribeToPropertyOnInstance(Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler,System.Type,System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs,System.Reflection.PropertyInfo,System.Type,System.Boolean,System.String)">
            <summary>Subscribe to changes in a property's value, or triggers from a ThreadSafeAction, and return the subscription.</summary>
            <param name="callback">The callback that we want to get called when the watched property is changed.</param>
            <param name="expectedCallbackParam">The parameter the callback takes.</param>
            <param name="root">An instance of the root type that has the sub property that we want to watch.</param>
            <param name="args">Old and new value of the subProperty.</param>
            <param name="prop">The sub property info that we want to watch.</param>
            <param name="propType">The type of the sub property that we want to watch.</param>
            <param name="watchAllProps">When set to true, we watch all the sub properties of the root type instead of just the specified sub property.</param>
            <param name="debugIdentifier">Help identify the sub property when there's an error, usually it's "{rootType.name}.{rootMember.name}".</param>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.SubscribeITrackedList(System.Reflection.PropertyInfo,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Setup subscription to an enumerable that implement the ITrackedList interface.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.Internal.WatchUtils.GetMethodRealRootType(System.Reflection.MemberInfo,Eco.Core.PropertyHandling.Internal.WatchBaseAttribute)">
            <summary>If the method attribute has an override type we get that else we just get the extension/declaring type.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs">
            <summary><see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> extended with <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.Before"/> and <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.After"/> values. Both <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.Before"/> and <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.After"/> 
            will be null if not available.  We rename from the root 'property' to 'member' because this is used for methods as well.</summary>
        </member>
        <member name="P:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.HasBeforeAfter">
            <summary>Checks if <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.Before"/> and <see cref="F:Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs.After"/> values available.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.PropertyChanges">
            <summary>
            <see cref="T:Eco.Core.PropertyHandling.PropertyChanges"/> is a class for managing property subscriptions both global and per instance.
            <c>Global(Un)Subscribe</c> methods may be used for global subscriptions (for all-instances)
            and <see cref="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker,System.String,System.Object,System.Object)"/> should be used to fire both per-instance and global PropertyChanged events.
            Usually used in conjunction with Fody <c>PropertyChangedNotificationInterceptor.Intercept</c> which may be implemented as:
            <code>
            public static class PropertyChangedNotificationInterceptor2
            {
                public static void Intercept(INotifyPropertyChangedInvoker invoker, string propertyName, object? before, object? after) => PropertyChanges.FirePropertyChanged(invoker, propertyName, before, after);
            }
            </code>
            Read more about property changes in README.md.
            </summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker,System.String,System.Object,System.Object)">
            <summary>Fires both per-instance (using InvokePropertyChanged) and global property change events. If <paramref name="before"/> and <paramref name="after"/> both <c>null</c> it assumes that no before/after values available.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>Fires both per-instance (using InvokePropertyChanged) and global property change events.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(System.Object,System.String)">
            <summary>If <paramref name="source"/> is <see cref="T:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker"/> then invokes InvokePropertyChanged which fires per-instance property changes. Anyway fires global property change events.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(System.Object,System.String,System.Object,System.Object)">
            <summary>If <paramref name="source"/> is <see cref="T:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker"/> then invokes InvokePropertyChanged which fires per-instance property changes. Anyway fires global property change events.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.FirePropertyChanged(System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>If <paramref name="source"/> is <see cref="T:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker"/> then invokes InvokePropertyChanged which fires per-instance property changes. Anyway fires global property change events.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalSubscribe(System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Subscribes for <paramref name="propertyName"/> changes on all instances of <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalUnsubscribe(System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Unsubscribes from <paramref name="propertyName"/> changes on all instances of <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalSubscribe(System.Type,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Subscribes for all notified properties changes on all instances of <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalUnsubscribe(System.Type,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Unsubscribes from all notified properties changes on all instances of <paramref name="type"/>.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalSubscribeInternal(System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Subscribes for all notified properties/concrete property changes on all instances of <paramref name="type"/>. For internal usage.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GetOrAddTypeSubscriptions(System.Type)">
            <summary>Returns TypeSubscriptions mapped to type which then may be used for global subscriptions.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.GlobalUnsubscribeInternal(System.Type,System.String,Eco.Core.PropertyHandling.PropertyChangedBeforeAfterEventHandler)">
            <summary>Unsubscribes for all notified properties/concrete property changes on all instances of <paramref name="type"/>. For internal usage.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.PropertyChanges.IsNotifyingProperty(System.Reflection.PropertyInfo)">
            <summary>Return true if the property has an attribute that will make it notify through fody.</summary>
        </member>
        <member name="T:Eco.Core.PropertyHandling.TooltipAffectedByAttribute">
            <summary>Put on an extension method with NewTooltipAttribute to mark that tooltip part as dirty when CallWhenChangedAttribute.Property 
            changes in any instance of the extension method's type.</summary>
            <remarks>
            Can't be used when tooltip use CacheAs.User. See 'Tooltip.md' for more info.
            See wiki guide here: https://github.com/StrangeLoopGames/Eco/wiki/Watching-System
            Requirements:
            - Can use on static extension methods. No need to pass the type being watched if its the same as the 'this' for the extension method.
            - If you're watching an event with params on a tooltip that's using CacheAs.Instance then the event param type must be the tooltip parent (TO DO : we should
            make an assert for this when tooltips are moved to Core instead of Gameplay).
            </remarks>
        </member>
        <member name="T:Eco.Core.PropertyHandling.WatchSubMemberAttribute">
            <summary>When put on a property, will create subscriptions watching a given sub-property to change, and trigger the corresponding method or event.</summary>
            IE, CreditComponent has a property containing a BankAccount and it uses this attribute to call one of its own methods whenever MarkedUpName is changed.
            This attribute will both:
            - Watch when the BankAccount's property 'MarkedUpName' changes and trigger the callback
            - Watch when the BankAccount property itself changes, and update remove the subscription to the old BankAccount.MarkedUpName, and add a subscription
              to the new BankAccount.MarkedUpName.  Will also call the callback in this case.
            Either way declaring class should implement <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> and <see cref="T:Eco.Core.PropertyHandling.INotifyPropertyChangedInvoker"/> (usually auto-implemented by Fody).
            See wiki guide here: https://github.com/StrangeLoopGames/Eco/wiki/Watching-System
            <remarks>
            Declaring class must implement INotifyPropertyChanged, so that it can watch when the prop changes.
            Declaring class must also implement ISubscriptions, allowing this service to property track subscriptions when they are made and remove them upon destroy.
            </remarks>
        </member>
        <member name="F:Eco.Core.PropertyHandling.WatchSubMemberAttribute.Callback">
            <summary>The name of the method on 'this' that we want to call. Can be either an event or a method.</summary>
        </member>
        <member name="F:Eco.Core.PropertyHandling.WatchSubMemberAttribute.Flags">
            <summary>Flags customizing behavior of this attribute.</summary>
        </member>
        <member name="P:Eco.Core.PropertyHandling.WatchSubMemberAttribute.DontTriggerWhenRootPropSetToNull">
            <summary>When true callback won't be called when root property is set to null.</summary>
            <remarks>This flag can only be used when callback expects to receive new value of sub property as parameter and sub proeprty is of value type
            (so null can't be passed) and is mandatory in such cases to explicitly show that different behavior for value types will be used.</remarks>
        </member>
        <member name="M:Eco.Core.PropertyHandling.WatchSubMemberAttribute.#ctor(System.String,System.String,Eco.Core.PropertyHandling.SubPropWatcherFlag)">
            <summary>Whenever the given sub property is changed/triggered, call the given callback.</summary>
        </member>
        <member name="M:Eco.Core.PropertyHandling.WatchSubMemberAttribute.GetCallback(System.Reflection.MemberInfo,System.Type@)">
            <summary>Returns callback delegate based on the value of Callback field.</summary>
            <param name="memberWithAttribute">Member to which this attribute is applied.</param>
            <param name="expectedCallbackParam">Type of expected callback parameter if any.</param>
        </member>
        <member name="M:Eco.Core.PropertyHandling.WatchSubMemberAttribute.CheckNullSafety(System.Reflection.MemberInfo)">
            <summary>Makes sure we will never try to pass null as value for a value type parameter</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1">
            <summary>Custom <see cref="T:System.ComponentModel.TypeConverter"/> for converting derived types to and from strings for use with the Eco server configuration UI</summary>
            <typeparam name="TType">Base Interface to generated derrived options from.</typeparam>
            <remarks>
            To utilize the InterfaceDerivedTypesConverter for type selection create your property as normal then mark it with the TypeConverter attribute passing
            the type of the InterfaceDerivedTypesConverter as its first parameter.
            </remarks>
            <seealso cref="T:System.ComponentModel.ExpandableObjectConverter"/>
        </member>
        <member name="M:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Gets a value indicating whether this converter can convert an object in the
            given source type to a string using the specified context.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>Returns wether this converter can convert the object to specified type,  using the context specified.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1.CreateDerivedTypeInstance(System.String,System.Type)">
            <summary>
            Overridable method for creating the user selected <see cref="T:System.Type"/> instance. Intended for custom derived type converter
            implementations.
            </summary>
            <param name="name">Name of the derived type being created</param>
            <param name="derivedType">Type of the object that needs to be created</param>
            <returns>Newly created type instance or null if invalid</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1.GetDerivedTypeFromName(System.String)">
            <summary>Attempts to create a new derived type given the selected string name of the type.</summary>
            <param name="name">Name to use in identifying the type to instantiate</param>
            <returns>Newly instantiated type if found. Otherwise null</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Converters.InterfaceDerivedTypesConverter`1.GetStandardValues(System.ComponentModel.ITypeDescriptorContext)">
            <summary>Creates a <see cref="T:System.ComponentModel.TypeConverter.StandardValuesCollection"/> containing all the names of our derrived types for displaying to the user</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Converters.UniversalDateTimeConverter">
            <summary>
            Reads <see cref="T:System.DateTime"/> either with <see cref="T:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter"/> or with <see cref="T:Newtonsoft.Json.Converters.IsoDateTimeConverter"/>, but always serializes as <see cref="T:Newtonsoft.Json.Converters.IsoDateTimeConverter"/>.
            Required for transition between old JSON incompatible date serialization format and new ISO JSON compatible format. It will work with old configs, but new configs will be produced in valid format.
            </summary>
        </member>
        <member name="T:Eco.Core.Serialization.DataBlob">
            <summary> Contains named raw data for <see cref="T:Eco.Core.Serialization.DataStore"/>. </summary>
        </member>
        <member name="P:Eco.Core.Serialization.DataBlob.Name">
            <summary> Entry name. </summary>
        </member>
        <member name="P:Eco.Core.Serialization.DataBlob.Data">
            <summary> Raw data. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.DataStoreContentAccessorDelegate">
            <summary> Delegate for <see cref="M:Eco.Core.Serialization.DataStore.ContentAccessor.ExecuteAsync(Eco.Core.Serialization.DataStore.ExclusiveAccess,Eco.Core.Serialization.DataStoreContentAccessorDelegate)"/>. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.DataStore.ContentAccessor">
            <summary> <see cref="T:Eco.Core.Serialization.DataStore"/> content accessor which allows to perform safe <see cref="T:Eco.Core.Serialization.DataStore"/> modifications by other classes. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.ContentAccessor.UpdateEntry(System.String,Ionic.Zip.WriteDelegate)">
            <summary>Updates entry with <paramref name="name"/> with content written by <paramref name="writeDelegate"/>. Aware that <paramref name="writeDelegate"/> may be called multiple times!</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.ContentAccessor.DeleteEntry(System.String)">
            <summary> Deletes entry with given <paramref name="name"/> in <see cref="T:Eco.Core.Serialization.DataStore"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.DeleteEntry(System.String)">
            <summary> Deletes zip entry with given <paramref name="name"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.UpdateEntry(System.String,Ionic.Zip.WriteDelegate)">
            <summary> Opens existing or creates new zip entry with specified <paramref name="name"/>. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.DataStore.ExclusiveAccess">
            <summary>
            Class which should be used for exclusive access to <see cref="F:Eco.Core.Serialization.DataStore.ExclusiveAccess.DataStore"/>.
            May be obtained with <see cref="M:Eco.Core.Serialization.DataStore.WaitExclusiveAccess"/> or <see cref="M:Eco.Core.Serialization.DataStore.WaitExclusiveAccessAsync"/> to get it with exclusive access.
            You can also create with <see cref="M:Eco.Core.Serialization.DataStore.ExclusiveAccess.#ctor(Eco.Core.Serialization.DataStore)"/> constructor (no obtained state) and then <see cref="M:Eco.Core.Serialization.DataStore.ExclusiveAccess.Wait(System.Threading.CancellationToken)"/> or <see cref="M:Eco.Core.Serialization.DataStore.ExclusiveAccess.WaitAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.ExclusiveAccess.PurgeAsync(System.String)">
            <inheritdoc cref="M:Eco.Core.Serialization.DataStore.PurgeAsync(Eco.Core.Serialization.DataStore.ExclusiveAccess,System.String)"/>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.ExclusiveAccess.LoadAndRemove``1(System.String,System.Action{``0,System.String})">
            <inheritdoc cref="M:Eco.Core.Serialization.DataStore.LoadAndRemove``1(Eco.Core.Serialization.DataStore.ExclusiveAccess,System.String,System.Action{``0,System.String})"/>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.InitEntryDictionaries">
            <summary>Init entry dictionaries with reflection, because default <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)"/> is very very slow for archives with big number of files. It also doesn't allow to remove entries with Windows paths.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.RemoveEntryFromDictionaries(System.String)">
            <summary>Directly removes entry from <see cref="T:Ionic.Zip.ZipFile"/> entry dictionaries. Used for optimization purposes and in cases where it isn't possible to remove entry because of path normalization (like Windows path).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.FixWindowsPaths">
            <summary>There known issue with DotNetZip which causes to duplicate zip entries if they uses \ symbol as separator. It isn't possible to fix with API, so we are using reflection here for direct collections modification.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.Flush">
            <summary>Flushes changes to disk if any updates and enough time since last save.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.LoadFileAsStream(System.String)">
            <summary>Load a singular entry from the zip file.</summary>?
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.LoadFileAsStreamAsync(System.String)">
            <summary>Loads file asynchronously from <see cref="T:Eco.Core.Serialization.DataStore"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.LoadFileAsStringAsync(System.String)">
            <summary>Loads file asynchronously from <see cref="T:Eco.Core.Serialization.DataStore"/> as a string.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.LoadFileAsStream(Eco.Core.Serialization.DataStore.ExclusiveAccess,System.String)">
            <summary>Loads file as <see cref="T:System.IO.MemoryStream"/> with <paramref name="exclusiveAccess"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.FolderExists(System.String)">
            <summary> Checks if non-empty <paramref name="folder"/> exists in the zip archive. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.GetFileNames(System.String)">
            <summary> Returns file names in zip archive's <paramref name="folder"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.GetFileEntriesInFolder(System.String)">
            <summary> Returns all <see cref="T:System.IO.Compression.ZipArchiveEntry"/> for files in the <paramref name="folder"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.WriteAsync(System.String,System.String)">
            <summary>Writes <paramref name="content"/> to the entry with name <paramref name="fileName"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DataStore.LoadAndRemove``1(Eco.Core.Serialization.DataStore.ExclusiveAccess,System.String,System.Action{``0,System.String})">
            <summary>Loads object and removes entries from zip-archive. May be used during conversion pass from old zip entries to new zip entries.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.IObjectReference">
            <summary>Used during deserialization for object references for late resolving (i.e. from <see cref="T:Eco.Core.Systems.IRegistrar"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.IObjectReference.GetReferencedObject">
            <summary>Gets referenced object. Usually only available when all object deserialized and fixups may be applied.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.IObjectReference.TryGetReferencedObject(System.Object@)">
            <summary>Tries to get referenced object. Returns <c>false</c> if that not possible.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.IObjectReferenceService">
            <summary>Service used by serializers for different reference types (like <see cref="T:Eco.Core.Systems.IHasID"/> or <see cref="T:Eco.Core.Systems.IHasReferenceableSerializableID"/>).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.IObjectReferenceService.GetId(System.Object)">
            <summary>Returns identifier for <paramref name="instance"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.IObjectReferenceService.MakeReference(System.Type,System.Int32)">
            <summary>Makes <see cref="T:Eco.Core.Serialization.Internal.IObjectReference"/> for <paramref name="type"/> and <paramref name="id"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.SerializationMeta">
            <summary>Meta data for serialization like version, schema etc.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.SerializationMeta.LoadAsync(Eco.Core.Serialization.DataStore)">
            <summary>Loads serialization meta from <paramref name="dataStore"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.SerializationMeta.SaveAsync(Eco.Core.Serialization.DataStore)">
            <summary>Saves serialization meta to <paramref name="dataStore"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.SerializationMeta.FlushDirtyFiles">
            <summary>Flushes all modified meta files as pairs of file name and content.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.TransientHandle">
            <summary><see cref="T:Eco.Core.Serialization.IPersistent"/> implementation for transient (non-serialized) objects. <see cref="P:Eco.Core.Serialization.IStorage.StorageHandle"/> may be used for modification locks and instead of null handling it is better to have such a transient handle which will prevent concurrent modifications, but won't serialize the object.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.UniversalIdReference">
            <summary>Reference to <see cref="T:Eco.Core.Systems.UniversalIDs"/> object.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Internal.UniversalIdReferenceService">
            <summary><see cref="T:Eco.Core.Serialization.Internal.IObjectReferenceService"/> for <see cref="T:Eco.Core.Systems.IHasReferenceableSerializableID"/> objects.</summary>
            <inheritdoc cref="T:Eco.Core.Serialization.Internal.IObjectReferenceService"/>
        </member>
        <member name="M:Eco.Core.Serialization.Internal.ZipBlob.GetAndEraseName">
            <inheritdoc cref="M:Eco.Core.Serialization.IPersistent.GetAndEraseName"/>
        </member>
        <member name="P:Eco.Core.Serialization.IPersistent.Name">
            <summary> Persistent name. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.IPersistent.GetAndEraseName">
            <summary> Returns current name and erases it as atomic operation. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.AggregateMigration">
            <summary>Migration which aggregates multiple migrations into one. Migrations applied after each other for every compatible type.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ArrayEntriesMigration">
            <summary>Array migration which applies migration to every element and modifies collection schema type if required. May be supplied with optional filter for migrated entries.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute">
            <summary>
            Attribute for marking class as <see cref="T:Eco.Core.Serialization.Migrations.MigrationType"/> (read more about migration types in the <see cref="T:Eco.Core.Serialization.Migrations.MigrationType"/> documentation).
            Can be used in two ways:
            - As <see cref="T:Eco.Shared.Serialization.SerializedAttribute"/> type attribute, then the attributed type will be used to represent new type if <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> not specified.
            The representing type shouldn't exactly match target type, but only have necessary fields. This type may not even existing in final schema, but used as intermediate type
            (i.e. if you have Schema v1 with type Foo and need to migrate to Schema v3 with type Baz, but in Schema v2 type Foo was renamed to Bar and then to Baz in v3. In this case you may need to migrate first to MigrationType("Bar", SinceVersion=2) and then you will be able to migrate from Bar to Baz for version v3).
            - As migration class attribute (the type with <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigrationAttribute"/>). In most cases when used with migration <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType"/> is same as <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> as well as <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.SinceVersion"/>. In that cases you can just use constructor with type parameter which sets <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> to same value as <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType"/> and <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.SinceVersion"/> will be used from <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigrationAttribute"/>.
            It will help to avoid copy paste and potential errors when these values changes not synced.
            </summary>
        </member>
        <member name="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType">
            <summary>Schema type for the migration type. May be different from <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> (i.e. class[Foo] as schema type and FooV1 as migration type).</summary>
        </member>
        <member name="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.SinceVersion">
            <summary>The first version when this type was added. Can't be used with migrations before that version. If not specified then will be populated from <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigrationAttribute"/> on same type.</summary>
        </member>
        <member name="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType">
            <summary>The type representing <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/>. May be same as <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType"/> or it's simplified version. Also may represent intermediate type which existed between one of previous supported schema versions and latest schema version.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.#ctor(System.Type)">
            <summary>Sets both <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType"/> and <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> from <paramref name="targetType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.#ctor(System.String)">
            <summary>Sets <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.TargetSchemaType"/> from <paramref name="classNameOrSchemaType"/>. <see cref="P:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute.MigrationType"/> should be specified explicitly or will use attributed type.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ClassMigrationBase.MigrateInstance(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>
            Migrates an instance with provided <paramref name="context"/>.
            It may modify <paramref name="context"/> with one of following migration results:
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceTypeName"/> != null means that binary content was fully consumed and a reference should be serialized instead. It should contains the referenced object id in <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceId"/>;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified and output schema is a class schema, it means that original class binary data was replaced with another class binary data and it should use new object serializer;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified and output schema is the cached serializer schema, it means that original binary content was consumed and object instance created and cached for upcoming deserialization call;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified, but output schema not class or cached object, it means that <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> contains compatible binary data. If reader wasn't modified then it will be reset to initial position.
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> not modified, if <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> modified then it should be re-serialized with original serializer or just reset reader position otherwise.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ClassMigrationBase.MigrateReference(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>
            Migrates an reference with provided <paramref name="context"/>.
            It may modify <paramref name="context"/> with one of following migration results:
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceTypeName"/> != null means that binary content was fully consumed and a reference should be serialized instead. It should contains the referenced object id in <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceId"/>;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified and output schema is a class schema, it means that original class binary data was replaced with another class binary data and it should use new object serializer;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified and output schema is the cached serializer schema, it means that original binary content was consumed and object instance created and cached for upcoming deserialization call;
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> modified, but output schema not class or cached object, it means that <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> contains compatible binary data. If reader wasn't modified then it will be reset to initial position.
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> not modified, if <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> modified then it should be re-serialized with original serializer or just reset reader position otherwise.
            </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ClassRemoveMigration">
            <summary> Migration for a removed class which allows to invoke <see cref="F:Eco.Core.Serialization.Migrations.ClassRemoveMigration.onRemove"/> callback for removed instances members data. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ClassRemoveMigration.MigrateInstance(Eco.Core.Serialization.Migrations.MigrationContext)">
            <inheritdoc cref="M:Eco.Core.Serialization.Migrations.ClassMigrationBase.MigrateInstance(Eco.Core.Serialization.Migrations.MigrationContext)"/>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.CollectionEntriesMigration">
            <summary>Abstract collection migration (i.e. array or list).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.CollectionEntriesMigration.MigrateContent(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Migrates binary content. If migration not performed (collection is <c>null</c> or empty) then returns <c>false</c>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.CollectionEntriesMigration.MigrateElements(Eco.Core.Serialization.Migrations.MigrationContext,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
            <summary>Migrate elements from <paramref name="reader"/> to <paramref name="writer"/>. Returns new number of migrated elements (passed by <see cref="F:Eco.Core.Serialization.Migrations.CollectionEntriesMigration.filter"/>).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration.AddKeyOutputGenerator(System.Func{System.Collections.Generic.IDictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})">
            <summary>
            Adds key output generator modification. <paramref name="keyGenerator"/> generates <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> for an entry key.
            <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.DataInputs"/> provided as second argument and may be used for accessing other registered data inputs.
            <example>
            Migration from list of CurrencyHolding to Dictionary with Currency.SerializedId as a key.
            <code><![CDATA[
            var dm = new DataMigration(typeof(BankAccount));
            var holdingsMigration = new CollectionToDictionaryDataMigration(SchemaUtils.GetSchemaType(typeof(CurrencyHolding)));
            var serializedId      = holdingsMigration.ItemInput.Member("Currency").Member("SerializedID");
            holdingsMigration.AddKeyOutputGenerator(inputs => inputs[serializedId]);
            dm.MigrateMember(nameof(BankAccount.CurrencyHoldings), holdingsMigration);
            ]]></code></example>
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration.AddKeyOutputGenerator``1(System.Func{System.Collections.Generic.IDictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},``0})">
            <summary>Same as <see cref="M:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration.AddKeyOutputGenerator(System.Func{System.Collections.Generic.IDictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})"/>, but generates a value instead of <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration.MigrateEntries(System.Int32,Eco.Core.Serialization.Migrations.MigrationContext,System.IO.BinaryWriter)">
            <summary>Migrates Collection to Dictionary entries. Number of entries provided as <paramref name="count"/>. Migrated content written to <paramref name="writer"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration">
            <summary> Migration from base type to multiple concrete types based on object's field values. If you need to migrate only by single field you can use simplified <see cref="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration`1"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ConcreteTypeMigration.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.Object[],System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration"/> class.
            It will convert every class of <paramref name="baseTypeName"/> into more specific (concrete) type using field values of <paramref name="fieldNames"/>.
            For every migrated object it will invoke <paramref name="typeMapper"/> with array of values for <paramref name="fieldNames"/> in same order and the function should return new type name.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ConcreteTypeMigration.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput[],System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration"/> class.
            It will convert every class of <paramref name="baseTypeName"/> into more specific (concrete) type using <paramref name="fieldNames"/> (members of the object).
            For every migrated object it will invoke <paramref name="typeMapper"/> with array of <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> for <paramref name="fieldNames"/> in same order and the function should return new type name.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ConcreteTypeMigration.MigrateInstance(Eco.Core.Serialization.Migrations.MigrationContext)">
            <inheritdoc cref="M:Eco.Core.Serialization.Migrations.ClassMigrationBase.MigrateInstance(Eco.Core.Serialization.Migrations.MigrationContext)"/>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration`1">
            <summary> Migration from base type to multiple concrete types by single (discriminator) field value. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ConcreteTypeMigration`1.#ctor(System.String,System.String,System.Func{`0,System.String})">
            <summary> Initializes a new instance of the <see cref="T:Eco.Core.Serialization.Migrations.ConcreteTypeMigration`1"/> class. </summary>
            <param name="baseTypeName">Base type name (from which concrete types will be expanded).</param>
            <param name="discriminatorName">Name of property or field in base object which will be used to determine concrete type name with typeMapper.</param>
            <param name="typeMapper">Function receives discriminator value and returns concrete type name evaluated from discriminator.</param>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigration">
            <summary>Data migration class performs data level modifications (change member type, migrate member, update member, rename member, delete member etc).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.#ctor">
            <summary>Internal <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> constructor not compatible with any type. Intended to be used for nested migrations (like member migrations).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.AddPrecondition``1(System.String,System.Predicate{``0})">
            <summary>Adds pre-condition for data migration. If pre-condition fails then migration will not be applied.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.AddPrecondition(System.Collections.Generic.IEnumerable{System.String},System.Predicate{System.Object[]})">
            <summary>Adds pre-condition for data migration. If pre-condition fails then migration will not be applied.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.AddPrecondition(Eco.Core.Serialization.Migrations.DataMigrations.IDataInput[],System.Predicate{System.Object[]})">
            <summary>Adds pre-condition for data migration. If pre-condition fails then migration will not be applied.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.UpdateMember``2(System.String,System.Func{``0,``1})">
            <summary>Updates member by converting old value to new value. Member schema type changes accordingly.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.UpdateMemberFromDataInput``1(System.String,Eco.Core.Serialization.Migrations.DataMigrations.IDataInput[],System.Func{Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput[],``0})">
            <summary> Updates member using <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> as original value. It produces value of <typeparamref name="TDst"/> type. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigration.ChangeSchemaType(System.String)">
            <summary>Changes class schema type to <paramref name="newSchemaType"/>. I.e. after all members converted you may decide to convert class itself to another type.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.DataInput">
            <summary>
            <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.DataInput"/> defines input for migration which optionally may have own member inputs. During migration it may <see cref="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.Read(Eco.Core.Serialization.Migrations.MigrationManager,System.IO.BinaryReader,System.IO.Stream,Eco.Core.Serialization.Serializers.ISerializer,System.Collections.Generic.Dictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})"/> from <see cref="T:System.IO.BinaryReader"/> <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> for itself and for all own members and update data mapping.
            Using data inputs let you avoid full objects deserialization (and so delay it until actual deserialization stage keeping it binary compatible with migrations for newer versions).
            I.e. you need to add a comment containing creator id to some entity. With data input it can be done like:
            <code><![CDATA[
            this.AddDataMigration(typeof(SomeType), dm => {
                var creatorId = dm.Member("Creator").ReferenceId();
                dm.AddMember<string>("Comment", new[] { creatorId }, inputs => $"Creator ID: {inputs[0].Value}");
            });
            ]]></code>
            If you then have another migration for <c>SomeType</c> then it will work just fine with new serialized content containing Comment field.
            
            Without data inputs you need to do it hacky way like
            <code><![CDATA[
            new ObjectInstanceMigration<SomeType, SomeType>(typeName, obj => {
                SimpleFixups.Add(() => obj.Comment = $"Creator ID: {obj.Creator.Value}");
            });
            ]]></code>
            It may look simpler, but it makes this migration incompatible with any further migration. I.e. if you then have new migration which uses Comment value for something else then you need to
            modify old migration to do the update in SimpleFixup block in addition to new migration to make it compatible with different save versions.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.Member(System.String)">
            <summary>Input's member. Only valid for class/struct instance inputs.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.ReferenceId">
            <summary>Input's reference id. Only valid for inputs representing serialized references.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.Read(Eco.Core.Serialization.Migrations.MigrationManager,System.IO.BinaryReader,System.IO.Stream,Eco.Core.Serialization.Serializers.ISerializer,System.Collections.Generic.Dictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})">
            <summary>Reads input and nested inputs (for <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.members"/> or <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.referenceId"/>) from <paramref name="reader"/> and puts to <paramref name="data"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.ReadReferenceHeader(System.IO.BinaryReader,Eco.Core.Serialization.Serializers.ISerializer)">
            <summary>Reads serialized object header and returns <see cref="T:Eco.Core.Serialization.Serializers.ObjectSerializer"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.DataInput.ReadObjectHeader(Eco.Core.Serialization.Migrations.MigrationManager,System.IO.BinaryReader,Eco.Core.Serialization.Serializers.ISerializer)">
            <summary>Reads serialized object header and returns <see cref="T:Eco.Core.Serialization.Serializers.ObjectSerializer"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.IDataModification.Apply(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>
            Applies modification to `data`.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.IEntryDataModification">
            <summary>Data modification for an entry of dictionary or collection.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.IEntryDataModification.ModifyEntry(System.Collections.Generic.Dictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})">
            <summary>Modifies <paramref name="dataInputs"/> for a collection or dictionary entry.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataInput">
            <summary>Represents class member data input.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification">
            <summary>Base class for data member modifications (update, add, migrate, remove etc). Used in <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification.Apply(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Applies member modification to data object context.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification.GenerateOutput(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Generates data member output value after modification applied.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification`1">
            <summary>Base class for data member modifications with known output value type. Used in <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification`1.ReplaceWithCachedObjectsSerializerIfNeeded(Eco.Core.Serialization.Migrations.MigrationManager,Eco.Core.Serialization.Serializers.ISerializer)">
            <summary>Once <typeparamref name="TOutput"/> instantiated it is unsafe to serialize it back again to avoid copies creation, especially for singletons. Instead <see cref="T:Eco.Core.Serialization.Serializers.CachedObjectSerializer"/> should be used which saves an instance in memory and serializes just reference to it.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification`1.TryGenerateValue(System.Collections.Generic.Dictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},`0@)">
            <summary>Tries to generate value for data member. Returns <c>false</c> if value can't be generated and member should be removed.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberNameChangeDataModification">
            <summary>Rename member data modification.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.MigrationDataModification">
            <summary><see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification"/> which applies modification to member with custom <see cref="T:Eco.Core.Serialization.Migrations.IMigration"/>.</summary>
            <inheritdoc cref="T:Eco.Core.Serialization.Migrations.DataMigrations.MemberDataModification"/>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification">
            <summary>Modification with generates <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> with <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification.generateOutput"/> function for specified <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification.dataInput"/>. May be used by <see cref="T:Eco.Core.Serialization.Migrations.DictionaryDataMigration"/> or <see cref="T:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration"/> for key/value data generation.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification`1">
            <summary>Modification with generates <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/> for value of type <typeparamref name="TOutput"/> with <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification`1.generateOutput"/> function for specified <see cref="F:Eco.Core.Serialization.Migrations.DataMigrations.OutputEntryDataModification`1.dataInput"/>. May be used by <see cref="T:Eco.Core.Serialization.Migrations.DictionaryDataMigration"/> or <see cref="T:Eco.Core.Serialization.Migrations.CollectionMigrations.CollectionToDictionaryDataMigration"/> for key/value data generation.</summary>
        </member>
        <member name="P:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput.Count">
            <summary>Returns count of elements for Data Input value. For string it will be length of string, for enumerable or array number of elements in collection.
            If instance is <c>null</c> then return has null value. This way it let to get elements count without objects allocation and instantiation.
            </summary>
            <exception cref="T:System.NotSupportedException">When doesn't know how to get length for <see cref="P:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput.Serializer"/>.</exception>
        </member>
        <member name="P:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput.StringValue">
            <summary> Represents Data Input value as string. Currently only implemented for enums and strings. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DataMigrations.SchemaTypeChangeModification">
            <summary><see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.IDataModification"/> which changes schema type of data object itself (not one of it's members).</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryDataMigration">
            <summary>
            Migration for both key and value. Original key and value may be accessed with <see cref="P:Eco.Core.Serialization.Migrations.DictionaryDataMigration.KeyInput"/> and <see cref="P:Eco.Core.Serialization.Migrations.DictionaryDataMigration.ValueInput"/>.
            It let you manipulate with Dictionary data at binary level similar way as <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> works. With data inputs for key and value you can
            access serialized data in binary form and use it for key and value generation. Migration itself doesn't define default modifications, but instead
            modifications should be added with methods like <see cref="M:Eco.Core.Serialization.Migrations.DictionaryDataMigration.AddKeyTransform(System.Func{System.Collections.Generic.IDictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DictionaryDataMigration.AddKeyTransform(System.Func{System.Collections.Generic.IDictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput})">
            <summary>
            Adds key transform modification. <paramref name="keyTransform"/> converts data input for a key to new key data input. <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.DataInputs"/> provided as second argument and may be used for accessing other registered data inputs.
            <example><code><![CDATA[
            var dm = new DataMigration(typeof(BankAccount));
            var holdingsMigration = new DictionaryDataMigration("int", SchemaUtils.GetSchemaType(typeof(Currency)));
            var serializedId      = holdingsMigration.ValueInput.Member("Currency").Member("SerializedID");
            holdingsMigration.AddKeyTransform(inputs => inputs[serializedId]);
            dm.MigrateMember(nameof(BankAccount.CurrencyHoldings), holdingsMigration);
            ]]></code></example>
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.DictionaryDataMigration.MigrateEntries(System.Int32,Eco.Core.Serialization.Migrations.MigrationContext,System.IO.BinaryWriter)">
            <summary>Migrates Dictionary entries. Number of entries provided as <paramref name="count"/>. Migrated content written to <paramref name="writer"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryExtendMigration">
            <summary>Migration extending dictionary with new items. Items should be generated with provided function.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryKeyMigration`2">
            <summary>Migrates all dictionary keys to new key values using <see cref="F:Eco.Core.Serialization.Migrations.DictionaryKeyMigration`2.converter"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryMigrations.DictionaryEntriesMigration">
            <summary>Base class for for dictionary entries migrations. Supports items filtering, but can't convert empty dictionary to non-empty.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryMigrations.DictionaryMigration">
            <summary>Base class for dictionary migrations. Initializes schema types and key/value serializers.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DictionaryMigrations.DictionaryValueMigration`2">
            <summary>Migrates all dictionary values to new value using <see cref="F:Eco.Core.Serialization.Migrations.DictionaryMigrations.DictionaryValueMigration`2.converter"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.DummyMigration">
            <summary>
            This migration may be used if you don't actually want to do any migration logic, but want to include this type in migration chain (to process attributes etc).
            </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.EnumerableEntriesMigration">
            <summary>Enumerable collection migration which applies migration to every element and modifies collection schema type if required. May be supplied with optional filter for migrated entries.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.IClassMigration">
            <summary>Base interface for all class migrations. Shouldn't be used directly, instead use <see cref="T:Eco.Core.Serialization.Migrations.IInstanceMigration"/> or <see cref="T:Eco.Core.Serialization.Migrations.IReferenceMigration"/> or both.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ClassMigrationExtensions.IsCompatibleContext(Eco.Core.Serialization.Migrations.IClassMigration,Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Checks if <see cref="T:Eco.Core.Serialization.Migrations.IClassMigration"/> is compatible with <paramref name="context"/>. It compatible if either it's compatible types matches context schema type or reference type name.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.IMigration">
            <summary>
            Base migration class.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.IMigration.Migrate(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>
            Performs migration using current MigrationContext.
            <see cref="M:Eco.Core.Serialization.Migrations.IMigration.Migrate(Eco.Core.Serialization.Migrations.MigrationContext)"/> method should follow a contract:
            - It can only modify <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> and <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/>.
            - <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Schema"/> may only be modified with <see cref="M:Eco.Core.Serialization.Migrations.MigrationManager.CreateSchema(System.String)"/> or other similar methods (no new instance creation!)
            - If <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.Reader"/> modified then it should fully consume migrated content from original reader, otherwise it should set the reader at initial read position.
            General rule is to always return a reader positioned at beginning of serialized content.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.InstanceMigration">
            <summary>
            Base class for instance migrations. This kind of migration doesn't care about class headers, but only migrates instance content (fields, properties etc).
            <see cref="T:Eco.Core.Serialization.Migrations.ClassMigrationBase"/> takes are about nullability flags and other meta info. It also constructs serialized header from output schema.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.InstanceMigration.#ctor(System.String)">
            <summary>Constructs new <see cref="T:Eco.Core.Serialization.Migrations.InstanceMigration"/> which works with <paramref name="compatibleType"/>. <paramref name="compatibleType"/> is either schema type or type name.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.InstanceMigration.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Constructs new <see cref="T:Eco.Core.Serialization.Migrations.InstanceMigration"/> which works with <paramref name="compatibleTypes"/>. <paramref name="compatibleTypes"/> is either schema types or type names or mix.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.IPostLoadMigration">
            <summary>Migration which performs some actions <see cref="M:Eco.Core.Serialization.Migrations.IPostLoadMigration.OnPostLoad"/>. Call to <see cref="M:Eco.Core.Serialization.Migrations.IPostLoadMigration.OnPostLoad"/> adds to <see cref="F:Eco.Core.Serialization.Serializers.ClassSerializer.PostLoadMethods"/> if migration version higher than save version.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.IPostLoadMigration.OnPostLoad">
            <summary>Callback for post-load migration actions.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.IReferenceMigration">
            <summary>Interface for object References migrations. I.e. for <see cref="T:Eco.Core.Serialization.Migrations.ClassRenameMigration"/> you need it to change reference type.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.IReferenceMigration.MigrateReference(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Migrates <paramref name="context"/> containing information about reference: <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceTypeName"/> and <see cref="P:Eco.Core.Serialization.Migrations.MigrationContext.ReferenceId"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ITypeMigration">
            <summary>Migration may implement the interface if it supports type migration (i.e. when type renamed).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ITypeMigration.MigrateType(System.String)">
            <summary>Migrates <paramref name="typeName"/> and returns new type name.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.KeyToReferenceMigration`2">
            <summary>Migrates a key to reference which have to be resolved by the key using <see cref="F:Eco.Core.Serialization.Migrations.KeyToReferenceMigration`2.referenceResolver"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.MappedReferenceMigration`1">
            <summary>Migration for mapping from reference ID to object with <see cref="F:Eco.Core.Serialization.Migrations.MappedReferenceMigration`1.mapper"/> instead of standard reference resolve logic.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.MigrationCollection">
            <summary>Collection of migrations. Unlike <see cref="T:Eco.Core.Serialization.Migrations.AggregateMigration"/> these migrations are unordered and may be applied independently.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationCollection.AddMigration(Eco.Core.Serialization.Migrations.IClassMigration)">
            <summary>Add <paramref name="migration"/> to the collection.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationCollection.AddDataMigration``1(System.Action{Eco.Core.Serialization.Migrations.DataMigration})">
            <summary>Add new <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> for type <typeparamref name="T"/> to the collection. <paramref name="configure"/> action may be used to add data modifications to the migration.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationCollection.AddDataMigration(System.Type,System.Action{Eco.Core.Serialization.Migrations.DataMigration})">
            <summary>Add new <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> for type <paramref name="type"/> to the collection. <paramref name="configure"/> action may be used to add data modifications to the migration.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationCollection.AddDataMigration(System.String,System.Action{Eco.Core.Serialization.Migrations.DataMigration})">
            <summary>Add new <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> for type name or schema type to the collection. <paramref name="configure"/> action may be used to add data modifications to the migration.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.MigrationManager">
            <summary>Class responsible for migration stuff. It holds migrations, migration types for different versions and can apply them.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddMigrations(System.Double,System.Collections.Generic.IEnumerable{Eco.Core.Serialization.Migrations.IClassMigration})">
            <summary>Adds all migrations from enumerable with same <paramref name="sinceVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddInstanceMigration(System.Double,Eco.Core.Serialization.Migrations.IInstanceMigration)">
            <summary>Adds <see cref="T:Eco.Core.Serialization.Migrations.IInstanceMigration"/> which will be applied <paramref name="sinceVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddReferenceMigration(System.Double,Eco.Core.Serialization.Migrations.IReferenceMigration)">
            <summary>Adds <see cref="T:Eco.Core.Serialization.Migrations.IReferenceMigration"/> which will be applied <paramref name="sinceVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddTypeMigration(System.Double,Eco.Core.Serialization.Migrations.ITypeMigration)">
            <summary>Adds <see cref="T:Eco.Core.Serialization.Migrations.ITypeMigration"/> which will be applied <paramref name="sinceVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddMigratedType(System.Double,Eco.Core.Serialization.Migrations.Attributes.MigratedTypeAttribute)">
            <summary>Adds <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigratedTypeAttribute"/> which will be used to access erased information for migrated type (i.e. if it was struct and was changed to class or vice versa).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.IsMigrationOnlyType(System.Type)">
            <summary>Checks if <paramref name="type"/> is a type which only used during migration. Such a type should be fully serialized instead of <see cref="P:Eco.Core.Serialization.Migrations.MigrationManager.CachedObjectsSerializer"/> usage.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.TryCreateMigrationChainSerializer(System.String,Eco.Core.Serialization.SerializerSchema,Eco.Core.Serialization.Serializers.ISerializer@)">
            <summary>Tries to create <see cref="T:Eco.Core.Serialization.Serializers.MigrationChainSerializer"/>. Success if there any registered migrations for <paramref name="schemaType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddSerializers">
            <summary>Add extra serializers for <see cref="T:Eco.Core.Serialization.Migrations.MigrationManager"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.MigrateType(System.String)">
            <summary>Migrates <see cref="T:System.Type"/> if it was renamed.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.MigrateTypeInternal(System.String@,System.Double@,System.Collections.Generic.IEnumerable{Eco.Core.Serialization.Migrations.VersionedObject{Eco.Core.Serialization.Migrations.ITypeMigration}})">
            <summary>Migrates <paramref name="typeName"/> to new type name using <paramref name="migrations"/>. It updates <paramref name="typeName"/> and <paramref name="version"/> as result. Returns <c>true</c> if migration fully finished.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.GetSerializerFromSchemaType(System.String)">
            <summary>Tries to find serializer for <paramref name="schemaType"/>. If not exists then returns default <see cref="P:Eco.Core.Serialization.Migrations.MigrationManager.ObjectSerializer"/> for class schema types or throws exception.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.GetOrCreateSerializerFromSchemaType(System.String)">
            <summary>Tries to find serializer for <paramref name="schemaType"/>. If not exists then either will try to create new serializer for container types (dictionary or collection) or returns default <see cref="P:Eco.Core.Serialization.Migrations.MigrationManager.ObjectSerializer"/> for class schema types.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.DecodeObject(Eco.Core.Serialization.Migrations.MigrationContext)">
            <summary>Migrates <paramref name="context"/> and returns <see cref="T:Eco.Core.Serialization.DecodedObject"/> (either reference or instance).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.Migrate(Eco.Core.Serialization.Migrations.MigrationContext,System.Nullable{System.Double})">
            <summary>Migrates <paramref name="context"/> up to <paramref name="tillVersion"/> if specified or to latest version.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.Migrate(Eco.Core.Serialization.Migrations.MigrationContext,System.Action{Eco.Core.Serialization.Migrations.IInstanceMigration,Eco.Core.Serialization.Migrations.MigrationContext},System.Action{Eco.Core.Serialization.Migrations.IReferenceMigration,Eco.Core.Serialization.Migrations.MigrationContext},System.Nullable{System.Double})">
            <summary>
            Migrates content with <paramref name="context"/> up to <paramref name="tillVersion"/> (if specified). Can be used by other migrations (like <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/>) which applies member modifications to members which have earlier version(s) migrations.
            Uses provided <paramref name="migrateInstance"/> and <paramref name="migrateReference"/> actions for appropriate migrations. Migration may be performed for object content only or who whole object and so it may require different migrate actions.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.DecodeObject(Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.IO.BinaryReader)">
            <summary>
            Decodes object using provided schema.
            </summary>
            <param name="schema">schema.</param>
            <param name="reader">reader.</param>
            <returns>object instance.</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddReferencedObjectSerializer``2(System.Func{``0,``1})">
            <summary>Shortcut for <inheritdoc cref="M:Eco.Core.Serialization.Migrations.MigrationManager.AddReferencedObjectSerializer(System.String,System.Type,System.Func{System.Object,System.Object})"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.AddReferencedObjectSerializer(System.String,System.Type,System.Func{System.Object,System.Object})">
            <summary>Adds new <see cref="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializer"/> created for provided arguments.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.GetOrCreateVersionedSerializer(Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.Double)">
            <summary>
            Gets or creates versioned serializer. If migration for <paramref name="schema"/> required then it will start from <paramref name="version"/> instead of current schema version.
            Typical use-case if you have a <see cref="T:Eco.Core.Serialization.Migrations.DataMigration"/> which performs migration on a member which has migrations before and after that data migration.
            Then you fist migrate the member up-to version compatible with data migration then perform modifications for member from data modification itself and serialize it back with data migration version.
            When member will be decoded it will apply all migrations after the version of data migration. 
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.MigrateInstanceInternal(Eco.Core.Serialization.Migrations.MigrationContext,Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery,System.Action{Eco.Core.Serialization.Migrations.IInstanceMigration,Eco.Core.Serialization.Migrations.MigrationContext})">
            <summary>Applies class migrations to <paramref name="context"/>. Returns <c>true</c> if <paramref name="context"/> fully migrated.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.MigrateReferenceInternal(Eco.Core.Serialization.Migrations.MigrationContext,Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery,System.Action{Eco.Core.Serialization.Migrations.IReferenceMigration,Eco.Core.Serialization.Migrations.MigrationContext})">
            <summary>Applies reference migrations to <paramref name="context"/>. Returns <c>true</c> if <paramref name="context"/> fully migrated.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.ReadMembers(System.IO.BinaryReader,System.Collections.Generic.IDictionary{System.String,Eco.Core.Serialization.Migrations.DataMigrations.MemberDataInput},Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.Int64,System.Int64}}@)">
            <summary>
            Reads schema, returns decoded data for every requested member and returns member ranges mapping to positions in the stream.
            Reader positioned at the end of schema data after call to the method.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.ReadMembers(System.IO.BinaryReader,System.IO.Stream,System.Collections.Generic.IDictionary{System.String,Eco.Core.Serialization.Migrations.DataMigrations.MemberDataInput},Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.Int64,System.Int64}}@)">
            <summary>
            Reads schema, returns decoded data for every requested member and returns member ranges mapping to positions in the stream.
            Reader positioned at the end of schema data after call to the method.
            </summary>
            <param name="reader">binary reader to read data from.</param>
            <param name="instanceStream">stream with instance data which will advance with <paramref name="reader"/>. It may be reader's base stream or tapped stream from <see cref="T:Eco.Core.Utils.Streams.ReadOnlyForkStream"/>.</param>
            <param name="members">set of requested member names.</param>
            <param name="schema">schema describing data to read.</param>
            <param name="memberRanges">output dictionary with mapping between member names and they reader's positions.</param>
            <returns>dictionary with requested members data.</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.ReadMembersTo(System.IO.BinaryReader,System.IO.Stream,System.Collections.Generic.IDictionary{System.String,Eco.Core.Serialization.Migrations.DataMigrations.MemberDataInput},Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.Collections.Generic.Dictionary{Eco.Core.Serialization.Migrations.DataMigrations.IDataInput,Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput},System.Collections.Generic.Dictionary{System.String,System.ValueTuple{System.Int64,System.Int64}}@)">
            <summary>
            Reads schema, saves to <c>data</c> decoded data for every requested member and returns member ranges mapping to positions in the stream.
            Reader positioned at the end of schema data after call to the method.
            </summary>
            <param name="reader">binary reader to read data from.</param>
            <param name="instanceStream">stream with instance data which will advance with <paramref name="reader"/>. It may be reader's base stream or tapped stream from <see cref="T:Eco.Core.Utils.Streams.ReadOnlyForkStream"/>.</param>
            <param name="members">set of requested member names.</param>
            <param name="schema">schema describing data to read.</param>
            <param name="data">data dictionary to store requested members data.</param>
            <param name="memberRanges">output dictionary with mapping between member names and they reader's positions.</param>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.EncodeWith(Eco.Core.Serialization.Serializers.ISerializer,System.IO.BinaryWriter,System.Object,Eco.Core.Serialization.SerializeFlags)">
            <summary></summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.IsNullableType(System.String,System.Double)">
            <summary>
            Returns if type is nullable in specific schema version.
            </summary>
            <param name="schemaType">schema type.</param>
            <param name="version">schema version.</param>
            <returns><c>true</c> - if schema type nullable in specified schema version.</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.CopySchemaContent(Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.IO.BinaryReader,System.IO.BinaryWriter)">
            <summary>
            Copies schema content from reader to writer without actually deserializing it.
            </summary>
            <param name="schema">schema.</param>
            <param name="reader">reader to read from.</param>
            <param name="writer">writer to write content to.</param>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.SkipSchemaContent(Eco.Core.Serialization.Migrations.ImmutableSerializerSchema,System.IO.BinaryReader)">
            <summary>Skips schema content from reader without actually deserializing it.</summary>
            <param name="schema">schema.</param>
            <param name="reader">reader to skip from.</param>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery">
            <summary>Helper struct for querying versions migrations with <see cref="F:Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery.tillVersion"/> support.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery.TryGetVersionedMigrations``1(Eco.Core.Serialization.Migrations.VersionedTypeMapping{``0},System.String,System.Double,System.Collections.Generic.IEnumerable{Eco.Core.Serialization.Migrations.VersionedObject{``0}}@)">
            <summary>Returns versioned migrations for <paramref name="mapping"/>. Optionally applying <see cref="F:Eco.Core.Serialization.Migrations.MigrationManager.MigrationsQuery.tillVersion"/> constraint.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.MigrationType">
            <summary> Contains information about new type added during migration. Without this info it won't be possible to encode the type. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.SerializeNullAsReader">
            <summary> Serializes null object value as <see cref="T:System.IO.BinaryReader"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.SerializeAsReaderDataInput``1(Eco.Core.Serialization.Serializers.ISerializer,System.String,``0)">
            <summary>Serializes <paramref name="value"/> as <see cref="T:Eco.Core.Serialization.Migrations.DataMigrations.ReaderDataInput"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.CopyMigratedContent(Eco.Core.Serialization.Migrations.IMigration,Eco.Core.Serialization.Migrations.MigrationContext,System.IO.BinaryWriter)">
            <summary>Copies content migrated with <paramref name="migration"/> to <paramref name="writer"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.CopySerializerContent(Eco.Core.Serialization.Serializers.ISerializer,System.IO.BinaryReader,System.IO.BinaryWriter)">
            <summary>
            Copies serializer content from reader to writer without actually deserializing it.
            </summary>
            <param name="serializer">serializer.</param>
            <param name="reader">reader to read from.</param>
            <param name="writer">writer to write content to.</param>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.CopySerializerContent(Eco.Core.Serialization.Serializers.ISerializer,System.IO.BinaryReader,System.IO.Stream)">
            <summary>
            Copies serializer content from reader to writer without actually deserializing it.
            </summary>
            <param name="serializer">serializer.</param>
            <param name="reader">reader to read from.</param>
            <param name="outputStream">output stream to write content to.</param>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.CopySerializerInstanceContent(Eco.Core.Serialization.Serializers.ObjectSerializer,System.IO.BinaryReader,System.IO.BinaryWriter)">
            <summary>
            Copies serializer instance content from reader to writer without actually deserializing it (it uses <see cref="M:Eco.Core.Serialization.Serializers.ObjectSerializer.SkipInstance(System.IO.BinaryReader)"/> internally
            which only copies instance content without header - object flags and polymorphic object id).
            </summary>
            <param name="serializer">object serializer.</param>
            <param name="reader">reader to read from.</param>
            <param name="writer">writer to write content to.</param>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.MigrationUtils.CopySerializerInstanceContent(Eco.Core.Serialization.Serializers.ObjectSerializer,System.IO.BinaryReader,System.IO.Stream)">
            <summary>
            Copies serializer instance content from reader to writer without actually deserializing it (it uses <see cref="M:Eco.Core.Serialization.Serializers.ObjectSerializer.SkipInstance(System.IO.BinaryReader)"/> internally
            which only copies instance content without header - object flags and polymorphic object id).
            </summary>
            <param name="serializer">object serializer.</param>
            <param name="reader">reader to read from.</param>
            <param name="outputStream">output stream to write content to.</param>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ObjectInstanceMigration`2">
            <summary> Used to migrate object instance of compatible type (specified in constructor) to instance of same or another type. It may not produce null value as result and also may not produce value type. May be used as root level migration. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ObjectMigration`2">
            <summary>
            Used to migrate object instance to other object instance. It may not be used as auto root-level migration, but can be used explicitly as member migration or collection entry migration.
            It allows to migrate object to null or to value type (opposite to <see cref="T:Eco.Core.Serialization.Migrations.ObjectInstanceMigration`2"/>).
            </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ReferenceCollectionToDictionaryMigration">
            <summary> Used to migrate a collection of references into a dictionary, with ID as key ('null' entries are skipped). </summary>
            <remarks> Useful when wanting to migrate a ControllerList without having to wait for registrar initialization.    </remarks>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SchemaUtils.GetSchemaType(System.Type)">
            <summary>Returns schema name corresponding to type. It uses generation rules or built-in name if available.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SchemaUtils.AsClassSchemaType(System.String)">
            <summary>Returns class schema type. If <paramref name="typeNameOrSchemaType"/> already class schema type then returns as is otherwise assume it is type name and builds schema type from the type name.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SchemaUtils.GetClassSchemaType(System.String)">
            <summary>Returns class schema type for <paramref name="typeName"/>. If <paramref name="typeName"/> is generic type name then it will be converted to schema compatible name like List`1[[System.String, Version=1.0.0.0, PublicToken=null, Culture=neutral]] -> class[List{string}].</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SchemaUtils.FixOldFormatGenericSchemaType(System.String)">
            <summary> Converts old schema type for generic types into new one. </summary>
            <example>
            <code>class[Eco.Core.Systems.GeneratedRegistrarWrapper`1[[Eco.Gameplay.Items.TagManager, Eco.Gameplay, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]]</code>
            will be converted into.
            <code>class[Eco.Core.Systems.GeneratedRegistrarWrapper{class[Eco.Gameplay.Items.TagManager]}]</code>
            </example>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.SeekableRead">
            <summary>Helps to make seekable read on non-seekable streams.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SeekableRead.Start(System.IO.BinaryReader@)">
            <summary>Prepares members reader. It checks if Base Stream is seekable and if it isn't then it makes new <see cref="T:System.IO.BinaryReader"/> with <see cref="T:Eco.Core.Utils.Streams.ReadOnlyForkStream"/> which "taps" to new seekable instance stream.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SeekableRead.Reset">
            <summary>Resets seekable read to position from which it was started.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.SeekableRead.ResetReader(System.IO.BinaryReader)">
            <summary>Resets seekable read to position from which it was started and returns either same reader or new reader if stream was changed.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ValueToClassMigration">
            <summary>Migrates value to class with one of it's field filled with the value. Useful when required migration from value to class wrapping the value and extending it with additional info.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.ValueToClassMigration.#ctor(System.String,System.String)">
            <summary>Creates new <see cref="T:Eco.Core.Serialization.Migrations.ValueToClassMigration"/> which converts a value to class with <paramref name="schemaType"/> and saves value to <paramref name="fieldName"/> with same schema type as the value.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.ValueToCollectionMigration">
            <summary>Migrates value to collection with single element. Useful when required migration from former one element to collection of such elements.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.VersionedObject`1">
            <summary>Comparer which only compares version component of (version, object) component.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1">
            <summary>Mapping between type name and corresponding object (i.e. <see cref="T:Eco.Core.Serialization.Migrations.IInstanceMigration"/> or <see cref="T:Eco.Core.Serialization.Migrations.IReferenceMigration"/>) which aware about versioning.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.HasMapping(System.String)">
            <summary>Checks if there any mapping for any version for <paramref name="schemaType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.HasMigrations(System.String,System.Double)">
            <summary>Quick check if there any migrations <paramref name="sinceVersion"/> for <paramref name="schemaType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.TryGetVersionedObjects(System.String,System.Double,System.Double,System.Collections.Generic.IEnumerable{Eco.Core.Serialization.Migrations.VersionedObject{`0}}@)">
            <summary>Tries to get versioned objects for <paramref name="schemaType"/> having version greater than <paramref name="sinceVersion"/> and less than <paramref name="tillVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.TryGetVersionedObjects(System.String,System.Double,System.Collections.Generic.IEnumerable{Eco.Core.Serialization.Migrations.VersionedObject{`0}}@)">
            <summary>Tries to get versioned objects for <paramref name="schemaType"/> having version greater than <paramref name="sinceVersion"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.AddRange(System.Collections.Generic.IEnumerable{System.String},System.Double,`0)">
            <summary>Adds mapping for all <paramref name="schemaTypes"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Migrations.VersionedTypeMapping`1.Add(System.String,System.Double,`0)">
            <summary>Adds mapping for <paramref name="schemaType"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.PersistenceManager">
            <summary> <see cref="T:Eco.Core.Serialization.PersistenceManager"/> responsible for objects persistence (marking as dirty, delete, persist to DataStore). </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.AddBlob(Eco.Core.Serialization.DataBlob)">
            <summary> Adds <paramref name="blob"/> to persistence manager. It will be persisted in next call to <see cref="M:Eco.Core.Serialization.PersistenceManager.PersistAllAsync(Eco.Core.Serialization.DataStore.ExclusiveAccess)"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.MarkDirty(Eco.Core.Serialization.IStorage)">
            <summary>
            Marks storage as dirty using current version.
            During persist phase it increases version and only saves objects from previous version.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.Remove(Eco.Core.Serialization.IStorage)">
            <summary> Removes <paramref name="storage"/> from <see cref="F:Eco.Core.Serialization.PersistenceManager.pendingStorages"/>. It doesn't remove <paramref name="storage"/> immediate, but instead places it in <see cref="F:Eco.Core.Serialization.PersistenceManager.pendingStorages"/> to be processed with <see cref="M:Eco.Core.Serialization.PersistenceManager.PersistAllAsync(Eco.Core.Serialization.DataStore.ExclusiveAccess)"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.PersistAllAsync(Eco.Core.Serialization.DataStore.ExclusiveAccess)">
            <summary> Increases version and persists all dirty objects with last version. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.ApplyChanges(Eco.Core.Serialization.DataStore.ContentAccessor@)">
            <summary> Applies all pending changes. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.PersistBlobs(Eco.Core.Serialization.DataStore.ContentAccessor@)">
            <summary> Persists raw data blobs to data store using <paramref name="contentAccessor"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.Delete(Eco.Core.Serialization.DataStore.ContentAccessor@,Eco.Core.Serialization.IStorage)">
            <summary> Deletes storage with <paramref name="contentAccessor"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.Persist(Eco.Core.Serialization.DataStore.ContentAccessor@,Eco.Core.Serialization.IStorage)">
            <summary> Persists object with <paramref name="contentAccessor"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.ClearDirtyState(Eco.Core.Serialization.IStorage)">
            <summary>
            Clears dirty state for the <paramref name="storage"/>.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.PersistenceManager.IsDirty(Eco.Core.Serialization.IStorage)">
            <summary>
            Checks if the <paramref name="storage"/> is dirty.
            </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Schema.ClassSerializerSchemaBuilder">
            <summary>Custom serializer schema builder. Doesn't require existing type. Used for migration tests.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.SerializationTimestamp">
            <summary>
            This struct should be used for auto-generated serialization timestamps which then may be used to check if serialized version is up to date.
            When loaded it always contains last timestamp when it was serialized which may be used to ensure serialized versions contains actual copy and invalidate it if required (i.e. for height caches).
            Can be just added to serialized class which aware about serialization timestamp.
            IMPORTANT: It should be non-readonly field! If copied (i.e. when assigned by value) then it will contain snapshot value for <see cref="P:Eco.Core.Serialization.SerializationTimestamp.LastSerializedValue"/>.
            </summary>
        </member>
        <member name="P:Eco.Core.Serialization.SerializationTimestamp.Value">
            <summary>When serialized this value will be generated and saved. It also updates <see cref="P:Eco.Core.Serialization.SerializationTimestamp.LastSerializedValue"/>. Can be used to invalidate caches and other syncs.</summary>
        </member>
        <member name="P:Eco.Core.Serialization.SerializationTimestamp.LastSerializedValue">
            <summary>Contains last serialized <see cref="P:Eco.Core.Serialization.SerializationTimestamp.Value"/> (actually timestamp when it was last time serialized and persisted). The value is comparable with <see cref="P:Eco.Shared.Utils.TimeUtil.Seconds"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SerializationTimestamp.op_Implicit(Eco.Core.Serialization.SerializationTimestamp)~System.Double">
            <summary>May be implicitly converted to <see cref="T:System.Double"/> (will use <see cref="P:Eco.Core.Serialization.SerializationTimestamp.LastSerializedValue"/>).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SerializationUtils.CreateSerializer(System.Boolean,System.Boolean,Newtonsoft.Json.ObjectCreationHandling)">
            <summary>Creates <see cref="T:Newtonsoft.Json.JsonSerializer"/> using settings created with <see cref="M:Eco.Core.Serialization.SerializationUtils.CreateSerializerSettings(System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SerializationUtils.PopulateObjectWithJson(System.String,System.Object,Newtonsoft.Json.ObjectCreationHandling)">
            <summary>Populate json from the string (jsonText)</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SerializationUtils.PopulateObjectWithJson(Newtonsoft.Json.Linq.JObject,System.Object,Newtonsoft.Json.ObjectCreationHandling)">
            <summary>Populate json from the JObject. Useful if you need to change json on the way so it won't need to read it twice</summary>
        </member>
        <member name="T:Eco.Core.Serialization.EcoSerializer">
            <summary>Read more about serialization and migrations in README.md.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.SerializeTo(System.IO.Stream,System.Object)">
            <summary> Serializes <paramref name="obj"/> to <paramref name="stream"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.SerializeTo``1(System.IO.Stream,``0)">
            <summary> Serializes <paramref name="obj"/> to <paramref name="stream"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.LoadUniversalIDs">
            <summary>Loads objects with serialized universal ids.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.InitMigrationDeserializer(System.String,System.Double,System.ValueTuple{System.Type,System.Double}[])">
            <summary>Initializes migration deserializer for <see cref="F:Eco.Core.Serialization.EcoSerializer.currentSerializer"/> using <paramref name="schema"/> and <paramref name="migrationClasses"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.ThrowIfLastVersionInvalid">
            <summary>Checks if <see cref="P:Eco.Core.Serialization.EcoSerializer.LastVersion"/> is valid.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.ScanForMigrationClasses(System.Double,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>Scans all assemblies to find types with <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigrationAttribute"/> and returns array of such types ordered by migration target version.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.AddMigrations(Eco.Core.Serialization.Migrations.MigrationManager,System.ValueTuple{System.Type,System.Double}[])">
            <summary>Collects all suitable migrations (which should be applied since <see cref="P:Eco.Core.Serialization.EcoSerializer.LastVersion"/>).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.AddMigration(Eco.Core.Serialization.Migrations.MigrationManager,System.Type,System.Double)">
            <summary>Adds migration base on <paramref name="migrationType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.CollectMigrationTypes">
            <summary>Collects and registers all applicable migration types (with SinceVersion > LastVersion). See <see cref="T:Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute"/> and <see cref="T:Eco.Core.Serialization.Migrations.MigrationType"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.EcoSerializer.CreateMigrationType(System.Type,Eco.Core.Serialization.Migrations.Attributes.MigrationTypeAttribute,System.Nullable{System.Double})">
            <summary>Creates new <see cref="T:Eco.Core.Serialization.Migrations.MigrationType"/> from <paramref name="attribute"/> or returns <c>null</c> if this attribute won't produce the migration type (it should be newer than last schema version).</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.Array2DSerializer`1">
            <summary>Can serialize to a compressed Array2d or a regular Array2d.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.Array2DSerializer`1.EncodeElementsWithElementSerializer(System.IO.BinaryWriter,`0[],Eco.Core.Serialization.SerializeFlags)">
            <summary>Regular elements encode method when <see cref="F:Eco.Core.Serialization.Serializers.Array2DSerializer`1.valueSerializer"/> is not available.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.Array2DSerializer`1.EncodeElementsWithValueSerializer(System.IO.BinaryWriter,`0[],Eco.Core.Serialization.SerializeFlags)">
            <summary>Optimized elements encode method using <see cref="F:Eco.Core.Serialization.Serializers.Array2DSerializer`1.valueSerializer"/> if available.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.Array2DSerializer`1.DecodeElementsWithElementSerializer(System.IO.BinaryReader,`0[])">
            <summary>Regular elements decode method when <see cref="F:Eco.Core.Serialization.Serializers.Array2DSerializer`1.valueSerializer"/> is not available.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.Array2DSerializer`1.DecodeElementsWithValueSerializer(System.IO.BinaryReader,`0[])">
            <summary>Optimized elements decode method using <see cref="F:Eco.Core.Serialization.Serializers.Array2DSerializer`1.valueSerializer"/> if available.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.Array2DSkipperSerializer">
            <summary><see cref="T:Eco.Shared.Utils.Array2D`1"/> skipper (for 2d arrays of removed serialized types).</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.ArraySerializer">
            <summary>Base class for array serializers. Based on provided parameters to <see cref="M:Eco.Core.Serialization.Serializers.ArraySerializer.Create(System.Type,Eco.Core.Serialization.Serializers.ISerializer)"/> factory method it either creates <see cref="T:Eco.Core.Serialization.Serializers.DefaultArraySerializer"/> or <see cref="T:Eco.Core.Serialization.Serializers.ArraySerializer`1"/> (optimized version for <see cref="T:Eco.Core.Serialization.Serializers.ValueSerializer`1"/>).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ArraySerializer.Create(System.Type,Eco.Core.Serialization.Serializers.ISerializer)">
            <summary>Factory method which returns best matching <see cref="T:Eco.Core.Serialization.Serializers.ArraySerializer"/> implementation.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.ArraySerializer`1">
            <summary>Typed version of <see cref="T:Eco.Core.Serialization.Serializers.ArraySerializer"/> for element serializer inherited from <see cref="T:Eco.Core.Serialization.Serializers.ValueSerializer`1"/> for better performance and avoid boxing/unboxing for value types.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.DefaultArraySerializer">
            <summary>Default implementation of <see cref="T:Eco.Core.Serialization.Serializers.ArraySerializer"/> which uses straightforward unoptimized algorithm for encoding and decoding when optimized version not possible.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.IEnumSerializer">
            <summary>
            Marker interface for Enum Serializer.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ClassMigrationSerializer`1.EncodeInstanceWith(Eco.Core.Serialization.Serializers.ClassSerializer,System.IO.BinaryWriter,System.Object,Eco.Core.Serialization.SerializeFlags)">
            <summary>
            This method's main purpose is to provide access to internal classSerializer.EncodeMembers for migration serializers.
            </summary>
            <param name="classSerializer">class serializer to be used for members encoding.</param>
            <param name="writer">binary writer.</param>
            <param name="instance">instance which members will be encoded.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ClassSerializer`1.ConstructStronglyTypedActionForPropertySetter(System.Reflection.MethodInfo)">
            <summary>
            Speeds up access to <see cref="T:System.Reflection.MethodInfo"/> style reflection items. Created by Jon Skeet. Adapted for
            void type methods (specifically property setter)
            https://blogs.msmvps.com/jonskeet/2008/08/09/making-reflection-fly-and-exploring-delegates/.
            </summary>
            <param name="method">The method info to strongly type. This must be a method on <typeparamref name="T"/>.</param>
            <returns>A strongly typed already resolved and quick <see cref="T:System.Action"/> for this <see cref="T:System.Reflection.MethodInfo"/>.</returns>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.DictionarySerializer`3.Add(System.Object,System.Object,System.Object)">
            <summary>Adds mapping between <paramref name="key"/> and <paramref name="value"/> to an <paramref name="instance"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.DictionarySerializer`3.AddDelayed(System.Object,Eco.Core.Serialization.DecodedObject,Eco.Core.Serialization.DecodedObject)">
            <summary>Adds mapping delayed until <see cref="F:Eco.Core.Serialization.DecodedObject.SimpleFixups"/> applied. Usually used for references which may not yet be available on deserialization stage.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.DictionarySkipperSerializer">
            <summary>Class for skipping dictionaries using inner types that were removed.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.EnumerableSerializer">
            <summary>Serializer for enumerable collections, but not dictionaries (lists, sets etc).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.EnumerableSerializer.AddRange(System.Object,System.Collections.IEnumerable)">
            <summary><c>AddRange</c> to <paramref name="enumerable"/>. It uses <see cref="F:Eco.Core.Serialization.Serializers.EnumerableSerializer.addRangeDelegate"/> if available otherwise it adds element one by one with <see cref="F:Eco.Core.Serialization.Serializers.EnumerableSerializer.addDelegate"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.EnumerableSerializer.DecodeElements(System.IO.BinaryReader,System.Int32)">
            <summary>
            Decodes <paramref name="numElements"/> elements as <see cref="T:System.Collections.IEnumerable"/> from <paramref name="reader"/>. May be used with <see cref="F:Eco.Core.Serialization.Serializers.EnumerableSerializer.addRangeDelegate"/>.
            WARNING: If collection has custom <c>AddRange</c> then it should ensure to not have double enumeration. Ignoring this rule may lead to unpredictable results.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.EnumerableSerializer.CollectReferencedValues(Eco.Core.Serialization.DecodedObject[])">
            <summary>Collects referenced values for <paramref name="decodedObjects"/>. For every missing reference it will report error and skip it.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.EnumSkipperSerializer">
            <summary>Serializer skipping no more exising enums.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.EnumSkipperSerializer.Decode(System.IO.BinaryReader)">
            <summary>Return string instead of enum value. Usually this value ignored anyway, but string value may be useful for migrations.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.IArray2DSerializer">
            <summary>Interface for <see cref="T:Eco.Core.Serialization.Serializers.Array2DSerializer`1"/> which allows to access type info without known generic type.</summary>
        </member>
        <member name="P:Eco.Core.Serialization.Serializers.IReferenceableSerializer.ReferenceService">
            <summary>When not null then object may be encoded as reference (preferred if not SerializeFlags.ForceSerializeFullObject).</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.LegacyTypeSerializer">
            <summary>Legacy version of <see cref="T:Eco.Core.Serialization.Serializers.TypeSerializer"/> (before 9.6). May be removed after 10.0 release. Last compatible version should be set to at least 3.9201.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ObjectSerializer.GetReferenceService(System.Type)">
            <summary>Get <see cref="P:Eco.Core.Serialization.Serializers.ObjectSerializer.ReferenceService"/> for <paramref name="type"/> based on implemented interfaces.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ObjectSerializer.EncodeWith(Eco.Core.Serialization.Serializers.ISerializer,System.IO.BinaryWriter,System.Object,Eco.Core.Serialization.SerializeFlags)">
            <summary>
            This method may be used by inheritors and other classes from same module for more controlled serialization.
            </summary>
            <param name="serializer">Exact serializer to be used for instance encoding.</param>
            <param name="writer">binary writer.</param>
            <param name="instance">instance to be encoded.</param>
            <param name="flags"></param>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializer">
            <summary>Class for referenced objects serialization. Usually used during migration to convert non standard reference to an object (i.e. string to User).</summary>
            <inheritdoc cref="T:Eco.Core.Serialization.Serializers.ObjectSerializer"/>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot">
            <summary>
            Root Referenced Object serializer for schema type lookup. When serializer ID isn't known and only schema type is available it may be resolved to <see cref="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot"/> which then delegates logic to concrete <see cref="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializer"/>.
            It saves concrete serializer ID as part of instance data, so even if just instance data is available it still possible to get concrete referenced object serializer and resolve it to valid instance. 
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot.#ctor(Eco.Core.Serialization.SimpleSerializer)">
            <summary>Constructor for root ReferencedObjectSerializer. It not intended to be used for encoding/decoding, but as abstract root delegating to real instances of <see cref="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializer"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot.EncodeAsReference(System.IO.BinaryWriter,System.IO.BinaryReader)">
            <summary>Encodes key from <paramref name="keyReader"/> as a reference by the key to <paramref name="writer"/>. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot.Reference">
            <summary>Object reference with custom <see cref="F:Eco.Core.Serialization.Serializers.ReferencedObjectSerializerRoot.referenceResolver"/> function.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.Serializers.IValueSerializer">
            <summary>This interface helps to identify serializes which inherits from <see cref="T:Eco.Core.Serialization.Serializers.ValueSerializer`1"/> and get their <see cref="P:Eco.Core.Serialization.Serializers.IValueSerializer.ValueType"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.DecodedObject">
            <summary>
             Returned decoded object.  It can either be
             1. The fully formed object. Assigned in 'obj'
             2. A reference to the object, which will need to be assigned later, after all serialization is complete.
             In this case, object with the 'applyFunc' will be added fixupList to apply the reference, and that will
             be later executed.
             </summary>
        </member>
        <member name="M:Eco.Core.Serialization.DecodedObject.TryGetValue(System.Object@)">
            <summary>Tries to get <paramref name="value"/> as already known or resolved from reference.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DecodedObject.TryGetNotNullValue(System.Object@)">
            <summary>Tries to get non-null <paramref name="value"/> as already known or resolved from reference. Returns <c>false</c> if value isn't valid reference or it is <c>null</c>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.DecodedObject.CleanUp">
            <summary>Cleanups fixup lists.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.TryGetReferenceService(System.Type,Eco.Core.Serialization.Internal.IObjectReferenceService@)">
            <summary>Returns <see cref="T:System.ComponentModel.Design.IReferenceService"/> for <paramref name="type"/> if exits.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.TryMakeReference(System.String,System.Int32,Eco.Core.Serialization.DecodedObject@)">
            <summary>Tries to make <see cref="T:Eco.Core.Serialization.Internal.IObjectReference"/> for <paramref name="typeName"/> and <paramref name="id"/>. Fails when id is 0 or typeName is null, non-existing type name or isn't referenceable.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.DecodeReference(System.String,System.Int32)">
            <summary>Decodes reference from <paramref name="typeName"/> and <paramref name="id"/>. Applies migrations for reference if necessary.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.AddObjectSerializerByType(System.Type,Eco.Core.Serialization.Serializers.ObjectSerializer)">
            <summary>Adds <paramref name="serializer"/> to type mapping.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.CreateClassSchemaSerializer(Eco.Core.Serialization.SimpleSerializer,Eco.Core.Serialization.SerializerSchema)">
            <summary>Creates <see cref="T:Eco.Core.Serialization.Serializers.ClassSerializer"/> for class schema type (class[className]).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.ReplaceTypeSerializerWithLegacyIfRequired(Eco.Core.Serialization.Migrations.MigrationManager,System.Double)">
            <summary>Replaces <see cref="T:Eco.Core.Serialization.Serializers.TypeSerializer"/> with <see cref="T:Eco.Core.Serialization.Serializers.LegacyTypeSerializer"/> if schema version has old binary format for Type.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.InitSerializedAsEnumerableTypes">
            <summary>Initializes standard types which should be serialized as enumerable (like <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.List`1"/>). All other types should have <see cref="T:Eco.Shared.Serialization.SerializedAsEnumerableAttribute"/>.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.InitializeSerializableTypes">
            <summary>Scans all assemblies with reflection for all serializable types (with [Serialized] or [Eco] attribute).</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.AddSerializableType(System.Type,System.String)">
            <summary>Add serialized type to <see cref="F:Eco.Core.Serialization.SimpleSerializer.SerializableTypes"/>. If it isn't [Serialized] type, but just type name which may be referenced in serialized types then it adds it's name to <see cref="F:Eco.Core.Serialization.SimpleSerializer.AdditionalSerializedTypeNames"/> instead.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.SerializeTo(System.IO.Stream,System.Object)">
            <summary> Serializes <paramref name="obj"/> to <paramref name="stream"/>. </summary>
        </member>
        <member name="M:Eco.Core.Serialization.SimpleSerializer.SerializeTo``1(System.IO.Stream,``0)">
            <summary> Serializes <paramref name="obj"/> to <paramref name="stream"/>. </summary>
        </member>
        <member name="T:Eco.Core.Serialization.StandardSerializers">
            <summary>
            Holder for standard serializers which used by different serialization systems (i.e. <see cref="T:Eco.Core.Serialization.Migrations.SchemaUtils"/> and <see cref="T:Eco.Core.Serialization.SimpleSerializer"/>).
            It may not be part of SimpleSerializer, because when accessed it will force static constructor initialization logic which will cause different problems in runtime (i.e. not all assemblies may be loaded and assembly scan won't find all serializable types).
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.StandardSerializers.CreateStandardSerializers">
            <summary>Creates array of standard serializers to be used by <see cref="T:Eco.Core.Serialization.SimpleSerializer"/> or <see cref="T:Eco.Core.Serialization.Migrations.SchemaUtils"/>. Can't use shared instance, because serializers not stateless and has ID assigned by <see cref="T:Eco.Core.Serialization.SimpleSerializer"/>.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.StorageBag">
            <summary><see cref="T:Eco.Core.Serialization.StorageBag"/> is a serializable unordered container for items. Used by <see cref="T:Eco.Core.Serialization.StorageBagDirectory`1"/> as minimal serializable unit for save file entry.</summary>
        </member>
        <member name="T:Eco.Core.Serialization.StorageBagDirectory`1">
            <summary>
            <see cref="T:Eco.Core.Serialization.StorageBagDirectory`1"/> represents a directory in <see cref="P:Eco.Core.Serialization.StorageBagDirectory`1.StorageManager"/> with set of <see cref="T:Eco.Core.Serialization.StorageBag"/> entries. Each bag contains up to <see cref="P:Eco.Core.Serialization.StorageBagDirectory`1.MaxItemsPerBag"/> items.
            Intended for cases where lot of items may exists to reduce number of storage handles in Zip Archive. Zip archive slow downs and can even crash if too many entries.
            </summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.LoadInParallel">
            <summary>Loads all storage dir items in parallel.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.Add(`0)">
            <summary>Adds <paramref name="item"/> to one of storage bags in the directory.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.AddToExitingStorageBag(Eco.Core.Serialization.StorageBag,`0)">
            <summary>Adds <paramref name="item"/> to existing <paramref name="storageBag"/>.</summary>
            <returns><c>false</c> if bag isn't suitable (removed or full).</returns>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.AddToNewStorageBag(`0)">
            <summary>Creates new <see cref="T:Eco.Core.Serialization.StorageBag"/> for <paramref name="item"/> and returns it.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.Remove(`0)">
            <summary>Removes <paramref name="item"/> from the directory.</summary>
            <returns><c>false</c> if item wasn't added to the directory.</returns>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.Modify``1(``0,System.Action{``0})">
            <summary>Modifies <paramref name="obj"/> in a way preventing partial object saving.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageBagDirectory`1.MarkAllDirty">
            <summary>Marks all storage bags as dirty to be re-saved.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageExtensions.Modify``1(``0,System.Action{``0})">
            <summary>Perform storage modification. It ensures it won't be modified or saved in another thread to prevent concurrency issues.</summary>
        </member>
        <member name="M:Eco.Core.Serialization.StorageExtensions.Modify``2(``0,System.Func{``0,``1})">
            <summary>Perform storage modification (version with return value). It ensures it won't be modified or saved in another thread to prevent concurrency issues.</summary>
        </member>
        <member name="T:Eco.Core.Systems.GeneratedRegistrar`1">
            <summary>Implementation of <see cref="T:Eco.Core.Systems.Registrar`1"/> for registrars generated in runtime. Works in pair with <see cref="T:Eco.Core.Systems.GeneratedRegistrarWrapper`1"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.GeneratedRegistrar`1.AddNameMapping(System.String,`0)">
            <summary>Adds mapping between name and object, but doesn't allocate ID. IDs allocated when <see cref="M:Eco.Core.Systems.GeneratedRegistrar`1.PreInit(Eco.Shared.Localization.LocString,System.Boolean,Eco.Core.Plugins.Interfaces.ISaveablePlugin,System.String,System.Boolean)"/> called. May be only used before registrar initialized.</summary>
        </member>
        <member name="M:Eco.Core.Systems.GeneratedRegistrar`1.ClaimIDs(System.Collections.Generic.Dictionary{System.String,System.Int32})">
            <summary>Claims IDs by name for all matching objects in registrar.</summary>
        </member>
        <member name="T:Eco.Core.Systems.GeneratedRegistrarWrapper`1">
            <summary>
            A generated registrar is one whose data is created entirely dynamically, but then stored as an ID.
            It wraps a regular registrar, allowing it to save references and get the usual registrar benefits (linking, etc)
            It functions by only saving names->IDs, and fixing up on load. This allows us to use regular reference serialization (ie, you
            can store references to Tags instead of some TagHandle class), as well as makes the storage of tags a direct reference when
            running, and simply an int ID otherwise.
            We make this a templated class so we have separate statics for each type that implements it (a trick to allow us to have serialization and
            static data in a single structure).
            </summary>
        </member>
        <member name="T:Eco.Core.Systems.IHasReferenceableSerializableID">
            <summary>Marker interface for objects with serializable universal ID which may be serialized by reference (like <see cref="T:Eco.Core.Systems.IHasID"/>). These objects by default serialized by reference and need to use <see cref="T:Eco.Shared.Serialization.ForceSerializeFullObjectAttribute"/> for full object serialization.</summary>
        </member>
        <member name="T:Eco.Core.Systems.IHasUniversalID">
            <summary>For any object that needs to be referenced by the client and/or server.</summary>
        </member>
        <member name="T:Eco.Core.Systems.IHasSerializableID">
            <summary>If an object needs to have its ID serialized, it must inherit from this instead.</summary>
        </member>
        <member name="T:Eco.Core.Systems.IRegistrar">
            <summary>Interface allowing to have untyped access to <see cref="T:Eco.Core.Systems.Registrar`1"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.OfType``1">
            <summary>Returns all entries in <see cref="T:Eco.Core.Systems.IRegistrar"/> of specified type <typeparamref name="TResult"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.All">
            <summary>Returns all entries in <see cref="T:Eco.Core.Systems.IRegistrar"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.Verify">
            <summary> Verifies all entities in the registry and removes all which fails the verification. </summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.GetByName(System.String)">
            <summary>Returns <see cref="T:Eco.Core.Systems.IRegistrar"/> entity by Name.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.Add(System.Type,Eco.Shared.Networking.INetObject,System.String)">
            <summary>Adds new entity of <paramref name="type"/> which should be derived from <see cref="P:Eco.Core.Systems.IRegistrar.ContainedType"/>. Optionally providing <paramref name="netObj"/> and <paramref name="name"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.Insert(Eco.Core.Systems.IHasID,Eco.Shared.Networking.INetObject,System.Boolean)">
            <summary>Inserts pre-created <paramref name="obj"/>. It should match <see cref="P:Eco.Core.Systems.IRegistrar.ContainedType"/> of registar. Optionally providing <paramref name="netObj"/>.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IRegistrar.Save">
            <summary>Marks registry as dirty and asks persistence system to save it.</summary>
        </member>
        <member name="T:Eco.Core.Systems.Registrar`1">
            <summary>A registrar stores things of a single type that are accessible via an ID or via a name.
            Types that are stored in a registrar must have a private constructor,
            only the registrar is allowed to construct them so that the ID stays assigned and tracked properly.</summary>
        </member>
        <member name="F:Eco.Core.Systems.Registrar`1.MinNameLength">
            <summary> Min name length of entry in this registrar, can be overriden in <see cref="M:Eco.Core.Systems.Registrar`1.PreInit(Eco.Shared.Localization.LocString,System.Boolean,Eco.Core.Plugins.Interfaces.ISaveablePlugin,System.String,System.Boolean,System.Int32,System.Int32)"/> </summary>
        </member>
        <member name="F:Eco.Core.Systems.Registrar`1.MaxNameLength">
            <summary> Max name length of entry in this registrar, can be overriden in <see cref="M:Eco.Core.Systems.Registrar`1.PreInit(Eco.Shared.Localization.LocString,System.Boolean,Eco.Core.Plugins.Interfaces.ISaveablePlugin,System.String,System.Boolean,System.Int32,System.Int32)"/> </summary>
        </member>
        <member name="M:Eco.Core.Systems.Registrar`1.Verify">
            <summary> Verifies all entities in the registry and removes all which fails the verification. </summary>
        </member>
        <member name="M:Eco.Core.Systems.Registrar`1.SanitizeName(System.String@,System.Boolean,System.String,System.Boolean)">
            <summary>Checks a name for requirements (length and profanity-free). If 'allowChanges' is set, it will fix the name to meet reqs. Otherwise it fails if it
            doesnt meet reqs.</summary>
        </member>
        <member name="P:Eco.Core.Systems.IHasID.CanBeDeleted">
            <summary>If true, can be deleted by admins</summary>
        </member>
        <member name="M:Eco.Core.Systems.IHasID.Verify">
            <summary>Entity state verification function. Used by <see cref="T:Eco.Core.Systems.IRegistrar"/> to verify if entity's state isn't corrupted. All corrupted entities will be removed from registry. Called when serialization finished (fixups applied and PostLoad methods invoked).</summary>
        </member>
        <member name="M:Eco.Core.Systems.IHasID.GetLinkableName">
            <summary>Return a name that can be used for forming a link, e.g. used in ObjectFinders.cs. Some objects require a specific string to be parsed as a link, e.g. Channels.</summary>
        </member>
        <member name="M:Eco.Core.Systems.IHasIDExtensions.MarkedUpNameOrMissing(Eco.Core.Systems.IHasID)">
            <summary>Displays the marked up name, or *MISSING* if its null (can be called with a null safely)</summary>
        </member>
        <member name="M:Eco.Core.Systems.Registrars.AddPreInitCommand(System.Action)">
            <summary>Adds pre-init command which runs before initialization of any registrar.</summary>
        </member>
        <member name="M:Eco.Core.Systems.Registrars.RunAndClearPreInitCommands">
            <summary>Runs all pre-init commands and clears the list.</summary>
        </member>
        <member name="M:Eco.Core.Systems.Registrars.Verify">
            <summary>Verifies all registrars. Should be called when all fixups already applied, makes low level verification and removes invalid entities.</summary>
        </member>
        <member name="T:Eco.Core.Systems.UniversalIDs">
            <summary>Management of objects with a universal id. Tracks them and allows finding by ID.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.Load(System.Collections.Generic.IEnumerable{Eco.Core.Systems.IHasUniversalID})">
            <summary>Loads objects to <see cref="T:Eco.Core.Systems.UniversalIDs"/> storage.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.Unload">
            <summary>Unloads objects from <see cref="T:Eco.Core.Systems.UniversalIDs"/> storage. May be used in tests.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.Clean">
            <summary>Remove entries whose weak-references no longer point to anything.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.TryGetByID(System.Int32,Eco.Core.Systems.IHasUniversalID@)">
            <summary>Get the object of the given ID. It may fail if the weak reference has expired on a deleted object,
            in which case false is returned.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.GetOrNull(System.Int32)">
            <summary>Return the IHasUniversalID with the given ID, or null if it's not found.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.GetOrNull``1(System.Int32)">
            <summary>Return the object with the given ID, cast to expected Type T. Returns null if not found or different type than expected. </summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.GetOrCreateID(Eco.Core.Systems.IHasUniversalID)">
            <summary> Get the ID, assigning a new one if none is set yet.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.ClaimID(Eco.Core.Systems.IHasUniversalID,System.Int32)">
            <summary>Claims <paramref name="id"/> for <paramref name="obj"/>. Can only be used when serialized IDs loaded and if object doesn't yet have an ID.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.ResolveClaimedIDConflict(System.Int32,Eco.Core.Systems.IHasUniversalID)">
            <summary>Tries to resolve claimed IDs conflict. Throws exception if conflict can't be solved.</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.InternalCreateID(Eco.Core.Systems.IHasUniversalID)">
            <summary>Assign an ID and put it in the dictionary</summary>
        </member>
        <member name="M:Eco.Core.Systems.UniversalIDs.AddToDictionary(Eco.Core.Systems.IHasUniversalID)">
            <summary>Put an object with an id into the dictionary, asserting no collisions.</summary>
        </member>
        <member name="T:Eco.Core.Tooltips.TooltipsCore">
            <summary>Utils for watching properties on properties.</summary>
        </member>
        <member name="F:Eco.Core.Tooltips.TooltipsCore.CreateTooltipInvalidationActionDelegate">
            <summary>A function filled in by the tooltip system, which lives in gameplay, that will create an action invalidating a specific tooltip.</summary>
        </member>
        <member name="T:Eco.Shared.Collections.ImmutableDictionaryTransaction`2">
            <summary>
            It is a class for transaction for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/>. It isn't immutable by itself. It is also not thread-safe and can be used from one thread.
            It provides more effective way to make multiple modifications for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> in transaction with tracking for all changes.
            It behaves dictionary-like and implements most common dictionary methods.
            You should use this class if you want to make multiple modifications to <see cref="T:Eco.Core.Utils.ThreadSafeDictionary`2"/>, but don't wanna to make them visible
            until all of them completed. You should ensure no other modifications done in <see cref="T:Eco.Core.Utils.ThreadSafeDictionary`2"/> until transaction complete, because they may be overwritten.
            Then you can create/re-use <see cref="T:Eco.Shared.Collections.ImmutableDictionaryTransaction`2"/> and <see cref="M:Eco.Shared.Collections.ImmutableDictionaryTransaction`2.Start(System.Collections.Immutable.ImmutableDictionary{`0,`1})"/> it for <see cref="P:Eco.Core.Utils.ThreadSafeDictionary`2.Snapshot"/>.
            When you done you can <see cref="M:Eco.Shared.Collections.ImmutableDictionaryTransaction`2.Commit"/> it and get new <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> with all modifications applied and then <see cref="M:Eco.Core.Utils.ThreadSafeDictionary`2.Set(System.Collections.Immutable.ImmutableDictionary{`0,`1})"/> it back.
            It may be extended if required to expose all modifications done in transaction for processing.
            </summary>
        </member>
        <member name="M:Eco.Shared.Collections.ImmutableDictionaryTransaction`2.Start(System.Collections.Immutable.ImmutableDictionary{`0,`1})">
            <summary>Starts new transaction for <paramref name="initial"/>. Be sure you <see cref="M:Eco.Shared.Collections.ImmutableDictionaryTransaction`2.Commit"/> previous transaction, before this call, because state may not be clear!</summary>
        </member>
        <member name="M:Eco.Shared.Collections.ImmutableDictionaryTransaction`2.Commit">
            <summary>Finishes transaction, clears transaction state and returns new <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> with all transaction changes applied.</summary>
        </member>
        <member name="M:Eco.Shared.Utils.ChangeNotificationUtils.PropagateChange(Eco.Core.Controller.IController,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Glue coded to connect a fody automatic change notification (which happens through the INotifyPropertyChanged interface) to a separate controller./// </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Monitoring.NetTrafficTracker.TrafficEntry.Describe(System.Double)">
            <summary> Describe over period of time delta </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Monitoring.NetTrafficTracker.TrafficEntry.Describe">
            <summary> Describe total </summary>
        </member>
        <member name="M:Eco.Shared.Networking.Monitoring.NetTrafficTracker.TrafficEntryAverage.Describe">
            <summary> Describe over total time </summary>
        </member>
        <member name="F:Eco.Shared.Networking.Monitoring.NetTrafficTracker.categoryInstancesPerClient">
            <summary> Number of times a certain category of object is sent, per Client (used to calculate average) </summary>
        </member>
    </members>
</doc>
