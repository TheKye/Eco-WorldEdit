<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>Eco.Gameplay</name>
    </assembly>
    <members>
        <member name="T:Eco.Gameplay.Achievements.AchievementProgressChange">
            <summary>When Achievement progress is gained this data struct is created and passed to process</summary>
        </member>
        <member name="T:Eco.Gameplay.Achievements.AchievementDefinition">
            <summary>The definition for an achievement, which can be in the base list or externally created via mods. See <see href="ModAchievements.cs" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Achievements.AchievementDefinition.TriggerAchievementProgress(Eco.Gameplay.Players.User,System.Func{Eco.Shared.Localization.LocString},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>Trigger the achievement or add progress to cumulative one</summary>
        </member>
        <member name="M:Eco.Gameplay.Achievements.AchievementDefinition.CreateAchievementDefinition(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Action{Eco.Gameplay.Achievements.AchievementDefinition},System.Boolean,System.Single,System.Int32)">
            <param name="displayName">The name of the achievement that will be shown to the player.</param>
        </member>
        <member name="T:Eco.Gameplay.Achievements.AchievementInstance">
            <summary>An individual achievement earned or in progress of being earned by a user.</summary>
            <remarks>Contains details about where it was earned and the specifics of it.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Achievements.IContainsAchievements">
            <summary>Define on a class that has a static function</summary>
            <remarks>This must return all the achievements that are to be made.</remarks> 
        </member>
        <member name="T:Eco.Gameplay.Achievements.AchievementManager">
            <summary>Handles management of achievements for users</summary>
        </member>
        <member name="M:Eco.Gameplay.Achievements.AchievementManager.GetServerAchievementNames">
            <summary>Returns an array of localized achievement names and their description that the server has obtained. Returns empty array if none available</summary>
        </member>
        <member name="M:Eco.Gameplay.Achievements.AchievementManager.OnAchievementProgress(Eco.Gameplay.Achievements.AchievementProgressChange)">
            <summary>Process achievement Progress</summary>
        </member>
        <member name="T:Eco.Gameplay.Achievements.ServerAchievements">
            <summary>Tracks scores and achievements for servers as a whole</summary>
        </member>
        <member name="T:Eco.Gameplay.Aliases.IAlias">
            <summary>An object that contains a list of users (<see cref="T:Eco.Gameplay.Civics.Titles.Title" />, <see cref="T:Eco.Gameplay.Civics.Demographics.Demographic" />, <see cref="T:Eco.Gameplay.Players.User" />).</summary>
        </member>
        <member name="P:Eco.Gameplay.Aliases.IAlias.UserSetChangedEvent">
            <summary>Raised when a user/users are added or removed from the UserSet. When invoked this event get passed the list of users that were added and removed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Aliases.AliasExtensions.OneUser(Eco.Gameplay.Aliases.IAlias)">
            <summary>If this alias is a single user, return it.  This is used for parts of the game that can't handle something being multiple users. Over time we can add support to that (like housing values spreading across multiple people for example).</summary>
        </member>
        <member name="M:Eco.Gameplay.Aliases.AliasExtensions.FirstUser(Eco.Gameplay.Aliases.IAlias)">
            <summary>If this alias has multiple users, return the first one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Aliases.AliasExtensions.ToUsers(System.Collections.Generic.IEnumerable{Eco.Gameplay.Aliases.IAlias})">
            <summary>Get the full list of users in all these aliases, no repeats.</summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.Internal.UserLayeredCatchEntry">
            <summary> Base class for player dependent catchers. Preferably targeting user inventory and checks by user position to apply catcher </summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.Internal.WorldObjectLayeredCatchEntry">
            <summary> Base class for world object targeted catchers. Preferably targeting their storage inventory and checks by object position </summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry">
            <summary>
            Core atomic component for layered catch system.
            Gets the species name and converts/caches that to animal world layers
            On tick it tries to check population there and catch smth, by special configurable rules (todo implement and add them to LayeredCatchEntryConfig too)
            It applies changes to layer afterwards
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.DefaultTargetSpecies">
            <summary> Default target species that will be default in configuration. Only used for initial setup. </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.Enabled">
            <summary> If this catcher is active and should be processed on regular update </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.AnimalLayers">
            <summary> Cached animal layers from Species list provided. </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.TargetInventory">
            <summary> Inventory that will be used to put items gathered by this catcher </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.NextCatchDelay">
            <summary> Cached time interval for next tick </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.CurrentCatchDelay">
            <summary> Current catch delay tick, so we can have time randoness </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.CatchRange">
            <summary> Amount of resources per catch update (e.g.: 1..1 = min of 1 max 1, 0..2 = min of 0, max of 2) </summary>
        </member>
        <member name="P:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.Apply">
            <summary> Action to apply when catch is successfull </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.ApplyData(System.Collections.Generic.List{System.String})">
            <summary> Fill new species to this catcher (useful for updates in runtime on config changes) </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.Tick">
            <summary>
            Tick - Updates enabled catch entry
            1. Updates catch check interval
            2. Tries to apply randomized results catch to layer when interval is reached
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.ApplyCatch(Eco.Simulation.Types.Species,System.Int32)">
            <summary> Tries to apply catch to inventory and environments changes </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.GetLayerData">
            <summary> Returns layer data from position </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.GetCatchData(System.Collections.Generic.IEnumerable{Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.CatchLayerData})">
            <summary> Picks species and amount randomly with balanced weights based on layer value</summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.OnPositionCheck">
            <summary> This should return position to check for layer catch process. For fishing pole its lure, for fishing trap its trap position, etc </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.OnValidationCheck">
            <summary> This should check if this catcher is still need to be processed. This is always checked before tick, and if returns false -&gt; this catcher will be removed </summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry.CatchLayerData">
            <summary> Structure for cached layer data for special rules to be applied on to it (on how to catch things) </summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.Internal.SpeciesLayeredCatchConfig">
            <summary>
            Config for <see cref="T:Eco.Gameplay.Animals.Catchers.SpeciesLayeredCatchPlugin" /> to allow custom user settings to target species from <see cref="T:Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry" /> 
            e.g.: add/remove target species from fishing pole catcher
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.Internal.SpeciesLayeredCatchConfig.GetSpecies(System.Type)">
            <summary> Gets list of species for the catcher type </summary>
        </member>
        <member name="T:Eco.Gameplay.Animals.Catchers.SpeciesLayeredCatchPlugin">
            <summary>
            Plugin that registers and updates species catchers. 
            It will tick active valid ones. Can be used for any kind of automatic species gather:
            Animals traps, fishing traps, crab pots, trawler passive catch, etc
            This moves gather logic (fishing/catching/etc) away from client and we secure it around server
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.SpeciesLayeredCatchPlugin.AddLayeredCatcher(System.Object,Eco.Gameplay.Animals.Catchers.Internal.LayeredCatchEntry)">
            <summary> Adds catcher to tracking list and dills data from configs </summary>
        </member>
        <member name="M:Eco.Gameplay.Animals.Catchers.SpeciesLayeredCatchPlugin.UpdateCatchersData">
            <summary> Apply plugin configuration for currently present catchers on the world </summary>
        </member>
        <member name="T:Eco.Gameplay.Auth.AuthManager">
            <summary> Class solely responsible for authorization about everything (e.g.: WorldObjects, Plots, GameActions, etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization of a GameAction. Returns success if user is authorized on the WorldObject, if there is one, or all deeds affected if there isn't. </summary>
            <remarks> Also returns success if GameAction doesn't need any access, or if GameAction is NOT issued by a user (for non-user actions like <see cref="T:Eco.Gameplay.GameActions.GlobalTimer" />). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization on a WorldObject. </summary>
            <remarks> Returns success if user is authorized on the AuthComponent, if there is one, or the plot if there isn't. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Shared.Voxel.PlotPos,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization on a position. Returns success if user is authorized on specified plot position. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Shared.Math.WorldRange,Eco.Gameplay.Players.User,Eco.Shared.Items.AccessType)">
            <summary> Checks authorization for a swath of land (WITHOUT overrides from GameAction). </summary>
            <remarks> Returns success if user is authorized on ALL plots. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Players.Player,Eco.Shared.SharedTypes.InteractionTarget,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function to call the correct auth check given a context. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.GetAuthorizationLevel(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Gameplay.GameActions.GameAction)">
            <summary> Gets the level of authorization a user has over the specified property. <para> Internally checks for GameAction auth overrides. </para> 
            Ignores the special result returned from overload.</summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.ShouldOverrideAuth(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks if auth should be overriden for target GameAction. <para> e.g.: Auth should be overriden for a GameAction that affects a WorldObject authorized by a Contract. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.GetAuthorizationLevel(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Core.Utils.LazyResult@,Eco.Gameplay.GameActions.GameAction)">
            <summary> Gets the level of authorization an alias has on the specified property.           </summary>
            <remarks> If there's an access override from a GameAction, it is outted as `specialResult`. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Property.IOwned,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function that returns success if alias is authorized on target property. </summary>
            <remarks> Returns the special result if access if overriden from GameAction.              </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(System.Collections.Generic.IEnumerable{Eco.Gameplay.Property.Deed},Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function that returns success if alias is authorized on ALL specified deeds. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.NotAuthed(Eco.Gameplay.Property.IOwned)">
            <summary> The failure result for unauthorized actions. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockTierAttribute">
            <summary> The tier of a block used for room tier calculations. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Reapable">
            <summary> That can be reaped; ready for reaping. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Chopable">
            <summary> That can be chopped; ready for chopping. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Clearable">
            <summary> That can be cleared by a machete; ready for clearing. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockContainer">
            <summary> A contained area of blocks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainer.#ctor(Eco.Shared.Math.WrappedWorldPosition3i,System.Numerics.Vector3)">
            <summary> Makes new block container at <paramref name="position" /> (it should be pre-wrapped) and with specified <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainer.Contains(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Checks if <paramref name="position" /> is within the <see cref="T:Eco.Gameplay.Blocks.BlockContainer" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockContainerManager">
            <summary> Manages contained areas of blocks. Can test if an individual block is in any container. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.AddBlockContainer(Eco.Shared.Math.WrappedWorldPosition3i,System.Numerics.Vector3)">
            <summary> Adds <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> at <paramref name="position" /> with <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.RemoveBlockContainer(Eco.Shared.Math.WrappedWorldPosition3i,System.Numerics.Vector3)">
            <summary> Removes <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> at <paramref name="position" /> with <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.IsBlockContained(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Checks if <paramref name="position" /> contained within any of registered <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> instances. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.MaterialId">
            <summary> Material ID of material that form is made from. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.BlockTypes">
            <summary> Rotational variants, first being default. They are suppose to go in order: 0 - not rotated, 1 - rotation for 90° and so on. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.Next">
            <summary> Used in case of consecutive blocks, like ramps. TODO: change to ushort? after adding support of nullables to view system. Now -1 represents null </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.IconName">
            <summary> Icon name used by the client to look up the icon in Eco.scene. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.GroupType">
            <summary> The FormGroup-derived type that defines the group this form belongs to. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.MinTier">
            <summary> Minimum tier of hammer needed to use this form. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.Group">
            <summary> Form group used for grouping in the UI. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.IconItem">
            <summary>
            Base class for block forms and fills.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.IconItem.SortOrder">
            <summary> A number used for sorting in lists in the UI. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blueprints.Blueprint">
            <summary>Contains persistent data for <see cref="T:Eco.Gameplay.Blueprints.BlueprintItem" />. Inherited by World Object's <see cref="T:Eco.Gameplay.Blueprints.BlueprintComponent" /> when <see cref="T:Eco.Gameplay.Blueprints.FoundationStoneObject" /> created from item.</summary>
        </member>
        <member name="T:Eco.Gameplay.Blueprints.BlueprintCommands">
            <summary>Blueprint related commands.</summary>
        </member>
        <member name="T:Eco.Gameplay.Blueprints.BlueprintComponent">
            <summary>Component holding blueprint data.</summary>
        </member>
        <member name="T:Eco.Gameplay.Blueprints.BlueprintItem">
            <summary>Item which may be used for <see cref="T:Eco.Gameplay.Blueprints.FoundationStoneObject" /> creation, containing blueprint data.</summary>
        </member>
        <member name="P:Eco.Gameplay.Blueprints.BlueprintItem.Blueprint">
            <summary>Part of item's persistent data which contains information about associated Blueprint (name and blocks info). This data will be inherited by <see cref="T:Eco.Gameplay.Blueprints.BlueprintComponent" /> when <see cref="T:Eco.Gameplay.Blueprints.FoundationStoneObject" /> created from the item.</summary>
        </member>
        <member name="T:Eco.Gameplay.Blueprints.FoundationStoneObject">
            <summary>Foundation stone representing blueprint in the world.</summary>
        </member>
        <member name="T:Eco.Gameplay.Buffs.AreaBuffManager">
            <summary>Tracks all the buffs by location and shares with client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsCommands.SpawnGov(Eco.Gameplay.Systems.Chat.IChatClient,System.Nullable{Eco.Shared.Math.Vector3i},System.Boolean,System.Int32,System.Boolean,System.String)">
            <summary> Spawn a Government. It is possible to override the capitol object (used in settlements) </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsExtensions.SetDefaults(Eco.Gameplay.Civics.ElectionProcess)">
            <summary> Values of the provided election process will be replaced with defaults from the config. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsExtensions.TrySetValueFromConfig(Eco.Gameplay.Civics.ElectionProcess,System.Reflection.PropertyInfo)">
            <summary> Looks for a property with the same name and replaces its value with the one from the config. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.AddCivicActionToObjectAttribute">
            <summary>Will ensure that this civic action can be performed on a civic object of the given type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.HasCivicAction">
            <summary>Adds the listed civic action type to the object this is declared on..</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.CivicsManager">
            <summary>Civics properties used on the client</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsManager.GetCivicActionsForWorldObject(System.Type)">
            <summary>Gets all the civic actions that can be executed on a given world object. Defined via attributes [AddCiviceActionToObject] and [HasCivicAction]</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsManager.GetWorldObjectsForCivicAction(System.Type)">
            <summary>Gets all the world objects where the given civic action can be performed. Defined via attributes [AddCiviceActionToObject] and [HasCivicAction]</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsData.DeactivateGovernment(Eco.Gameplay.Settlements.Settlement,System.Boolean,System.Boolean)">
            <summary>Deactivate all proposables for a given settlement, or all settlement if null.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameActionAccumulator">
            <summary>Accumulator to aggregate <see cref="T:Eco.Gameplay.GameActions.GameAction" />'s property every intervalTime seconds.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameActionAccumulator.AddGameActions(Eco.Gameplay.GameActions.AccumulatableAction,Eco.Gameplay.Players.User)">
            <summary>Add <see cref="T:Eco.Gameplay.GameActions.GameAction" /> every time it's need to accumulate.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameActionAccumulator.Tick">
            <summary>
            Perform all GameActions which are accumulated and clear the data of last intervalTime seconds.
            Step 1: get copy List of <see cref="F:Eco.Gameplay.Civics.GameActionAccumulator.userGameActionList" /> and clear it
            Step 2: group copied list by user and type
            Step 3: Iterate each group and <see cref="M:Eco.Gameplay.GameActions.AccumulatableAction.AggregateAction(Eco.Gameplay.GameActions.AccumulatableAction)" /> them into one
            Step 4: Perform aggregated Action"/&gt;
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicCondition.AppliesTo(Eco.Gameplay.Civics.CivicAction)">
            <summary>Returns true if this civic condition matches the given action (either because it applies to the type of civic action, or its acting on a container of the given type of civic types.)</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicCondition.AppliesTo(System.Type)">
            <summary>Returns true if this civic condition matches the given action (either because it applies to the type of civic action, or its acting on a container of the given type of civic types.)</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicConditionAllOtherCivicAbilities">
            <summary></summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicArticleCondition">
            <summary>Defines a type of civic action, which can be used to determine government rules in a constitution via CivicArticles</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicArticleCondition.PassesCondition(Eco.Gameplay.Players.User,Eco.Gameplay.Civics.CivicAction)">
            <summary>Returns true if this civic condition matches the given action (either because it applies to the type of civic action, or its acting on a container of the given type of civic types.)</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicPowerFlags">
            <summary>Defines a user's abilities with regards to any civic type</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicPowersManager">
            <summary>Helpers for determining a user's 'Civic Powers', which is the various governmental actions they are
            allowed to take, based on the settlement (used to be called Civic Duties).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.WatchCivicPowersAndCall(Eco.Shared.View.ISubscriptions{Eco.Core.Utils.ThreadSafeSubscriptions},System.Func{Eco.Gameplay.Settlements.Settlement},System.Action)">
            <summary>Subscribe to civic powers for a given settlement only.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.CivicPowersChangedEvent">
            <summary>Called when powers change for a user for a given settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.GetPowersDesc(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
            Civic Powers
            <summary>Returns a multiline description for a list of types, ignoring non-constitutional types.</summary>
            <param name="isSettlementFromJurisdiction">True if settlement was selected using jurisdiction component. False if it was selected based on position.</param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.GetPowers(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>Returns an enumerable corresponding to the passed types, listing the powers the given user has in the given settlement for each action in that list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.GetCivicPower(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Players.User,System.Type)">
            <summary>Returns what powers the given users has for the given civic type (can be a Civic Action or an IPropsoable type),
            within the given settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.GetSubmitButtonText(Eco.Gameplay.Players.User,Eco.Gameplay.Settlements.Settlement,System.Type,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>When editing an IProposable, we color the button based on what civic power we have, execution or election.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.DoPeriodicErrorCheck">
            <summary>In QA mode, we periodically check to make sure that the last civic powers we made are what we expected them to be.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicPowersManager.DebugUpdateAllCachedPowers(Eco.Gameplay.Settlements.Settlement,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User})">
            <summary>Updates the cached civic powers, which we do just for debug detection of failure to update</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Constitutional.ConstitutionUtils.CanBeInConstitution">
            Civic Power Types
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitution.OnRenamed(System.String)">
            <summary> Update Constitution articles name when Constitution gets renamed </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitution.InitDefaultConstitution(Eco.Gameplay.Civics.ElectionProcess,Eco.Gameplay.Aliases.IAlias)">
            <summary>Fill the constitution with all powers allowed by elections of the given process, by the given proposers.</summary>
            <param name="defaultProcess"></param>
            <param name="defaultProposers"></param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitution.ArticleNameWithConstitution(System.String)">
            <summary> Make a Article name with its Constitution name as prefix. Articles use this prefix so the default Article name can match the number of articles even when there are multiple Constitutions. </summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.ConstitutionManager.SettlementToCurrentArticles">
            <summary>All the active articles, from both the constitution and any amendments that modify that list.  Will contain invalid articles too.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.ConstitutionManager.SetConstitution(Eco.Gameplay.Civics.Constitution,Eco.Gameplay.Settlements.Settlement)">
            <summary>Set the constitution for a given settlement</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Demographics.Demographic.SetWhitelist(Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Force a user to be a permanent member of this demographic, regardless of whether they meet the conditions (can removed from whitelist also).</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager">
            <summary> Aggregates given amounts and gets ticked using <see cref="T:Eco.Gameplay.Civics.CivicsPlugin" /> through <see cref="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)" /> </summary>
            <inheritdoc cref="T:Eco.Shared.Utils.Singleton`1" />
            <example> Used for <see cref="T:Eco.Gameplay.Economy.WorkParties.WorkParty" /> Pay as you go feature where fraction payments that can get aggregated over <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> time. </example>
            <remarks> This is meant to process transfers in bulk instead of using <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications" /> to avoid extra processing that isn't meant to be done for notifications.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.AddOrUpdateAggregatedAmount(Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount,Eco.Gameplay.Players.User,System.Single)">
            <summary>
            Adds a delayed amount by <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> that should aggregate if there is a value with the same handles already delayed.
            </summary>
            <param name="aggregatedAmountHandler"> The aggregated amount Handler that should be resposible for handling the aggregated value. </param>
            <param name="user"> The target user that the amount should go to. </param>
            <param name="amountDelta"> The difference in aggregated amount that should applied for the given user, for example in WorkParites the payment is calculated with <see cref="T:Eco.Gameplay.Economy.WorkParties.Payment" />, in which the weight change (aggregated amount) is given and then payment is calculated and paid.</param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ForceAggregatingAmountsForHandler(Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount)">
            <summary> Forces the remaining aggregate amounts for the given amount handler. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.Tick">
            <summary> When ticked checks if there are aggregate amounts due and pays it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ApplyAggregatedAmountsGroupAndRemove(System.Collections.Generic.IEnumerable{Eco.Gameplay.Civics.Economy.AggregatedAmount})">
            <summary> Processes out the given group of aggregate amounts and removes it from <see cref="F:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.aggregatedAmounts" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ProcessAggregatedAmountAndRemove(Eco.Gameplay.Civics.Economy.AggregatedAmount)">
            <summary> Applies handling for the given aggregated amount and removes it from <see cref="F:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.aggregatedAmounts" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.AggregatedAmount">
            <summary> Holds data for aggregated amount, this is ticked by <see cref="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager" /> through <see cref="T:Eco.Gameplay.Civics.CivicsPlugin" />, delay is calculated internally using <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount">
            <summary> Interface meant for handling aggregated amounts using <see cref="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager" /> </summary>
            <example> Check <see cref="T:Eco.Gameplay.Economy.WorkParties.WorkParty" /> for an example implementation. </example>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)">
            <summary> Process the final aggregated amount for the given user. </summary>
            <param name="user">The targeted user reference.</param>
            <param name="amount">The final amount to be applied after aggregating for <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> seconds</param>
        </member>
        <member name="T:Eco.Gameplay.Civics.ElectionChoiceID">
            <summary>Simple int wrapper to lend some type safety to elections. </summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Elections.Election.UserVotedEvent">
            <summary>Executed when somebody voted in any election.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.Election.ElectionStartedEvent">
            <summary>Executed whenever voting for an election starts.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Elections.Election.ElectionFinishedEvent">
            <summary>Executed whenever an election completes.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Elections.Election.ElectionChoicesChangedEvent">
            <summary>Executed whenever an election's choice options change.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.Election.EndDateTime">
            <summary>Represents the election ending timestamp as <see cref="T:System.DateTime" /></summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.Election.ActionsOnComplete">
            <summary>
            The actions we run when the election succeeds.
            We dont scan the contents because CanStartForActions is called when an election starts, and that does a full consideration of what
            states should be allowed, ensures that referenced drafts are also in the election, etc.  (we could move that to be a Valid check in the election and
            then allow it to be scanned normally, but we'll leave that for now)
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.GetFinishedResult">
            <summary>Return the finished results, or null if theyre not done.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.GetCurrentResults">
            <summary>Generates the current results if theyre not set.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.CanVote(Eco.Gameplay.Players.User)">
            <summary>Check the various things that determine if a user can vote or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.TwitchVote(System.String,System.String,Eco.Gameplay.Civics.Elections.TwitchVote)">
            <summary>Cast a vote from a twitch user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.UpdateProvisionsDescription">
            <summary>Update the description of the election, not describing the results (those are described in ElectionResult).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.CalcResultsAndProcess(System.Boolean,System.Boolean,Eco.Gameplay.Players.User)">
            <summary>Calculate current results of election, and if it's finished, do the final processing.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.ShowAllVotes(Eco.Gameplay.Players.Player)">
            <summary>Display a large text of all the votes.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.CivicAction_StartCandidateElection.NotifyOnPerform">
            <summary>This is overriden to false for this action because this action invokes another global <see cref="M:Eco.Gameplay.Players.Player.OkBox(Eco.Shared.Localization.LocString)" /> that is tailored for elections.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.ElectionResult.RoundResultsForEachChoice">
            <summary>Each voting round, sorted in descending order based on final results.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Elections.ElectionResult.CachedAllVotes">
            <summary>Data about all votes, filled in on-demand.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Elections.VoteCounts">
            <summary>Stores all the types of votes allowed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.ElectionUtils.RemoveElectionsConcerningProposables(Eco.Gameplay.Civics.Misc.IProposable[])">
            <summary>We make sure to remove all proposables that are related to the specified proposables.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Elections.Internal.ElectionPoll">
            <summary>Funcs for creating a poll election.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionPoll.CreatePollElection(Eco.Gameplay.Players.User)">
            <summary>Query the user for and create an election polling the userbase.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionPoll.CivicAction_StartPoll.Perform(Eco.Gameplay.Players.User,Eco.Gameplay.Civics.Elections.Election)">
            <summary>Start an election with the given properties.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionResultBuilder.GetWinnersAndLosers(Eco.Gameplay.Civics.Elections.RoundsForChoice[],Eco.Gameplay.Civics.ElectionChoiceID[],System.Boolean,System.Func{Eco.Gameplay.Civics.ElectionChoiceID,Eco.Gameplay.Civics.ElectionChoice},System.Double,System.Boolean,System.Boolean,Eco.Gameplay.Players.User[]@,Eco.Gameplay.Players.User[]@,System.Boolean@)">
            <summary>Determine data about final completion for the results.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionResultBuilder.GetVotesPerRound(System.Collections.Generic.IDictionary{Eco.Gameplay.Players.User,Eco.Gameplay.Civics.Elections.UserRunoffVote},System.Collections.Generic.IDictionary{System.String,Eco.Gameplay.Civics.Elections.TwitchVote},System.Collections.Generic.IList{Eco.Gameplay.Civics.ElectionChoice},System.Int32,System.Single,System.Func{Eco.Gameplay.Civics.ElectionChoiceID,Eco.Shared.Localization.LocString},System.Func{Eco.Gameplay.Civics.ElectionChoiceID,System.String},Eco.Core.Systems.IHasSerializableID,System.Boolean,Eco.Shared.Localization.LocString@)">
            <summary>Does the rounds of voting and calculates the list of votes each choice got in each round.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionResultBuilder.GetWinningChoices(System.Boolean,System.Int32,Eco.Shared.Items.TiedElectionOptions,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},Eco.Gameplay.Civics.Elections.RoundsForChoice[],System.Func{Eco.Gameplay.Civics.ElectionChoiceID,Eco.Gameplay.Players.User},System.Boolean@,Eco.Gameplay.Civics.ElectionChoiceID[]@)">
            <summary>Assign the winning choices, handling ties correctly. Also assign the 'Tied' bool. Return a description of any ties.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.ElectionResultBuilder.GetElectionCompletionState(System.Int32,Eco.Gameplay.Civics.ElectionProcess,System.Boolean,System.Boolean,System.Boolean,System.Single,System.Single,System.Double,System.Boolean,Eco.Gameplay.Players.User,System.Boolean,System.Boolean@,System.Boolean@,System.Nullable{System.Boolean}@)">
            <summary>Checks if the election should complete, and returns values about why.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.TwitchElectionUtil.NotifyTwitchVoterVoted(System.String,Eco.Gameplay.Civics.Elections.TwitchVote,Eco.Core.Systems.IHasID,Eco.Gameplay.Settlements.Settlement,System.Func{Eco.Gameplay.Civics.ElectionChoiceID,Eco.Shared.Localization.LocString})">
            <summary>Do the notification when a twich user votes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.TwitchElectionUtil.DescribeTwitchVotesInElection(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,Eco.Gameplay.Civics.Elections.TwitchVote}},System.Func{Eco.Gameplay.Civics.ElectionChoiceID,Eco.Shared.Localization.LocString})">
            <summary>Output several lines describing a bunch of twitch votes in an election.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Internal.TwitchElectionUtil.GetTwitchVotes(System.Collections.Generic.IDictionary{System.String,Eco.Gameplay.Civics.Elections.TwitchVote},System.Single,System.Int32,Eco.Shared.Localization.LocString@)">
            <summary>Compile a dictionary of ElectionChoiceIDs to the numer of weighted votes it has, using the TwitchVote data, and output a string to describe the result.</summary>
            <param name="maxPercentTwitchVotes">Cap the twitch votes to this percent of the total votes in the election.</param>
            <param name="userVotes">count of user votes</param>
        </member>
        <member name="T:Eco.Gameplay.Civics.Elections.TwitchVote">
            <summary>A vote from a twitch user. They dont do runoff voting, just a single selection.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.UserRunoffVote.TopChoiceOfRemaining(System.Collections.Generic.HashSet{Eco.Gameplay.Civics.ElectionChoiceID})">
            <summary>Find the first entry chosen of the remaining options.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.ElectionChoicePollOption">
            <summary>A manually defined poll option that can be set in an election.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawSection.Perform(Eco.Gameplay.Civics.Laws.Law,Eco.Gameplay.GameActions.GameAction)">
             <summary>
            When performaing a law section we want to allow some limited recursivity but we must make sure to prevent infinite loops.
            To prevent infinite loops we save the current section when it's being performed and prevent it from being performed again until it was completely done.
             </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawSection.InternalPerform(Eco.Gameplay.Civics.Laws.Law,Eco.Gameplay.GameActions.GameAction)">
             <summary>
            Performs the test of the law if it matches one of our triggers.
            Return possibilities:
            - null: no match
            - PostResult Success: Continue performing law sections.
            - PostResult Failure: Stop performing law sections.
             </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawUtil.DescribeActiveLawsAtPosition(Eco.Shared.Math.Vector2i)">
            <summary>Create a list of all the laws at the given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawUtil.CountActiveLawsAtPosition(Eco.Shared.Math.Vector2i)">
            <summary>Counts the active laws of all settlements at this position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.AliasMoneyTransfer_LegalAction.GetAllowedUsersFromTarget(Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.TransferInfo)">
            <summary>
            From the specified target, we get all the users that this legal action can interact with.
            If the settlement feature is enabled and the context is depended on the settlement then we only get the users that are part of the context settlement.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.TransferInfo">
            <summary> <see cref="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.GetAndCheckValues(Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Settlements.Settlement)" /> converts and checks game values using provided context and fills this container with the data. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.ComposeTransfers(Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.TransferInfo)">
            <summary>
            Using the passed TransferInfo values, we compose the transfers that we want to perform and then return a PostResult that will either inform us that it failed or it will have all the actions
            that we will need to perform if it succeeded.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.ComposeDefaultData(Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.TransferInfo,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Players.User)">
            <summary> Creates an instance of <see cref="T:Eco.Gameplay.Economy.Transfer.TransferData" /> and fills it with default values based on the provided params. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.DescribeAmount(System.Nullable{System.Single},System.String)">
            <summary> Uses provided value to compose a message in a format "X currency name (description of X)" or some variants if something is not provided or the game value is a constant. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.AccountCanBeUsedInGovernmentTaxOrPayAction(Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Settlements.Settlement,Eco.Shared.Localization.LocString@)">
            <summary>
            We check whether the specified account can be used with the specified context and if not we return false and an error message.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GamePickerList`1">
            <summary>
            Generic version of GamePickerList. Gives access to the wrapped type of GamePickerList through reflection. Non-generic version is still supported.
            This happens because to obtain 'MustDeriveType', we'd need the object's instance, which is hard and inefficient to obtain.
            So, the generic version is introduced to wrap 'MustDeriveType' under 'T'. Now 'MustDeriveType' is easily obtainable through `memberInfo.GenericTypeArguments[0]`.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GamePickerList">
            <summary>Can store a list of IHasID's or a list of Types. A list that can be used to form UI lists of entries for the user to select from. Use <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerListFactory" /> to create new instance for a base type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GamePickerList.DescribeEntries(Eco.Shared.Localization.LocString)">
            <summary> Returns a hoverable link with entries inside. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GamePickerListAlias">
            <summary>Special case for a list of aliases that gives some extra features, allowing watching of the full list of users.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.GameValues.GamePickerListAlias.OnUserSetChanged">
            <summary>Triggers when user contents change, passing a list of both added and removed users.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.GameValues.GamePickerListAlias.UserSet">
            <summary>Returns all the users mentioned in our list.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GamePickerListFactory">
            <summary>Helper class for <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" /> creation. With <see cref="M:Eco.Gameplay.Civics.GameValues.GamePickerListFactory.Create(System.Type)" /> method you can create best suitable <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" /> implementation for a base type. Use it instead of <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" /> constructor.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GamePickerListFactory.Create(System.Type)">
            <summary>Creates new <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" /> best suitable for <paramref name="baseType" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValue`1.Value(Eco.Core.Utils.PropertyScanning.IContextObject)">
            <summary>Evaluates value with exception handling and returns <see cref="F:Eco.Core.Utils.Eval`1.Invalid" /> value if exception happens.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValue`1.Evaluate(Eco.Core.Utils.PropertyScanning.IContextObject)">
            TODO: In 10.0 make this abstract and Value non-virtual. We don't wanna break Mods API in intermediate release.
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueContext`1.#ctor(System.Reflection.PropertyInfo)">
            <summary>We just pass the property that we want to use as context and this construction will get all the necessary values by itself.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.MakeGameValue">
            <summary>A GameValue factory for the most used cases.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.MakeGameValue.UserContext(System.Type,System.String)">
            <param name="type">The type that has the property that we want to use as context.</param>
            <param name="propertyName">The name of the property that we want to use as context (It must be of type User).</param>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GameValueType">
            <summary> Contains data about a given GameValue type, for the client to use when building its list.  </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GameValueTypeContext">
            <summary> Class for a contextually specified type. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueUtils.TryLoc(Eco.Gameplay.Civics.GameValues.GameValue{System.Boolean},System.FormattableString,Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Players.User)">
            <summary>
            Does the test for a GameValue, notifies in a failure, and returns true or false for "should we continue"
            </summary>
            <param name="reqs"></param>
            <param name="failureDesc"></param>
            <param name="context"></param>
            <param name="notify"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueUtils.IsSimpleTrue(Eco.Gameplay.Civics.GameValues.GameValue{System.Boolean})">
            <summary>If the game value is a simple wrapped value that's always true then we return true.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueUtils.IsSimpleFalse(Eco.Gameplay.Civics.GameValues.GameValue{System.Boolean})">
            <summary>If the game value is a simple wrapped value that's always false then we return true.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueUtils.FailNullSafe``2(Eco.Gameplay.Civics.GameValues.GameValue,Eco.Core.Utils.Eval{``1},System.String)">
            <summary> Make a generic Fail Eval param with a nice message. Assumes the paramname is already tagged as localized elsewhere (as members are when marked with [Eco]). </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.NamedVariable">
            <summary> A form that allows users to give a name to specified float game value.
            These names are bieng replaced with their definition during evaluation process of the formula defined in parent <see cref="T:Eco.Gameplay.Civics.GameValues.TextFormula" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.TextFormula.GenerateDescription">
            <summary>Generates description by <see cref="P:Eco.Gameplay.Civics.GameValues.TextFormula.Formula" />. Replaces Name and Definition variables with links.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeOwnedResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> owned by <paramref name="alias" /> and compares result with <paramref name="testOwned" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeAuthorizedResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> authorized for <paramref name="alias" /> and compares result with <paramref name="testAuthed" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeResidentResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> is the residence for <paramref name="alias" /> and compares result with <paramref name="testAuthed" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.CategoryExtensions.Test``1(Eco.Shared.Items.CategoryContainment,System.Collections.Generic.IEnumerable{``0},System.Func{``0,Eco.Core.Utils.Eval{System.Boolean}},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>Tests if elements from a set are contained in another set using passed function for testing.</summary>
            <param name="containerName">Name of the set which has to contain or not contain elements of the passed set. Used to create message describing the result.</param>
            <param name="set">Set that will be tested for specified requirements.</param>
            <param name="evalulate">Function that returns true if passed element of the passed set is contained in the other set. Also returns name.</param>
            <param name="hasString">String used to describe situation when elements are part of a set (like 'are part of').</param>
            <param name="notHasString">String used to describe situation when elements are not part of a set (like 'are not part of').</param>
            <param name="elementTypeSingular">Word that describes elements of the set in singular form. Used to create text for link that opens a foldout list if list of elements is too long (like '1 element').</param>
            <param name="elementTypePlural">Word that describes elements of the set in plural form. Used to create text for link that opens a foldout list if list of elements is too long (like '9 elements').</param>
            <returns>Eval with value indicating whether the test was passed and message explaining why test was passed or not in format 'containerName hasString/notHasString list-of-elements'.</returns>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.CategoryExtensions.Test``1(Eco.Shared.Items.RequiredTrue,System.Collections.Generic.IEnumerable{``0},System.Func{``0,Eco.Core.Utils.Eval{System.Boolean}},Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>Tests if passed cases evaluate to boolean value matching defined requirement using passed function for evaluation.</summary>
            <param name="containerName">Name of the object for which cases are tested. Used to create message describing the result.</param>
            <param name="cases">Cases that will be tested for specified requirements.</param>
            <param name="evaluate">Function that returns boolean Eval value to which passed case is evaluated, uses Message as name.</param>
            <param name="trueString">String used to describe situation when cases are evaluated to true (like 'are true').</param>
            <param name="falseString">String used to describe situation when cases are evaluated to false (like 'are false').</param>
            <param name="elementTypeSingular">Word that describes all cases in singular form. Used to create text for link that opens a foldout list if list of cases is too long (like '1 case').</param>
            <param name="elementTypePlural">Word that describes all cases in plural form. Used to create text for link that opens a foldout list if list of cases is too long (like '9 cases').</param>
            <returns>Eval with value indicating whether the test was passed and message explaining why test was passed or not in format 'containerName trueString/falseString list-of-cases'.</returns>
        </member>
        <member name="T:Eco.Gameplay.Civics.ICivicObject">
            <summary> Interface for Civic Objects to inherit from. Used to soft-lock the object to a settlement. </summary>
            <remarks> e.g.: When a Capitol of a country enters the region of a town, since it's soft-locked, it will remain within the country's jurisdiction, instead of the town's. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.SettlementParentChanged(System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>Get called whenever this settlement parent changes and make sure to update the old parent properties according to their immigration policies.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.CheckCanCreateChildSettlement(Eco.Gameplay.Players.User)">
            <summary>We check whether the specified user can create a child settlement inside the current one or not (we check both this settlement and all its parents).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.CheckCanJoinAsCitizen(Eco.Gameplay.Players.User)">
            <summary>We check whether the specified user can become a citizen of this settlement or not (we check both this settlement and all its parents).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.CanLeaveWithProperties(Eco.Gameplay.Players.User,System.Collections.Generic.List{Eco.Gameplay.Property.Deed}@)">
            <summary>We check whether the specified user can take his properties with him when leaving this settlement (If he doesn't own any, this will return a success).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.CanBePropertiesHeir(Eco.Gameplay.Aliases.IAlias)">
            <summary>Check whether the specified alias can be this settlement property heir when a citizen leaves or not.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Immigration.ImmigrationPolicy.SpawnPoint">
            <summary>Define the position a new player will spawn at if they join this settlement instantly.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Immigration.InitialSpawnPoint">
            <summary>Contains a single point for a spawning option.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Immigration.InitialSpawnManager">
            <summary>Class that handles giving players choices where they would like to initially spawn.
            Provides two sets: procedurally generated spots, based on clusters of resources, and settlements that are accepting new 
            citizens.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.UpdatedInitialPoints">
            <summary>Invoked when the initial points are regenerated.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.SpawnPoints">
            <summary>The spawn points created from last generation.</summary>
        </member>
        <member name="F:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.UpdateTimer">
            Update on this frequency. Can be pretty infrequent
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.StartHere(Eco.Gameplay.Players.Player,Eco.Gameplay.Civics.Immigration.InitialSpawnPoint)">
            <summary>Called by a player when they want to spawn at a given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.GenerateAllSpawnPoints(System.Boolean)">
            <summary> Generates spawn points. If DisplayOnlySettlements (in the configuration) is true and there are settlements this method will generate only settlements points </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.GetSettlementPoints">
            <summary>Returns all settlements with spawn points available.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.CreateDebugPoints(System.Collections.Generic.List{System.Collections.Generic.List{Eco.Shared.Utils.ClusteringAlgos.Cluster}})">
            <summary>Creates debug data displaying all the clusters</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.BuildAttractantMaps">
            <summary>Builds an array of float-maps, each corresponding to a different attractant type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.CreateInitialSpawnFromAttractantClusters(System.Collections.Generic.List{System.Collections.Generic.List{Eco.Shared.Utils.ClusteringAlgos.Cluster}})">
            <summary>Analyze the map to find clusters of resources and other incentives for initial starting positions, then 
            create a list of points with descriptions.  Accepets lists of clusters for each attractant type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.SumUnclaimedIntoBucket(Eco.Shared.Utils.Array2D{System.Boolean},Eco.Shared.Utils.Array2D{System.Single},Eco.Simulation.WorldLayers.Layers.WorldLayer,System.Single)">
            <summary>Go through all the buckets on unclaimed land, and query the value of the world layer there, and sum it to that bucket pos.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Immigration.InitialSpawnManager.DescribePoints">
            <summary>Describes the points available for initial spawn.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Internal.ElectionChatCommands.SendVote(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Gameplay.Civics.Elections.Election,Eco.Gameplay.Civics.ElectionChoiceID[],Eco.Gameplay.Players.User)">
            <summary>Vote in the given election. Pass a user or a bool and whichever type of election it will use the given value.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Misc.CivicsTooltip">
            <summary>
            Tooltip handler for Civics tooltips.
            <para> TypeTooltip hands over the tooltip generation logic to this class for type properties that are being hovered. </para>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.GetOrAddCachedTooltip(System.Type)">
            <summary> Tries to get the tooltip text for a specific type from cache -- if it isn't cached, generates, caches, then returns it. <para> Cached tooltips are localized. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.MakeTwoPartsTable(System.Type,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString})">
            <summary> A table with two parts for the type. One with members that match the func, and another with the ones that don't. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.FormTable(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.Collections.Generic.List{Eco.Shared.Localization.LocString})">
            <summary> Forms and returns a table that is ready to be used by Client's UI after passing through 'Text.Table'. <para> Consists of a header, followed by a row for each property. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsUtils.CanBeAssignedToContainer(Eco.Gameplay.Civics.Misc.IProposable,Eco.Gameplay.Placement.IOrphanAssignment)">
            <summary>
            This is used to check whether we can assign an orphan proposable to a container or not.
            Usually all classes that implement the IProposable interface have the same check that's why we just call this function when implementing IHostedObject.CanBeAssignedTo.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsUtils.Open(Eco.Gameplay.Civics.Misc.IProposable,Eco.Gameplay.Players.Player)">
            <summary>Open for read-only viewing (No need for a specific access type, everybody should be able to view a proposable).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsUtils.UpdateChildArticleStates(System.Collections.Generic.IEnumerable{Eco.Gameplay.Civics.CivicArticle},Eco.Gameplay.Civics.Misc.IProposable,Eco.Shared.Items.ProposableState)">
            <summary>
            Meant to be called when a <see cref="T:Eco.Gameplay.Civics.Misc.SimpleProposable" /> Object which contains a list of CivicArticles has changed it's state
            i.e. a Constitution. This function changes the states of those child CivicArticles as well as update the parent 
            (if there is none) and HostObject. <paramref name="state" /> may differ from <paramref name="proposable" /> state in case
            if we call this function *right before* parent state change. 
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsUtils.GetHostedProposables(System.Collections.Generic.IEnumerable{System.Type},Eco.Gameplay.Objects.WorldObject)">
            <summary> Returns objects that are currently hosted on this world object. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.DisplayErrorUIExtension.CheckAndUpdateValidity(Eco.Gameplay.Civics.Misc.IDisplayErrorUI,System.Reflection.PropertyInfo,System.Object)">
            <summary>
            This function will check and update IDisplayErrorUI.Errors property.
            </summary>
            <param name="displayErrorUI"></param>
            <param name="prop"></param>
            <param name="objParent"></param>
        </member>
        <member name="T:Eco.Gameplay.Civics.Misc.ExactlyOnePerHostAttribute">
            <summary>
            Put this tag on a civic object to say that when there are orphans of this type, we should make sure that the player chooses exacly one of them to set on the host object.
            This is usually used with classes that implement the <see cref="T:Eco.Gameplay.Placement.IHostedObject" /> interface.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Misc.RequiresSettlementAttribute">
            <summary>Put this on types that shouldnt be spawned willy-nilly, because they need to have settlements assigned to function.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Misc.RPCAuthMaxProposableStateAttribute">
            <summary>Marks a RPC method for <see cref="T:Eco.Gameplay.Civics.Misc.SimpleProposable" /> as allowed only for states between <see cref="P:Eco.Gameplay.Civics.Misc.RPCAuthMaxProposableStateAttribute.MinState" /> and <see cref="F:Eco.Gameplay.Civics.Misc.RPCAuthMaxProposableStateAttribute.MaxState" />. See <strong>RPCAuthorization.md</strong> for details.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.SimpleProposable.OnBeforeStateChangeInternal(Eco.Shared.Items.ProposableState)">
            <summary>Callback before state change, we need it separate from OnStateChangedInternal to ensure when we set State any State subscription will deal with valid state.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.SimpleProposable.OnStateChangedInternal">
            <summary>Callback when state changed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.SimpleProposable.IsOwnerAccessAuthorized(Eco.Gameplay.Players.User)">
            <summary>Checks if owner access authorized for <paramref name="user" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.SimpleProposable.IsFullAccessAuthorized(Eco.Gameplay.Players.User)">
            <summary>Checks if full access authorized for <paramref name="user" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.ProposableUtils.HasValidConstitution(Eco.Gameplay.Civics.Misc.IProposable)">
            <summary>Checks if the settlement associated with this proposable is active and valid.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.ReferenceTracker.GetAllReferencedBy(System.Collections.Generic.IEnumerable{Eco.Core.Systems.IHasID})">
            <summary>Given a list of IDs, find all the things that could reference any of them which we track.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.ReferenceUpdater.UpdateReferences(System.Collections.Generic.Dictionary{Eco.Core.Systems.IHasID,Eco.Core.Systems.IHasID},Eco.Core.Systems.IHasID)">
            <summary>Special case for just changing references in all possible reference places for a set of object pairs.
            Can also take an additional thing that is referenced and ensure all the references are updated there.
            Returns a description of results.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Objects.CivicObject">
            <summary>
            An object that can have civic slots and/or civic actions.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Objects.UniqueSettlementCivicItem`1.GetCoreProposableHostedObject(Eco.Gameplay.Settlements.Settlement)">
            <summary>We get the core proposable hosted object of this civic type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Titles.AppointedTitle">
            <summary>
            A title that can be assigned managers and users.
            This is different from an <see cref="T:Eco.Gameplay.Civics.Titles.ElectedTitle" /> in that it can be created and set by anyone at a Registrar object, whereas <see cref="T:Eco.Gameplay.Civics.Titles.ElectedTitle" /> can only be set via elections.
            Functionally, they both serve the same purpose: defining a set of users represented by a title.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Titles.ElectedTitle.GetLatestOfficeHolders">
            <summary>Get list of current or latest holders of this office, if there is none we get an empty list</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Titles.IHasBackupOwner">
            <summary> When an element with this interface is removed, all of its property goes to this deputy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.AirPollutionComponent.ApplyLawAndGetResult">
            <summary> Checks if the Law allows Air Pollution. If it doesn't, turns off component. Returns result with message. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.AirPollutionComponent.TryGetPollutionPosition(Eco.Shared.Math.Vector3i@)">
            <summary>Returns position where air pollution will be produced by the component.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.AuthItemData.SetConsumers(System.Collections.Generic.IEnumerable{Eco.Gameplay.Aliases.IAlias})">
            <summary>Set consumers and invoke the consumers updated event.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.AuthDataTrackerComponent">
            <summary> Tracks object's consumers list and saves it into persistent data. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Auth.IAuthChangeListenerComponent">
            <summary>
            Interface to be used with <see cref="T:Eco.Gameplay.Objects.WorldObjectComponent" />s.  If present, the component
            will get events from the parent <see cref="T:Eco.Gameplay.Objects.WorldObject" /> about auth ownership changes.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Auth.PropertyAuthComponent.UpdatePlot">
            <summary>We update the plot that's the property is currently on.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BankComponent.CreateBankAccount(Eco.Gameplay.Players.Player,System.Boolean)">
            <summary>Add a bank account through DualPermission logic and set a Host Object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BankComponent.UpdateBankAccounts">
            <summary>Track changes in accounts and update cache for this component. Notify client to update a list./// </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.BedComponent">
            <summary>Handles sleep for player through bed objects with <see cref="P:Eco.Gameplay.Components.BedComponent.MountComponent" /> and <see cref="T:Eco.Gameplay.Systems.SleepManager" />
             and has a button to open the sleep manager.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.BedComponent.SleepingUsers">
            <summary>Stores users as value and seat number that is occupied by user as key. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.BedComponent.MountComponent">
            <summary>Returns <see cref="P:Eco.Gameplay.Components.BedComponent.MountComponent" />. Cannot return null, because it's required. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.BedComponent.HasFreeSpace">
            <summary>Make check for free space by checking <see cref="P:Eco.Gameplay.Components.BedComponent.SleepingUsers" /> with seats count in <see cref="P:Eco.Gameplay.Components.BedComponent.MountComponent" /> due to beds
            depend on <see cref="P:Eco.Gameplay.Components.BedComponent.MountComponent" /> and have no own max seats count. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.Sleep(Eco.Gameplay.Players.Player)">
            <summary> Use this for player to sleep in bed only. Uses <see cref="P:Eco.Gameplay.Components.BedComponent.MountComponent" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.Wake(Eco.Gameplay.Players.User)">
            <summary>Dismounts user from bed, removes from list of "sleepers", removes OnEnterWorld sub. Wakes user in <see cref="T:Eco.Gameplay.Systems.SleepManager" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.OnPickup(Eco.Gameplay.Players.Player)">
            <summary>To avoid awkward behaviour wakes all users in current bed on pickup. </summary>
            <param name="player"></param>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.GetComponentPickupConfirmation">
            <summary>Returns confirmation popup text for player that want to pickup bed with sleeping players. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.Destroy">
            <summary>To avoid awkward behaviour wakes all players on current bed on destroy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.WakeUpUsers">
            <summary>Wake all the players are sleeping on this bed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.OnSleepingUserEntersWorld(Eco.Gameplay.Players.User)">
            <summary>Mounts player back on bed if he logged out in bed </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BedComponent.UpdateOfflineSleepersForManager">
            <summary>Used in init only! Required to call on server restart to restore sleeping players. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.BoatComponent">
            <summary>
            Represents a boat. This component should be attached to all boats/vessels.
            Handles boat moorage posts attachment.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.BoatComponent.BoatSize">
            <summary>Represents the size of a boat. Will be used in the moorage post, to check if the boat size is supported by the moorage post.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.BoatMooragePostComponent">
            <summary>
            Component used by boat moorage posts.
            Allows attaching and detaching boats.
            Finds boats nearby player that can be attached and detached, filtering allowed boats by player authorization.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.Destroy">
            <summary>When moorage post is destroyed, we need to detach any attached boats.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.FindAuthorizedBoatsInRange(Eco.Gameplay.Aliases.IAlias)">
            <summary>
            Finds all nearby boats that have authorized access by a player.
            Called when the player interacts with the boat moorage post.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.FindAllBoatsInRange">
            <summary>
            Find all boats that are within range of this moorage post.
            If a new boat is within range, or a boat that was in range is not anymore, update the property <see cref="M:Eco.Gameplay.Components.BoatMooragePostComponent.AuthorizedBoatsInRange(Eco.Gameplay.Players.Player)" /> so players can see the boat changes.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.TryAddBoatInRangeAndCheckIfChanged(Eco.Gameplay.Components.BoatComponent,System.Collections.Generic.HashSet{Eco.Gameplay.Components.BoatComponent},System.Boolean@)">
            <summary>
            Add a boat to the list of boats in range (if it's not yet in the list).
            Then try to remove the boat from the list of previous boats (that is, the boats that were in range of the moorage post in the last lookup).
            If the boat can't be removed from the previous boats in range, we set <paramref name="changed" /> to true, to indicate that the boats in range has changed since the last lookup.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.UpdateBoatsInRange(Eco.Gameplay.Players.Player)">
            <summary>
            RPC to check for the boats that are in range of this moorage post and are authorized by a player.
            Called when a player opens the boat moorage post UI.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.LockBoat(Eco.Gameplay.Players.Player,Eco.Gameplay.Components.BoatComponent)">
            <summary>Lock/attach a boat to this moorage post if possible. Otherwise, show error message to player.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.UnlockBoat(Eco.Gameplay.Players.Player,Eco.Gameplay.Components.BoatComponent)">
            <summary>Unlock/detach a boat from this moorage post if possible. Otherwise, show error message to player.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.CheckBoatValidLockAndShowError(Eco.Gameplay.Players.Player,System.Boolean,System.String)">
            <summary>Check if a condition to lock or unlock a boat is valid. If it's not, send error message to player. Returns true if condition is valid, false otherwise.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.ForceUnlockBoat(Eco.Gameplay.Components.BoatComponent)">
            <summary>
            Actually handles unlocking a boat from the moorage post.
            Can't be directly called from players.
            It's called on <see cref="M:Eco.Gameplay.Components.BoatMooragePostComponent.UnlockBoat(Eco.Gameplay.Players.Player,Eco.Gameplay.Components.BoatComponent)" /> after all safety checks are done.
            It's also called when the moorage post is destroyed or when a boat is destroyed.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.BoatMooragePostComponent.ObjectIdToBoatComponent(System.Guid)">
            <summary>
            Try to get a boat component from an object ID.
            Used in conjunction with <see cref="F:Eco.Gameplay.Components.BoatMooragePostComponent.attachedBoatIDs" />
            If an object with the ID does not exist, or if the object does not contain a boat component, return null.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UpdateSubscriptions(Eco.Gameplay.Components.IChunkSubscriber)">
            <summary> Update the chunk subscriptions for this subscriber. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UpdateSubscriptionsWithChunks(Eco.Gameplay.Components.IChunkSubscriber,System.Collections.Generic.List{Eco.Shared.Math.Vector3i})">
            <summary> Update the subscriptions for this subscriber to specific chunks. (Note: Removes previous subscriptions.) </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UnSubscribe(Eco.Gameplay.Components.IChunkSubscriber)">
            <summary> Unsubscribes the given subscriber from all chunks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CivicObjectComponent.DisableProposables">
            <summary>We make disable all proposables, meaning we make all the active ones as drafts again, we remove the draft ones and delete all elections currently in progress for them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CivicObjectComponent.OnCloseEdit(Eco.Gameplay.Civics.Misc.IProposable,Eco.Gameplay.Civics.Misc.IProposable)">
            <summary>Whenever the player stop editing a proposal, this method gets called.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ConstitutionComponent.OnElectionComplete">
            <summary>Called when election to ratify this constitution is completed, whether it succeeded or failed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.ContributeSelectedItem(Eco.Gameplay.Players.Player,Eco.Shared.SharedTypes.InteractionTriggerInfo,Eco.Shared.SharedTypes.InteractionTarget)">
            <summary>Contributes carried or selected item to the workorder</summary>
            interactionContextTODO: Implement parameter updating for the 'ActiveWorkOrder' instead of passing UILink from server.
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.GetConnectedInventories(Eco.Gameplay.Players.User,System.Boolean,System.Boolean)">
            <summary>
            gets all valid inventories we can take/put items
            </summary>
            <param name="user"></param>
            <param name="input">require take ability from inventories</param>
            <param name="output">require put ability from inventories</param>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.UpdateTotalCraftingTimer">
            <summary>When <see cref="P:Eco.Gameplay.Components.CraftingComponent.BottleNecked" /> value has changed. We have to update the state of the crafting timer. Start counting the time if it isn't bottle necked. Otherwise stop the counting.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.MakeOrderNotification(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Make a message with a few work orders and users, detailed information is not necessary here.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.MakeSingleUserSingleWorkorderNotification(Eco.Shared.Localization.LocString,Eco.Gameplay.Items.WorkOrder)">
            <summary>Build a notification message for a single user with a signle workorder.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.MakeSingleUserMultipleWorkordersNotification(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>Build a notification message for a single user with a multiple workorders.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.MakeMultipleUserMultipleWorkorderNotification(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.WorkOrder},System.Int32)">
            <summary>Build a notification message for a multiple users with a multiple workorders.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.AddLabor(Eco.Gameplay.Players.User,System.Int32)">
            <summary> Adds labor to the first available work order. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.CraftingFees">
            <summary>
            This class allows to calculate, pay and store escrowed payments withing craft/repair.
            Tables which has CreditComponent could set fee for using that table. This class will operate with payments allowing to retrieve back paid money for canceled work orders.
            Stores fee data on the moment work order was created. So further changes to fee/currency would not affect stored payment.
            When payment is requested, money are transfered to Escrow account saving all needed transfer info within serialized fields.
            When using escrow account is not needed (repair or craft single item) transfer is performed instantly.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayRepairFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Items.Item)">
            <summary>Pay repair fees instantly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayCraftingFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,System.Single,System.Int32,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Items.WorkOrder)">
            <summary> Try to pay crafting fees for work order. If multiple orders queued payment transfered to escrow account and owner will receive payment per finished order. On work order cancel tries to refund. Otherwise returns null.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayCraftingFee">
            <summary>Pay stored crafting fee per 1 unit. If table becomes public or free - refund all stored money.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.RefundCraftingFee">
            <summary>Refund remaining fees if any left in escrow bank account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.CreditDataChanged">
            <summary>When CreditData changed checks if we are still have to pay. If not - refund all stored money.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,System.Single,System.Int32,Eco.Gameplay.Economy.BankAccount,Eco.Shared.Localization.LocString)">
            <summary>Pay fees instantly, transfer data not stored</summary>
        </member>
        <member name="F:Eco.Gameplay.Components.CreditItemData.SelectedBankAccountBalanceChangedEvent">
            <summary>Raised when balance for <see cref="P:Eco.Gameplay.Components.CreditItemData.Currency" /> changes in <see cref="P:Eco.Gameplay.Components.CreditItemData.BankAccount" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CreditItemData.OnBankAccountValidityChanged(System.Boolean)">
            <summary> Listener for when validity of bank account gets changed, this basically removes it and sets the bank account as null. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.DoorComponent">
            <summary> Component containing necessary logic for doors. Enables the Open/Close interactions. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ElevatorComponent.ReceiveUpdate(Eco.Shared.Serialization.BSONObject)">
            <summary>Update cage's position, velocity and state.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.ExchangeEntry">
            <summary>Represents an exchange between two currencies.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.ExchangeComponent">
            <summary>WorldObject component that allows players to trade currencies with each other.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ExchangeComponent.VerifyObjectState(Eco.Gameplay.Aliases.IAlias,System.Boolean,System.String@)">
            <summary>Checks if the <see cref="T:Eco.Gameplay.Components.ExchangeComponent" /> is currently valid and able to be used. Returning a check boolean and user friendly message for any discovered problems.</summary>
            <param name="requester"><see cref="T:Eco.Gameplay.Aliases.IAlias" /> requesters trying to access the object.</param>
            <param name="stateTwitch">Boolean flag to determine if this request came from a state switch event.</param>
            <param name="message">User friendly message describing the identified issue.</param>
            <returns>True if the object state was verified. False if there were discovered issues.</returns>
        </member>
        <member name="M:Eco.Gameplay.Components.ExchangeComponent.TryOnOffStateChange(Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Called whenever our <see cref="T:Eco.Gameplay.Components.OnOffComponent" /> instance would like to change state and verifies the state change can occure based on owner information.</summary>
            <param name="user">The Eco user attempting to change state</param>
            <param name="newState">The requested On/Off state the component would like to change into.</param>
            <returns><see cref="T:Eco.Core.Utils.Result" /> instance containing the results of the verification and a user friendly localized message.</returns>
        </member>
        <member name="T:Eco.Gameplay.Components.ForSaleComponent">
            <summary>A component that allows purchase + pickup of a world object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ForSaleComponent.SetConfig(Eco.Gameplay.Components.ForSaleComponent.SaleTypes,System.Func{Eco.Shared.Localization.LocString},System.Func{Eco.Gameplay.Items.Item})">
            <summary>Config how this for-sale component works.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ForSaleComponent.CanBuy(Eco.Gameplay.Players.User)">
            <summary>Can only buy it if its for sale, has valid props, and user isnt already an owner (unless force enabled)</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ItemDistributionData.HasChanges">
            <summary>Checks if <see cref="T:Eco.Gameplay.Components.ItemDistributionData" /> has changes from <see cref="P:Eco.Gameplay.Components.ItemDistributionData.DifferenceSource" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.JurisdictionComponent">
            <summary>Component that allows setting an associated settlement with a world object based on the settlements that are influencing the current position.
            This component can be combined into another tab if its own tab isnt needed.</summary>
        </member>
        <member name="E:Eco.Gameplay.Components.JurisdictionComponent.CanChangeAssociatedSettlement">
            <summary>Callback that checks if changing the settlement is allowed.  Callback is expected to do the error notification to the user.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.JurisdictionComponent.IsValid">
            <summary>Does this world object have a jurisdiction selected?</summary>
        </member>
        <member name="F:Eco.Gameplay.Components.JurisdictionComponent.DisableWhenInvalid">
            <summary>Set to false to prevent world object from being treated as disabled when no jurisdiction is selected.</summary>
            <remarks>This can be used for things like allowing crafting settlement foundation items on ballot box before jurisdiction is selected.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Components.JurisdictionComponent.SetSettlementOfJurisdiction(Eco.Gameplay.Players.Player,Eco.Gameplay.Settlements.Settlement)">
            <summary>Trys to assigns a settlement upon which the objects in this civic object will apply. Validates it to make sure its
            influencing us, and prevents changes if there are active or proposed ones.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.JurisdictionComponent.UpdateSettlementCorrect(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>Maintains a status entry that ensures the assigned settlement influences the given location.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.LadderComponent">
            <summary>Interactable ladder, teleports player to relative localtion inside world object</summary>
            Instead of directly adding logic to WorldObject component spliting to this component and add it where necessary
        </member>
        <member name="T:Eco.Gameplay.Components.LinkComponent">
            <summary> This component manages connections to other world objects within a given radius </summary>
            <remarks> This assumes the world object is stationary </remarks> 
            <inheritdoc />
        </member>
        <member name="P:Eco.Gameplay.Components.LinkComponent.BaseConnectionRadius">
            <summary>Radius measurement used to connect to other objects as defined in the object's definition.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.LinkComponent.ObjectConnectionRadius">
            <summary>Radius measurement used to connect to other objects with applied modifiers. Based on the <see cref="P:Eco.Gameplay.Components.LinkComponent.BaseConnectionRadius" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.LinkSettingsAlias(Eco.Gameplay.Aliases.IAlias)">
            <summary> This alias will be used to get settings instead of provided one.
            For demo see how shared link component overrides this value and returns parent's owner. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.GetSortedLinkedComponents(Eco.Gameplay.Aliases.IAlias,System.Boolean,System.Boolean)">
            <summary>
            Get Sorted linked storages which are able to take/put items. NOTE: will not omit
            storages with disabled link settings.</summary>
            <param name="alias"></param>
            <param name="source">is able to take items</param>
            <param name="target">is able to put items</param>
            <returns>list of storages</returns>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.NewDefaultLinkSettings(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Objects.WorldObject,System.Type)">
            <summary>
            Gets <see cref="T:Eco.Gameplay.Components.LinkComponent.LinkSettings" /> which <see langword="this" /> should use when linking to <see cref="T:Eco.Gameplay.Components.Storage.StorageComponent" /> of type <paramref name="compType" />
            attached to <paramref name="linkedObj" />
            </summary>
            <param name="alias"></param>
            <param name="linkedObj"><see cref="T:Eco.Gameplay.Objects.WorldObject" /> that <see langword="this" /> wants to link to</param>
            <param name="compType"><see cref="T:System.Type" /> of <see cref="T:Eco.Gameplay.Components.Storage.StorageComponent" /> attached to <paramref name="linkedObj" /> for which <see cref="T:Eco.Gameplay.Components.LinkComponent.LinkSettings" /> will be returned</param>
        </member>
        <member name="T:Eco.Gameplay.Components.MinimapComponent">
            <summary> Objects with this component will have a hoverable icon generated for displaying on client's minimap. </summary>
            <remarks> Those icons can be either static (baked to atlas for optimization) or non-static (pos sync in real time), based on if they're Movable or not. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Components.MinimapComponent.InitAsMovable">
            <summary> Marks the object as Movable. This can only be done before initialization is complete. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MinimapComponent.SetOverrideTarget(Eco.Gameplay.Minimap.MinimapObject)">
            <summary> Sets the position provider for the target object. If null, the object's position will be used. </summary>
            <remarks> Useful for fully syncing the positions of two minimap objects (e.g.: When a Player drives a vehicle). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Components.MinimapComponent.SyncPosition">
            <summary> Syncs the position of the MinimapObject with that of the parent WorldObject. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.MountComponent.IsMounted">
            <summary>Return true if any player is mounted. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.MountComponent.HasFreeSeat">
            <summary>Check for null values in occupants array. Returns true if found any. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.MountComponent.FirstFreeSeatIndex">
            <summary>Looking for null value in occupants array. Returns index of array if found, -1 if not. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.MountComponent.Seats">
            <summary>Count all seats Mount has. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.MountComponent.MountedPlayers">
            <summary>Returns non-null collection with players that currently mounted. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.Dismount(Eco.Gameplay.Players.Player)">
            <summary> Dismounts specific <paramref name="player" /> from all occupied seats. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.DismountSeat(System.Int32)">
            <summary> Dismounts player at specific <paramref name="seatIndex" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.DismountDestroyedPlayers">
            <summary> Dismounts all disconnected players. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.MountSeatOnFree(Eco.Gameplay.Players.Player)">
            <summary>Mount player on first free seat through <see cref="M:Eco.Gameplay.Components.MountComponent.MountSeat(System.Int32,Eco.Gameplay.Players.Player)" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.OnPickup(Eco.Gameplay.Players.Player)">
            <summary>dismount all in current mount on pickup. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.NameDataTrackerComponent">
            <summary>Tracks object's name changes and saves it into persistent data.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.OnOffComponent">
            <summary>World object component for adding enable/disable support to a world object.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer">
            <summary>Components with this interface can proide themselves via <see cref="M:Eco.Gameplay.Components.OnOffComponent.Setup(System.Func{Eco.Gameplay.Players.User,System.Boolean,Eco.Core.Utils.Result},Eco.Shared.Items.AccessType,System.Boolean,Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer)" /> to override default messages.See <see cref="T:Eco.Gameplay.Components.Store.StoreComponent" /> for a demo.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.OnOffComponent.On">
            <summary>Represents current state of the toggle.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.OnOffComponent.ShowOnToggle(Eco.Gameplay.Players.Player)">
            <summary>Determines whether the player has access to switch current state.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.OnOffComponent.RequiredAuth">
            <summary>The required auth level to enable/disable the world object instance..</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.OnOffComponent.AllowPopupControl">
            <summary>Enables support for this component instance to be turned on/off via the popup messages.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.OnOffComponent.Setup(System.Func{Eco.Gameplay.Players.User,System.Boolean,Eco.Core.Utils.Result},Eco.Shared.Items.AccessType,System.Boolean,Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer)">
            <summary>Overrides default behaviour of the component.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.OnOffComponent.SetOnOff(Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Check user's auth and tries to set the on-off state of the component. Can contain additional checks and feedbacks. See how <see cref="T:Eco.Gameplay.Components.Store.StoreComponent" /> changes behaviour of this component. Null user bypasses auth check.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.PerformCivicActionComponent.Settlement">
            <summary>Settlement used to perform civic actions.</summary>
            <remarks>
            Returned settlement is based on value from jurisdiction component or based on world object's position if no jurisdiction component is attached.
            In both cases it can be null.
            </remarks>
        </member>
        <member name="M:Eco.Gameplay.Components.PerformCivicActionComponent.Select(Eco.Gameplay.Players.Player,System.Type)">
            <summary></summary>
            <param name="player"></param>
            <returns></returns>
        </member>
        <member name="T:Eco.Gameplay.Components.PicturePrinterComponent">
            <summary>Worldobject component that allows selecting local images on the client and uploading them to server to be used as PictureItem. Is used on PicturePrinterObject and uses PicturePrinterUI on the client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.PicturePrinterComponent.PrintPicture(Eco.Gameplay.Players.Player,System.Byte[])">
            <summary>Called from the button on client PicturePrinterUI.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.PluginModulesComponent">
            <summary> Component which allows to add Plugin Modules to a world object (like better efficiency, longer labor queue etc). </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.PluginModulesComponent.AllowedModulesInfo">
            <summary> Cached information about allowed modules (tags) you can plug. Actual module items stored in inventory. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.PowerGeneratorComponent.UpdateJoulesPerSecond(System.Single)">
            <summary> Updates the output of this Power Generator and alters the Power Grid Component to reflect the change. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.SharedLinkComponent">
            <summary> This link component uses parent owner's shared link settings if provided alias has full access to the property. 
            In other words, users with full access can change linked objects and expect that other owners will also receive these changes.
            Currently used for stores. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SharedLinkComponent.HasFullAccess(Eco.Gameplay.Aliases.IAlias)">
            <summary> Checks whether this alias has full access to the property. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SharedLinkComponent.LinkSettingsAlias(Eco.Gameplay.Aliases.IAlias)">
            <summary> Overrides provided alias if it has full access (replaces it with parent owner). </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.SolarGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires a view of the sun. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.SetSkyCoordinates">
            <summary> Calculates a horizontal plane of coordinates that this generator cares about being clear of obstruction for the purpose of a clear view of the sky. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.UpdateChunkSubscriptions">
            <summary> Checks if there are any new chunks in the columns this generator occupies and subscribes to them. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.SkyTest">
            <summary>
            Adjusts power output based on this generators view of the sky.
            Calculated by selecting each block occupied in a horizontal footprint and checking if it is the top block or not.
            OutputPower = InitializedPower * PercentUncovered
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.StatusElement.Priority">
            <summary> Status component uses this value to order entries. The lower the value, the sooner this element appears in the list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StatusComponent.CreateStatusElement(System.Int32)">
            <summary>Creates a status element, with lower values of priority appearing first.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StatusComponent.RemoveStatusElement(Eco.Gameplay.Components.StatusElement)">
            <summary>Removes a status element that was previously added..</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.FuelSupplyComponent.CanConsumeFuel(System.Single)">
            <summary> Checks whether it's possible for the component to burn provided amount of energy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.FuelSupplyComponent.ConsumeAsMuchAsPossible(System.Single)">
            <summary>Consumes as much <paramref name="joules" /> as possible and returns actually consumed joules. It tries to load fuel from inventory when Energy fully consumed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Storage.InteractableStorage">
            <summary>Defines interactions that storages which should have put/take avaialble can use.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.InteractableStorage.GetItemsUserCanTake(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Item,System.Boolean,System.Func{Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.Item,System.Boolean})">
            <summary>Get items available to user in this inventory</summary>
            <param name="restrictionsPassed">possible restrictions of other inventories</param>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.Internal.StorageComponentUtils.Put(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.Inventory,Eco.Shared.SharedTypes.InteractionTarget,Eco.Shared.SharedTypes.InteractionModifier)">
            <summary>Put selected thing in given inventory.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.Storage.PublicStorageComponent.ShelfLifeMultiplier">
            <summary> Some specialized objects (like refrigerator) are designed to preserve food for a certain amount (shelf life and time remaining increase by this multiplier) </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.PublicStorageComponent.UpdateShelfLifeMultiplier">
            <summary> Check if WorldObject is enabled and update the ShelfLifeMultiplier provided by this storage </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Storage.SelectionStorageComponent">
            <summary> Generic selection storage </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.SelectionStorageComponent.CreateInventory(System.Int32,System.Int32,Eco.Gameplay.Items.InventoryRestriction[])">
            <summary>Need to be called when create object(in its Initialize) with this component</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Storage.WorldStockpileComponent">
            <summary> This stockpile has all its contents represented in the world as blocks (e.g. DirtBlock for dirt. Non-block items are represented as StockpileCrateBlocks). </summary>
            <remarks> Changes are synced in the world real time when the content of the stockpile's inventory changes. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.WorldStockpileComponent.SyncBlocksToWorld(System.Collections.Generic.HashSet{Eco.Shared.Math.Vector3i})">
            <summary> Updates blocks spawned by stockpile to match stockpile's inventory </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Storage.ModularStockpileComponent">
            <summary> This component packages up the blocks of a stockpile into a format that can be used by moving objects, such as vehicles. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Storage.StockpileCrateBlock">
            <summary> A generic block for items that aren't block items. Represented as a crate. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.StockpileComponent.TickOnDemand">
            <inheritdoc cref="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand" />
        </member>
        <member name="M:Eco.Gameplay.Components.Storage.StockpileComponent.UpdateStockpileFromInventory">
            <summary> Updates contents of <see cref="P:Eco.Gameplay.Components.Storage.StockpileComponent.BlockTypes" /> to match contents of <see cref="F:Eco.Gameplay.Components.Storage.StockpileComponent.storage" /> </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.Storage.StockpileStackRestriction.SurpassStackSize">
            <inheritdoc cref="P:Eco.Gameplay.Items.InventoryRestriction.SurpassStackSize" />
        </member>
        <member name="M:Eco.Gameplay.Components.Store.Internal.PurchaseData.TradeDesc(System.Boolean)">
            <param name="describeToTradeInit">Will you describe the trade to the player who initialized the trade?</param>
        </member>
        <member name="T:Eco.Gameplay.Components.Store.Internal.StoreCategory">
            <summary> Subgroup of offers at the store. Each group will be showed and handled separated by UI, allowing users to group similar elements as they want.  </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.Internal.StoreCategory.SetTrades(Eco.Gameplay.Players.Player,System.Collections.Generic.List{System.Int32})">
            <summary> It updates offers list to match item ids, creating or deleting offers as necesary. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.Internal.StoreCategory.GetBestName(System.Collections.Generic.List{System.Int32})">
            <summary> Choose the best title for the category based on the item tags in itemIDs. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Store.Internal.StoreItemData">
            <summary> This class contains stores data: all offers and currency. It handles callbacks for offer changes.  </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.StoreComponent.CreateCategoryWithOffers(Eco.Gameplay.Players.Player,System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            Creates new category and tries to pick best name based on tags
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.StoreComponent.GetLinkedInventories(Eco.Gameplay.Aliases.IAlias,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Get all linked inventories that work for any user in the alias.</summary>
            <param name="includeStoreStorage">Do we want to include the store own storage ?</param>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.StoreComponent.TryOnOffStateChange(Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Called whenever our <see cref="T:Eco.Gameplay.Components.OnOffComponent" /> instance would like to change state and verifies the state change can occure based on owner information.</summary>
            <param name="user">The Eco user attempting to change state</param>
            <param name="newState">The requested On/Off state the component would like to change into.</param>
            <returns><see cref="T:Eco.Core.Utils.Result" /> instance containing the results of the verification and a user friendly localized message.</returns>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.StoreComponent.BuildTransfers(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.Store.Internal.PurchaseData,Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount)">
            <summary> Adds related transfers to the pack. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.Store.StoreComponent.BuildStoreTradeNotifications(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Make a message with detains of trades that were made in this store</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.TradeOffer">
            <summary> Represents an offer of the store. Contains description of condition of sell/buy, the price, the kind of item. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.TailingsReportComponent">
            <summary> Component responsible for reporting any ground pollution producing items in the world object storage. </summary>
        </member>
        <member name="F:Eco.Gameplay.Components.TailingsReportComponent.TailingsInfo">
            <summary> Static collection which contains information about all ground pollution producing items. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.TailingsReportComponent.UpdateTailings">
            <summary> Checks storage for items producing ground pollution and updates the info in the TailingsCache/&gt;. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.VehicleComponent.OutOfFuel">
            <summary> This property set if Vehicle has fuel supply and it is out of energy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleComponent.TrySetSinking(Eco.Shared.Math.WrappedPosition3i)">
            <summary>This RPC is for setting vehicle is underwater or not using given position. Do nothing if vehicle is able to move underwater. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleComponent.UpdateStatus">
            <summary> Show/hides vehicle water status</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleComponent.CheckFuel">
            <summary> Updates fuel status for the vehicle (if <see cref="F:Eco.Gameplay.Components.VehicleComponent.fuelSupply" /> available). </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleModules.VehicleHoeComponent.EngagePlow(System.Boolean)">
            <summary> Toggle 'Plowing' mode on or off. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WardrobeComponent">
            <summary> Component that adds wardrobe in a storage panel, allows ability to swap clothing using interaction </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WaterRiverGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires river water. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.WaterTest">
            <summary>
            Tests if the Waterwheel meets all necessary conditions to function.
            The Waterwheel needs at least some of its blocks submerged in water to function, and needs to be free of obstructions.
            In order for water to fill blocks occupied by the waterwheel, some of the blocks have to be set as EmptyBlock, which opens the possibility of a block being placed there, so checks exist to ensure this has not happened.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.CheckPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Vector3i,System.Int32@,System.Boolean@,Eco.Shared.Localization.LocString@)">
            <summary> Checks the given positions for water or obstructions. </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="water"> How many positions are IWaterBlocks. </param>
            <param name="obstructed"> True if one of the blocks is NOT water or empty. </param>
            <param name="killReason"> The reason, if any, this position is invalid. Including the world-position of the offending block. </param>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.KillPower(Eco.Shared.Localization.LocString)">
            <summary> Sets the power to zero and updates the status message. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.InFreshwaterEnable">
            <summary> Determines if the generator is in Freshwater, if not it shuts down the generator. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.FreshWaterCheck(Eco.Shared.Math.Vector2i)">
            <summary> Returns true if the position provided is in Freshwater (of 50% or less saltwater). </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WindGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires a clear area for wind. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.UpdateChunkSubscriptions">
            <summary> Checks if there are any new chunks in the columns this generator occupies and subscribes to them. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.SetCoordinates">
            <summary> Calculates and stores the plane of coordinates to use in the WindCheck and RelevantChunkPositions(). </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.WindTest">
            <summary> Adjusts power output based on this generators view of the sky. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.PlotsComponent">
            <summary> Allows claiming connected plots to where the parent is placed. Adding claim papers will charge 
            it up. The deed map lets you make the claims.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.PlotsComponent.DescribePlotsClaimed">
            <summary>Describe the plots that are claimed and where theyre coming from. For a foldout in the description.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.PlotsComponent.CheckPaperIsAllowed">
            <summary>We use this to only allow claim papers that are compatible with the parent deed to be added to the inventory</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.SpawnedClaimsComponent">
            <summary>Component that spawns claim stakes and claim papers based on the size of a settlement. These can then be distributed to citizens to allow them to claim more land from their claim stakes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SpawnedClaimsComponent.UpdateStakesAndClaimsIfCrisis(Eco.Gameplay.Players.User)">
            <summary>Callback for when the claims inventory changes. If there's a property crisis for our settlement, it might need to despawn new stakes or claims added here, so watch it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SpawnedClaimsComponent.AdjustSpawnedStakesAndClaims(System.Type,System.Int32)">
            <summary>Callback we register with the settlement to create or remove claims from our inventory.  The settlement determines this based on number of citizens. 
            Returns the number of things spawned/removed.  Count can be positive (spawn) or negative (despawn).  It returns similarly: positive for spawned count,
            negative for despawned.</summary>
        </member>
        <member name="T:Eco.Gameplay.Culture.CultureConfig">
            <summary>Values related to the culture system, set via mods.</summary>
        </member>
        <member name="F:Eco.Gameplay.Culture.CultureConfig.ArtworkValueCalculation">
            <summary>Accepts a placed world object, the settlement it's displayed in, and a usertexture, and calculates the culture value.</summary>
        </member>
        <member name="F:Eco.Gameplay.Culture.CultureConfig.SameSettlementReputationMutliplier">
            <summary>The ArtworCalculation function by default uses this value to reduce domestic reputation.</summary>
        </member>
        <member name="T:Eco.Gameplay.Culture.CultureItems.PictureFrameComponent">
            <summary>A component that takes a PictureItem for displaying it on the world object</summary>
        </member>
        <member name="F:Eco.Gameplay.Disasters.DisasterPlugin.StockpileDetectionDistance">
            <summary> Crater size + this value is a minimum distance from crater center for a stockpile to update its inventory after meteor impact </summary>
        </member>
        <member name="M:Eco.Gameplay.Disasters.DisasterPlugin.GetCurrentImpactDateTime">
            <summary>Calculates the current impact <see cref="T:System.DateTime" /> instance.</summary>
            <returns>Calculated <see cref="T:System.DateTime" /> representing the time of impact.</returns>
        </member>
        <member name="M:Eco.Gameplay.Disasters.MeteorObject.UpdateImpactTime">
            <summary>Updates the currently set impact time for the meteor.</summary>
        </member>
        <member name="P:Eco.Gameplay.Disasters.MeteorObject.ConvertedImpactTime">
            <summary>The current impact time converted to seconds.</summary>
        </member>
        <member name="T:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer">
            <summary>
            A service that will store large strings for a given period of time, for users to view them at will using foldouts or other methods.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer.FoldoutLargeTextLoc(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Boolean,System.Single)">
            <summary>Creates a foldout that when clicked will display large text.</summary>
        </member>
        <member name="M:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer.FoldoutLargeMessageToAll(Eco.Shared.Localization.LocString)">
            <summary>Creates a foldout with truncated text as name that on hover will display full text.</summary>
            <returns>If text is considered large, returns it in form of a foldout.</returns>
        </member>
        <member name="M:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer.SaveTextToDictionary(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Boolean,System.Single)">
            <summary>Save large text to dictionary to get it by ID when needed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer.DisplayText(Eco.Gameplay.Players.Player,System.String)">
            <summary>Display a large text with the given ID.</summary>
        </member>
        <member name="M:Eco.Gameplay.Display.Dialogs.LargeTextDisplayer.DisplayFoldout(System.String)">
            <summary>Returns a large text with the given ID in form of a TooltipSection.</summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.IDynamicValueContext">
            <summary>
            <p>Context for evaluating Dynamic Values (passes as parameter to <see cref="M:Eco.Gameplay.DynamicValues.IDynamicValue.GetCurrentValue(Eco.Gameplay.DynamicValues.IDynamicValueContext)" />.</p>
            <p>It provides a way to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> in different contexts.</p>
            <p>In example <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> may be evaluated for <see cref="T:Eco.Gameplay.Players.User" /> - in this case you should create <see cref="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext" />.</p>
            <p>Alternatively you may need to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> for crafting table <see cref="T:Eco.Gameplay.Modules.PluginModule" /> - in this case you should create <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" />.</p>
            <p>Depending on context <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> may be evaluated in different ways. In example for <see cref="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext" /> <see cref="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.Position" /> will be retrieved from <see cref="T:Eco.Gameplay.Players.User" />,
            but for <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" /> it will use a crafting table position. Some values, like <see cref="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue" />, may only be evaluated for specific context, otherwise they will return base value.
            I.e. if you view Recipe from Ecopedia it will show unmodified ingredient amount and crafting time, but on crafting table it will show values modified by modules.</p>
            </summary>
        </member>
        <member name="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.User">
            <summary> User for which value should be evaluated (i.e. for <see cref="T:Eco.Gameplay.DynamicValues.TalentModifiedValue" />). </summary>
        </member>
        <member name="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.Position">
            <summary> Position where value should be evaluated (i.e. for <see cref="T:Eco.Gameplay.DynamicValues.LayerModifiedValue" />). </summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.AdditiveStrategy.ModifiedValue(System.Single,System.Int32)">
            <summary>
            Retrieves last value of this.Additions if level &gt;= this.Additions.Length
            For instance, this allows Skills MaxLevel to be increased over level 7 without breaking the server
            </summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.MultiplicativeStrategy.ModifiedValue(System.Single,System.Int32)">
            <summary>
            Retrieves last value of this.Factors if level &gt;= this.Factors.Length
            For instance, this allows Skills MaxLevel to be increased over level 7 without breaking the server
            </summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.ModuleContext">
            <summary> Dynamic Value Context for Module (like resource efficiency or speed efficiency). Can be used to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue">
            <summary> Dynamic value modified by Module. It retrieves the module from context and modifies value using the module. </summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.ModuleModifiedValue.#ctor(System.Single,System.Type,Eco.Gameplay.DynamicValues.DynamicValueType)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue" /> class.
            </summary>
            <param name="baseValue">Base unmodified value.</param>
            <param name="skillType">Skill associated with the value.</param>
            <param name="valueType">Type of value (Efficiency, Speed etc).</param>
        </member>
        <member name="F:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.objectBenefits">
            <summary>object type to smvs that pertain to it.  Generally these are items, but can also be objects such as trees</summary>
        </member>
        <member name="F:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.skillBenefits">
            <summary>Maps a skill type to smvs</summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.GetBenefitNameForType(System.Type)">
            <summary>Get UILink based on type using runtime type ids</summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext">
            <summary> Dynamic Value Context for User (like labor efficiency or yield increase). Can be used to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Common.WorkableExtensions.MoveWorkables(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.Common.Workable},Eco.Gameplay.Economy.ContainedWorkables,Eco.Gameplay.Objects.WorldObject,System.Int32)">
            <summary> Removes workables from their host containers and adds them to the provided one. Amount of entries to move can be capped. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.ContractBoardComponent.TryGetFromStash(Eco.Gameplay.Players.Player,System.Boolean,System.Boolean)">
            <summary> Checks if there are stashed entries and suggests to post them on this board. </summary>
            <returns> False if there are no stashed entries or if the player declined the suggestion. </returns>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.CurrencyInfo">
            <summary> Holds the necessary currency info for contract clauses related with currency transfers. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.IClauseList">
            <summary> Implement on classes that can host Clauses (e.g.: 'Contract' and 'ContractClauseNested'). </summary>
            <remarks> Used to get all hosted clauses from the parent level (e.g.: Contract will check its clauses and clauses that are children of ContractClauseNested at any level). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ClauseListExtensions.ClausesRecursive(Eco.Gameplay.Economy.Contracts.IClauseList)">
            <summary>Gets simple version of contract clause description in the format: X Contract Clauses</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.ActionPerformed(Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks if the given action have any implications and applied changes towards this contract, this to avoid applying same changes if multiple contracts are listening to the same action.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.FinishContract(Eco.Gameplay.Players.User,System.Boolean)">
            <summary> Called when the contract is finished. Could be called by the person who created the contract (<see cref="P:Eco.Gameplay.Economy.Contracts.Contract.ClientUser">Client</see>) using the method  <see cref="M:Eco.Gameplay.Economy.Contracts.Contract.JobFinished(Eco.Gameplay.Players.User)" />
            or by the person who accepted the contract (<see cref="P:Eco.Gameplay.Economy.Contracts.Contract.Contractor">Contractor</see>) in the method <see cref="M:Eco.Gameplay.Economy.Contracts.Contract.MarkJobFinished(Eco.Gameplay.Players.Player)" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.SetParentContract(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>We set the parent contract of the specified clause.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.RelevantUsers">
            <summary> Returns all the users that are involved in this contract -- the client and the contractor, if they're not null. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.DisableClauses">
            <summary>When the contract is removed/disabled, we need to clean all clauses from all subscriptions.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.ContractClause">
            <summary> Base class for any contract clause that a contract can contain. </summary>
            <remarks> Contract clauses are part of a contract and need to be completed in order to claim the rewards -- which is also a contract clause. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ContractClause.OnDisabled">
            <summary>This is called whenever the contract parent is removed and so all clauses must be cleaned from all subscription.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ContractClause.LateInit">
            <summary>This is always called after parent contract has already been initialized and set.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.ContractClauseNested">
            <summary> Contract clause that can host other contract clauses. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ContractClauseNested.OnClauseAdded(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>Whenever a new clause is added we should assign to it its parent contract, make sure to call the nested contract OnChanged whenever the clause is changed and update the pickers.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ContractClauseNested.OnClauseRemoved(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>When a clause is removed we make sure to call OnDestroy to clean all subscriptions and then update the clauses list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ContractManager.CalculateContractsDependingOnWorldObject(Eco.Gameplay.Objects.WorldObject)">
            <summary> Checks for any contract that use the given world object as a picking target, this is expensive and might need better implementation. </summary>
            <param name="obj">The world object that might be used.</param>
            <returns>The contracts that are using the given world object.</returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.CurrencyAndAmountGameValues.DoTransferLoc(System.FormattableString,Eco.Gameplay.Players.User,Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Economy.BankAccount,Eco.Shared.Items.TransferType)">
            <summary> Try to pay the fee in the given currency, querying for the bank account source. Handles all errors and notifications.</summary>
            <param name="propName">Name of the property as you want it displayed in the notifications, ie 'tuition fee'. It will be localized.</param>
            <param name="user">The user making the payment.</param>
            <param name="context">Context with which we query these params.</param>
            <param name="targetAccount">Account that its paid into.</param>
            <param name="type">The kind of transfer it classifies as.</param>
            <returns></returns>
        </member>
        <member name="T:Eco.Gameplay.Economy.DualPermissions">
            <summary>A dual-permissions object handles two sets of permissions: users and managers. Permissions are set by managers, and users cannot change permissions.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.DualPermissions.VerifyNewSetIsValid(Eco.Gameplay.Players.Player,Eco.Core.Utils.IClientControlledContainer,System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Verify if the player and the new set can be set to the container. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.DualPermissions.GetContainerPermissionType(Eco.Core.Utils.IClientControlledContainer)">
            <summary>We return whether it's the managers or the users container that's being modified.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.INullCurrencyAllowed">
            <summary> Credit component will hide null-crrency option on the client side
            if parent world object does not implement this interface. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.EconomyUtils.FillWithTools(Eco.Gameplay.Components.Store.StoreComponent,Eco.Gameplay.Components.Storage.StorageComponent)">
            <summary>Fills store with tools with different durability. Used with <see cref="M:Eco.Gameplay.Economy.EconomyUtils.SpawnToolsStore(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.EconomyUtils.FillStoreWithRandomItems(Eco.Gameplay.Components.Store.StoreComponent,Eco.Gameplay.Components.Storage.StorageComponent,Eco.Gameplay.Components.Storage.StorageComponent,System.Int32,System.Int32,System.Nullable{System.Single})">
            <summary>Fills store with random items. Used with SpawnStoreAndFillAndClaim.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.EconomyUtils.SpawnToolsStore(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i)">
            <summary>Spawns [store, stockpile, chest], links them and fills with tools.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.EconomyUtils.SpawnStoreAndFillAndClaim(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Gameplay.Property.Deed,System.Int32,System.Int32,System.Nullable{System.Single})">
            <summary>Spawns [store, stockpile, chest], links them and fills with some random items.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.EconomyUtils.SpawnStoreAndFillAndClaim(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Gameplay.Property.Deed,System.Action{Eco.Gameplay.Components.Store.StoreComponent,Eco.Gameplay.Components.Storage.StorageComponent,Eco.Gameplay.Components.Storage.StorageComponent})">
            <summary>Spawns [store, stockpile, chest], links them and fills with it using <paramref name="fill" /> action.</summary>
        </member>
        <member name="P:Eco.Gameplay.Economy.Jobs.IRecurringTransferService.AutoCreateAndUpdateTransferProps">
             <summary>
            true  -&gt; Auto create and update the transfers properties.
            false -&gt; Whenever we want to update the transfers properties we should call <see cref="M:Eco.Gameplay.Economy.Jobs.RecurringTransferServiceExtensions.UpdateTransfers(Eco.Gameplay.Economy.Jobs.IRecurringTransferService)" />.
            Sometimes we want to update the properties manually to prevent the transfers from being exploited like in <see cref="T:Eco.Gameplay.Property.RentForProperty" />.
             </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Jobs.IRecurringTransferService.OnTransferPropertiesUpdated">
            <summary>Whenever customers are added, removed or the active state get changed, this get called to update the transfer properties.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Jobs.RecurringTransferServiceExtensions.UnpaidWages(Eco.Gameplay.Economy.Jobs.IRecurringTransferService,Eco.Gameplay.Players.User,Eco.Shared.Localization.LocString)">
            <summary>We sent a private message to the user that didn't receive the transfer.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Jobs.RecurringTransfer.Initialize(Eco.Gameplay.Economy.Jobs.IRecurringTransferService)">
            <summary> Usually initialization is called when recurring transfer is created and its a moment when all data is setted.
            Some transfers are preserved over sessions and they have to be initializated only by setting service. It's a workaround for hotfix, should be refactored to have better archetecture. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Jobs.RecurringTransfer.UpdateValues(Eco.Gameplay.Economy.Jobs.IRecurringTransferService,System.Boolean,System.Boolean)">
            <summary>Calculate the values desired for the transfer and update them. Don't notify update during init, but if they're changed later do notify.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Jobs.RecurringTransferManager.OnTransferPropertiesUpdated(Eco.Gameplay.Economy.Jobs.IRecurringTransferService)">
            <summary>This gets called whenever customers are added, removed or the active state get changed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.CreateBankAccountAction(Eco.Gameplay.Players.User,Eco.Shared.Items.BankAccountAccessAction,Eco.Shared.Items.PermissionsType,Eco.Gameplay.Players.User)">
            <summary>We create a BankAccountPermissionsChange game action depending on the container that's being modified (managers or users).</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.TryAddOrRemoveManagerOrUser(Eco.Shared.Items.BankAccountAccessAction,Eco.Gameplay.Players.Player,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.PermissionsType)">
            <summary>Check whether we can add or remove all the users of an alias from the bank account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.TryAddManagerOrUser(Eco.Gameplay.Players.Player,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.PermissionsType)">
            <summary>Check if we're able to add a new manager or user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.TryRemoveManagerOrUser(Eco.Gameplay.Players.Player,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.PermissionsType)">
            <summary>Check if we're able to remove an old manager or user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.CanAccess(Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccountAccess,System.Boolean)">
            <summary>Check if IAlias has an access to use this account./// </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.GetResponsibleUser(System.Boolean)">
            <summary>Returns first found manager of the account</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.GetCurrencyHoldingVal(Eco.Gameplay.Economy.Currency)">
            <summary>Return total amount of a currency for this account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.GetCurrencyHoldingVal(Eco.Gameplay.Economy.Currency,Eco.Gameplay.Players.User)">
            <summary>Returns amount of a currency for this account owned by a user by percent ownership.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.DisplayAmount(Eco.Gameplay.Economy.Currency)">
            <summary>Returns string with description of currency amount on this account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.CanAnyAccess(Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccountAccess,System.Boolean)">
            <summary>Check if IAlias or any user of this IAlias can use this account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.AddCurrency(Eco.Gameplay.Economy.Currency,System.Single,System.Boolean)">
            <summary>Adds amount of currency to this account. Will fallback to zero if holdings become negative (set assertNegativeAmount if that was intended, otherwise an error will be logged).</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.RemoveCurrency(Eco.Gameplay.Economy.Currency)">
            <summary>Reduces holdings to zero (by removing an infinite amount).</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.SetAccountName(Eco.Gameplay.Players.Player,System.String)">
            <summary>Change an account name, will be validated at the same time.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.PercentOwnership(Eco.Gameplay.Players.User)">
            <summary>Returns user's percent ownership of this account for wealth calculation purposes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.DescribeWealth(Eco.Gameplay.Players.User)">
            <summary> Returns a string with user's percent ownership of this account. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.DescribeHoldings">
            <summary> Returns an entitled text block with this account's holdings. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccountManager.GetAccountsOfBackedCurrency">
            <summary>Return a tuple of accounts and holdings for all backed currencies.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccountManager.DirectTransfer(Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency,System.Single)">
            <summary> Public acessor for game action tests. Use <see cref="M:Eco.Gameplay.Economy.Transfer.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.Transfer.TransferData)" /> instead. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Money.BankAccountUtils">
            <summary>Functions for accessing and manipulating bank accounts</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Money.BankAccountUtils.AskUserForBankAccount(Eco.Gameplay.Players.User,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Presents a dialog for the user to choose a bank account.  If only one, automatically chooses it.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.PersonalBankAccount">
            <summary> Player's default bank account with an infinite amount of their personal currency. The player cannot be removed from managers list. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.GovernmentBankAccount">
            <summary> Accounts of this type can be targeted by Tax/Pay legal actions. Wealth calculations for users do not include these accounts. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.TreasuryBankAccount">
            <summary> This special account will be used as a default government account. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.ContractEscrowBankAccount">
            <summary> This special account will be used to temporary store payments for work parties and contracts. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Reputation.Internal.Reputation">
            <summary>Stores and manipulates reputation for anything deriving IHasReputation (citizens, artwork)</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.Internal.Reputation.WeightedPositiveSum(System.Func{Eco.Gameplay.Players.User,System.Single,System.Single})">
            <summary>Caluclate a weighted sum, with a passed in mult function. Only counts positive reputation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.Internal.Reputation.UpdateColorAndTitle">
            <summary>Given current values update the title and color.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.Internal.Reputation.GetReputationTitle(Eco.Gameplay.Economy.Reputation.Internal.ReputationTitle)">
            <summary>We return the current reputation title depending on whether this reputation is related to user or a generic object.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Reputation.Internal.ReputationTitle">
            <summary>Defines a vanity title (a text string) we apply when reaching a given reputation level.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Reputation.IHasReputation">
            <summary>Anything that can have rep (Citizens, artwork, etc).</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Reputation.ReputationManager">
            <summary>Primary interface for getting and setting rep on a class that implements IHasReputation</summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Reputation.ReputationManager.reputations">
            <summary>The reputation of anything that has one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.RepAndTotal(Eco.Gameplay.Economy.Reputation.IHasReputation)">
            <summary>Return the reputation title, and the total in parens.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.CalculateWeightedPositiveRep(Eco.Gameplay.Economy.Reputation.IHasReputation,System.Func{Eco.Gameplay.Players.User,System.Single,System.Single})">
            <summary>Caluclate a weighted sum, with a passed in mult function.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.RepColor(Eco.Gameplay.Economy.Reputation.IHasReputation)">
            <summary>Return a string of the name colored by the reputation level.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.GetRelativeRep(Eco.Gameplay.Players.User,Eco.Gameplay.Economy.Reputation.IHasReputation)">
            <summary>Return the relative rep of a target to me, and only count rep of people I like, and who they like, etc.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.GiveRep(Eco.Gameplay.Players.User,Eco.Gameplay.Economy.Reputation.IHasReputation,System.Single,System.String,System.Boolean,Eco.Shared.Items.ReputationSource,System.Boolean)">
            <summary>Give reputation from a source to a target, attaching an optional note.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.SubscribeReputationChanged(Eco.Gameplay.Economy.Reputation.IHasReputation,System.Action)">
            <summary>Accepts a callback that will be invoked whenever the reputation of the passed thing changes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.Notify(Eco.Gameplay.Players.User,Eco.Gameplay.Economy.Reputation.IHasReputation,System.Single,System.String)">
            <summary>Send notifications to source and target when reputation changes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.CreateReputationTransferAction(Eco.Gameplay.Economy.Reputation.IHasReputation,Eco.Gameplay.Players.User,System.Single,Eco.Shared.Items.ReputationSource)">
            <summary>We create a ReputationTransfer game action.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.GetDisplayText">
            <summary>Output a big string of all the reputation given in game.</summary>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Reputation.ReputationManager.ForceReplenishReputation(Eco.Gameplay.Players.User)">
            <summary>Replenishes the givable reputation of a user.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.SettlementTaxes">
            <summary>Defimes a set of taxes for a single settlement</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.SettlementTaxes.AssignAll(System.Single)">
            <summary>Set the value of all taxes</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.SettlementTaxes.AnyTaxes">
            <summary>Return true if any tax rate is set.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.SettlementTaxes.DescribeTaxes">
            <summary>Get a table of all the various types of taxes.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet">
            <summary> A class used by transfers to track requested changes for account holdings. 
            This allows to perform several transfers within a single pack and check their final result without caring what was happening (and in which order) inbetween.
            Every change set is bound to not-yet-disposed game action pack. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.AccountChange">
            <summary> A container for requested changes. </summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.changes">
            <summary> Requested changes are stored here. </summary>
        </member>
        <member name="P:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.Applied">
            <summary> Already applied change sets should be distinguishable from others. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.AddChange(Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency,System.Single,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Eco.Shared.Services.NotificationCategory},System.Nullable{Eco.Shared.Services.NotificationStyle},Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Tries to add new change request. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.Apply">
            <summary> Performs the changes without any checks.
            Should stay private and be triggered as a post effect of the related pack. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.Verify">
            <summary> Ensures that this change set will not result negative holdings. </summary> // TODO: Pre-test for already existing negative holdings?
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.NotifyAll">
            <summary> Groups transfers by their descriptions and tags. Then sends messages to according channels. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.NotifyAccountHolders(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.AccountChange})">
            <summary>Sends Transfer Notification to all Bank account Holders</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.Totals(Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency)">
            <summary> Returns total change for the account. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet.TotalsForCurrency(Eco.Gameplay.Economy.Currency)">
            <summary> Returns a collection of accounts and their total deltas for the currency. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TaxIntenalUtils.TryPayTaxes(Eco.Gameplay.Economy.Transfer.TransferData,Eco.Gameplay.GameActions.GameActionPack)">
            <summary>Try to pay tax into the given pack. May return failure.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TaxIntenalUtils.GetTaxRates(Eco.Gameplay.Economy.Transfer.TransferData,Eco.Gameplay.Settlements.Settlement)">
            <summary>Find the tax rate for the given type of transfer in the given settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TransferInternal(Eco.Gameplay.GameActions.GameActionPack,System.Single,Eco.Gameplay.Economy.Currency,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Eco.Shared.Services.NotificationCategory},System.Nullable{Eco.Shared.Services.NotificationStyle},Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Gets or creates change set for the pack, adds related deltas and composes post-effect. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTax(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.BankAccount},Eco.Gameplay.Economy.Currency,System.Single,Eco.Gameplay.Economy.Transfer.Transfers.ValueSpreadType,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},Eco.Gameplay.Economy.Transfer.Internal.AccountsChangeSet)">
            <summary> Calculates how much should be spent from each of the provided accounts.
            Depending on distributeEvenly, calls either <see cref="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" /> or <see cref="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTaxСonsistently(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" />. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTaxСonsistently(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Tries to pay as much as possible from provided accounts one by one:
            if some account is unable to pay the whole value, the remainder will be paid from the next one,
            i.e. three accounts with holdings 10, 100, 1000 will pay 10, 50, 0 respectively if requested value is 60.
            If order matters, provide already sorted collection of accounts. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Recursively splits provided amount into equal parts and tries get this value from the accounts that still can pay:
            if some account is unable to pay that equal part, the remainder will be spread between thouse that still can;
            i.e. three accounts with holdings 10, 100, 1000 will pay 10, 25, 25 respectively if requested value is 60. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TrySpreadEvenly(System.Single,System.Collections.Generic.List{Eco.Gameplay.Economy.BankAccount},System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Private recursive helper that implements logic of <see cref="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Internal.TransferInternalUtils.TryRepeatTax(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Tries to pay target value from each provided account. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfer.TaxUtils">
            <summary>Various helpers related to tax</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.TaxUtils.TaxesAtPosition(Eco.Shared.Math.Vector3i,System.String,Eco.Shared.Localization.LocStringBuilder)">
            <summary>Get the taxes at the given position, for the named property of SettlementTaxes.</summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfer.TransferData">
            <summary> A struct to customize behaviour of <see cref="M:Eco.Gameplay.Economy.Transfer.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.Transfer.TransferData)" /> (see its summary for demo cases). </summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Transfer.Transfers.AlmostZero">
            <summary> Values within this cap will be considered as zero. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.Transfer.TransferData)">
            <summary> Uses provided <see cref="T:Eco.Gameplay.Economy.Transfer.TransferData" /> to change holdings in pack's post effect.
            Some demo cases with different logic: <list type="bullet">
            <item> Store component triggers taxes for whole buy/sell amounts, but transfers only their difference: <see cref="M:Eco.Gameplay.Components.Store.StoreComponent.BuildTransfers(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.Store.Internal.PurchaseData,Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount)" />. </item>
            <item> Tax legal action requests a custom value to be paid from users and suppresses game actions to prevent law infinite loops (like "if tax then tax"): <see cref="M:Eco.Gameplay.Civics.Laws.LegalActions.Money.Tax_LegalAction.ComposeTransfers(Eco.Gameplay.Civics.Laws.LegalActions.Money.MoneyTransferBase_LegalAction.TransferInfo)" />. </item>
            <item> Treasury component implements similar taxation logic, but it is focused on accounts instead of users and does trigger game actions. This component is currently the only one who triggers ReceiveGovernmentFunds</item>
            <item> Work party's payment triggers transfer from escrow to laborer's account, but in terms of users it's from creator to laborer, so it ignores auth by granting super access: <see cref="M:Eco.Gameplay.Economy.WorkParties.CurrencyPayment.PayUser(Eco.Gameplay.Economy.WorkParties.Laborer,System.Single)" />. </item>
            </list><returns> Returns transferred amount. </returns></summary> // Return value is not currently used. And it's hard to make it precise untill the pack fully resolves.
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Transfers.TransferNow(Eco.Gameplay.Economy.Transfer.TransferData,System.Boolean)">
            <summary>A shortcut that performs a transfer using internally created pack and returns the result.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Transfers.TaxNow(Eco.Gameplay.Economy.Transfer.TaxData,System.Boolean)">
            <summary>A shortcut that performs a tax using internally created pack and returns the result.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Transfers.TransferAsPostResult(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.Transfer.TransferData})">
            <summary>Using a list of all of the data of the transfers that we want to perform, we compose the transfers using an internally created helperPack returning a PostResult with the according PostEffects.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfer.Transfers.Verify(Eco.Gameplay.GameActions.GameActionPack)">
            <summary> Checks provided pack's early result and its related accounts change set. 
            Failed test for the change set means that transfers cannot be performed (will result negative holdings). </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.MakeLaborNotification(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final add labor notification collecting all labor data while timer is on, so do not spam with notifications </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.MakeAddItemsNotification(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final notification with counting all items added while timer is working. By each user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.FinishNonValidOrders">
            <summary>Cleanup all non-valid work orders and pay users who already made some work. This is usually need on startup when some work orders could appear invalid.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)">
            <summary> Handles aggregate payments for PayAsYouGo feature, User is the laborer reference and weighted percent delta is the change in his contribution to the work party. </summary>
            <inheritdoc cref="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)" />
        </member>
        <member name="T:Eco.Gameplay.EcopediaRoot.IEcopediaDynamicPageName">
            <summary>Use this interface when we need to give each instance of the current type has a different ecopedia page name.</summary>
        </member>
        <member name="P:Eco.Gameplay.EcopediaRoot.IEcopediaDynamicPageName.PageName">
            <summary>The ecopedia page name of the current instance.</summary>
        </member>
        <member name="T:Eco.Gameplay.PropertyHandling.PropertyChangedNotificationInterceptor">
            <summary>Fody global interceptor for all notified property changes (unless custom OnPropertyChanged method implemented).</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.ActionUtil">
            <summary>
            Utility class to help with keeping track of IGameActionAware listeners, and notifying them when actions are performed.
            <para> Used by systems like Contracts, WorkParties, Item Distributions, etc., to keep track of progress. </para>
            </summary> 
        </member>
        <member name="F:Eco.Gameplay.GameActions.ActionUtil.Listeners">
            <summary>
            Holds listeners that want to be notified whenever a GameAction is being performed.
            <para> Also used by AuthManager to check if auth should be overriden for a specific action because it's allowed by one (e.g. a Contract that allows usage of someone's Oven). </para>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.ActionUtil.ActionPerformed(Eco.Gameplay.GameActions.GameAction)">
            <summary> Notifies all listeners that an action was performed. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.AtomicActions">
            <summary>
            Atomic actions are anything that has must be performed in a single transaction.
            Performing an atomic action builds up the ActionPack, which consists of a set of things to test at first, game actions to run
            through laws and contracts, and then post-effects that are run if everything in the action pack succeeds, and finally things that
            are disposed when the pack is finished.
            All atomic actions should check the early-out failure on the pack before doing anything
            (not necessary for actions that utilize <see cref="M:Eco.Gameplay.GameActions.AtomicActions.PerformMultiblockToolAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Func{Eco.Shared.Math.WrappedWorldPosition3i,System.Type,Eco.Core.Utils.Result})" /> since the check will be performed there).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DropRubble(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Items.BlockItem,Eco.Gameplay.Items.Inventory,System.Numerics.Vector3,System.Single)">
            <summary> Tries to remove block item from the inventory to spawn it as a loose rubble. Burns player's calories if needed. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.BurnCaloriesAndCheckExhaustion(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,System.Boolean,System.Single,System.Boolean)">
            <summary> Burn calories or fail if not enough available. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.BurnFuel(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.Storage.FuelSupplyComponent,System.Single)">
            <summary> Burn fuel or fail if not enough available. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.RemoveFromInventory(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory,System.Type)">
            <summary> See if we can remove an item, and queue it for post if so. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.ClaimOrUnclaimProperties(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Eco.Gameplay.Aliases.IAlias,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Items.PropertyType})">
            <summary>Claim/unclaim combo operation for lists for plot positions in PLOT-SPACE to claim/unclaim.
            If initialOwner is null, will default to claimer.
            If actor is null, then delete the things removed.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.PlaceBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Type,System.Type,System.Boolean,Eco.Gameplay.Items.Inventory,System.Type)">
            <summary> Uses tool to place blocks of provided type on the target area. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DeleteBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Item,System.Boolean,System.Boolean,System.Boolean)">
            <summary> Add the deletion of blocks to the passed action pack and use tool, if able. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DeleteBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Func{Eco.Shared.Math.WrappedWorldPosition3i,System.Boolean},Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Item,System.Boolean,System.Boolean)">
            <summary> Add the deletion of blocks to the passed action pack and use tool, if able. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.ChangeBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Type)">
            <summary> Uses tool to change type of blocks in the area. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.UseTool(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Single)">
            <summary>Consume energy, use durability and gain XP if related params are provided.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DestroyPlant(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Simulation.DeathType,Eco.Gameplay.Items.Inventory,System.Func{Eco.Simulation.Types.PlantSpecies,System.Boolean})">
            <summary> Destroy plants in the area. Will use the tool (i.e. reduce durability, try give XP and burn calories). </summary> // Use DestroyPlantInternal if you don't want to trigger UseTool.
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.HarvestPlant(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Gameplay.Items.Inventory,System.Boolean)">
            <summary> Harvest a PlantEntity into provided inventory. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DoNow(System.Action{Eco.Gameplay.GameActions.GameActionPack},System.Boolean)">
            <summary> Helper for calling the 'Now' functions immediately. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.PerformMultiblockToolAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Func{Eco.Shared.Math.WrappedWorldPosition3i,System.Type,Eco.Core.Utils.Result})">
            <summary> Executes provided actions for each position and counts successful to invoke UseTool with that value as a multiplier. Fails only if nothing was performed. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.ISyncedAction">
            <summary> An action that should be run in synced way. Both with "IPretestAction" works to avoid bugs with simultaneous running of two actions, like pick up same item twice by different users. Pair of (syncObject, GameActionType) will be locked while action is running.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.AggregatableAction">
            <summary> This is base class for all actions which can be grouped for optimization reasons. It already generates GetGroupingKey via reflection based on attributes and config of stats. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionDescription">
            <summary>
            Wraps Game Action descriptions that are visible to the players in two tenses.(Simple tense and progressive tense).
            </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionExtensions">
            <summary>Extension for game actions.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionExtensions.AffectedDeeds(Eco.Gameplay.GameActions.GameAction)">
            <summary>Check location permissions. Get all the affected plots.  Some actions may affect multiple plots.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionExtensions.Fill(Eco.Gameplay.GameActions.GameAction,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Shared.Math.WrappedWorldPosition3i,Eco.Gameplay.Items.Item)">
            <summary> Tries to fill action's fields with the provided data. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionManager">
            <summary> Handles applying all the various things that might adjust or prevent actions, and outputs display of them. </summary>
            <remarks> Laws, contracts, and auth all should work exclusively through this interface. </remarks>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionManager.GameActionLockers">
            <summary> Saves locks for combination of game action type and action subject (defined by ISyncedAction). It means that it will prevent running at same time same action with same subject, like two action of pick up same world object. </summary>
            <remarks> It needs to be converted from tuple to GameActionLocker since tuple is value type, and locks works in base of reference (i.e. (object, type) would never prevent nothing, since each time when it's used it will just create new reference) </remarks>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionManager.TryPerformActions(Eco.Gameplay.Players.User,Eco.Gameplay.GameActions.GameActionPack)">
            <summary> Passes the actions of specified pack through Laws and Auth Manager, and retrieves a failed/successful result. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.NoLawsAttribute">
            <summary>Prevents an action from being tracked in laws and hide it.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.PackFlags">
            <summary>A set of flags that can be set on a game action pack to change how its processed.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.PackFlags.Force">
            <summary>If set, anything preventing the action is ignored.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionPack">
            <summary>
            In Eco many actions can be blocked or modified by laws. This is handled with the GameActionPack, which defines an action to try to run,
            and a set of 'PostEffects' that subsequently run if it succeeds, as well as objects to dispose on completion. These packs are created then
            passed to the GameActionManager to perform them. 
            </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.GameActions">
            <summary>GameActions that are put through laws, auth, and stats.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.PreTests">
            <summary>Pretests to be run once the entire game action has been build and is being performed. This is used for things like changelists, which might have multiple 
            things added throughout the compilation of the GameActionPack, and thus shouldn't be tested for early-out. Usually though, things can fail in early-outs.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.PostEffects">
            <summary>Code to run when everything succeeds. These may not fail.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.OnDispose">
            <summary>Other disposal actions.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.ChangeSets">
            <summary>Collection of ChangeSet, there is only one change set for each type. They are used to do pretests, add PostEffect or called dispose call back.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.EarlyResult">
            <summary>If an action fails early, this will be set, preventing further atomic actions from bothering to do anything.</summary>
        </member>
        <member name="P:Eco.Gameplay.GameActions.GameActionPack.PackFlags">
            <summary>We can modify how the pack is performed with these flags.</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.Locker">
            <summary>Locking object of gameactionpack. Sample: When pick up same item, it will be locked, so another similar action (pick up) with same item will block each other, still allowing different things interact with this item.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.#ctor(Eco.Gameplay.GameActions.GameAction,System.Action)">
            <summary>Wrapper that lets us attach post-effects that don't need to return a status.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.AddPostEffect(System.Func{Eco.Shared.Localization.LocString})">
            <summary>Add a delegate that will be executed after all tests in this pack pass successfully.</summary>
            <returns>This action pack.</returns>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.AddPostEffect(System.Action)">
            <inheritdoc cref="M:Eco.Gameplay.GameActions.GameActionPack.AddPostEffect(System.Func{Eco.Shared.Localization.LocString})" />
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.AddChangeSet(Eco.Gameplay.GameActions.IGameActionPackChangeSet)">
            <summary>Changesets need to be cleaned up afterwards.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPackExtension.GetOrCreateInventoryChangeSet(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User)">
            <summary>This is an particular extension only for InventoryChangeSet to get or create a ChangeSet from a GameActionPack with inventory and user</summary>&gt;
        </member>
        <member name="T:Eco.Gameplay.GameActions.IGameActionPackChangeSet">
            <summary>Objects with this interface will be used in GameActionPack to do PreTest, PostEffect or GameActionPack Dispose callback.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.MultiblockActionContext">
            <summary> Parameters, the presence of which will determine behavior of multi-block atomic action.
            Default values will be ignored, i.e. if there is no fuel component provided, then nothing will be burned. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.CreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.Players.Player,System.Boolean,Eco.Shared.Math.Vector3i,System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction})">
            <inheritdoc cref="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.CreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.Players.Player,System.Boolean,System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction})" />
        </member>
        <member name="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.CreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.Players.Player,System.Boolean,System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction})">
            <summary>Builds a MultiblockActionContext based on the player's data.</summary>
            <param name="applyXPSkill">If FALSE, this sets the ExperienceSkill to NULL which results in no AddExperience() post effect being added to the action.</param>
            <param name="area">Positions of blocks to be included in this context.</param>
            <remarks>Returned MultiblockActionContext doesn't have to contain multiple blocks. It contains all blocks specified in <paramref name="area" />.</remarks>
        </member>
        <member name="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.TryCreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.GameActions.MultiblockActionContext@,Eco.Shared.SharedTypes.InteractionTarget,Eco.Gameplay.Players.Player,System.Boolean,System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <inheritdoc cref="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.TryCreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.GameActions.MultiblockActionContext@,Eco.Shared.SharedTypes.InteractionTarget,Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Boolean,System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag})" />
        </member>
        <member name="M:Eco.Gameplay.GameActions.MultiblockContextHelpers.TryCreateMultiblockContext(Eco.Gameplay.Items.ToolItem,Eco.Gameplay.GameActions.MultiblockActionContext@,Eco.Shared.SharedTypes.InteractionTarget,Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Boolean,System.Collections.Generic.IEnumerable{System.Type},System.Func{Eco.Gameplay.GameActions.GameAction},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag})">
            <summary>
            Builds a context that's ready to be used by the AtomicActions, including all necessary info for the action 
            to be performed with the appropriate target block(s), and handle XP, durability, and calories consumption.
            </summary>
            <param name="tagsTargetable">Only blocks that have any of these tags can be affected by this interaction.</param>
            <param name="mustHaveTags">Only blocks that have all of these tags can be affected by this interaction.</param>
            <param name="mustNotHaveTags">Only blocks that don't have any of these tags can be affected by this interaction.</param>
            <returns>True if at least one block valid for this tool was found and context was successfully created.</returns>
        </member>
        <member name="M:Eco.Gameplay.GameActions.TriggerConfigManager.IsValidConfig(System.Reflection.PropertyInfo,System.Type)">
            <summary> Checks if property is a valid property to appear on the Trigger section.</summary>
        </member>
        <member name="T:Eco.Gameplay.Garbage.BasicSimulation">
            <summary> Simulation responsible for ticking inventories for spoiling food, and gathering performance stats. </summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.BasicSimulation.TickAll(System.Int32)">
            <summary> Tick Inventories and gather stats about running time, and update the next tick time. </summary>
        </member>
        <member name="T:Eco.Gameplay.Garbage.GarbageManager">
            <summary>  Responsible for ticking Garbage inventories (when an item is thrown as garbage out of player inventory), once an item is spoiled it gets depleted and turned into waste. </summary>
        </member>
        <member name="T:Eco.Gameplay.Garbage.SpoilageManager">
            <summary> Manager Responsible for ticking <see cref="T:Eco.Gameplay.Items.ItemStack" /> and creating it with <see cref="T:Eco.Gameplay.Items.ItemStack" /> that have <see cref="T:Eco.Gameplay.Items.FoodItem" /> and detecting it through <see cref="T:Eco.Gameplay.Items.Inventory" /> changes, See DurabilityItems.md </summary>
        </member>
        <member name="F:Eco.Gameplay.Garbage.SpoilageManager.Reset">
            <summary> Used to Force ticks for the plugin to update nearest time to tick when needed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.#ctor">
            <summary> Initializes and checks the inventories and add tickers if there are any needed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.Tick">
            <summary> Ticks the simulation returns plugin sleep time for the next simulation tick. </summary>
            <returns> Sleeping time. </returns>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.SyncTickersForInventory(Eco.Gameplay.Items.Inventory)">
            <summary>Create tickers for the given inventory but given that this inventory accepts <see cref="F:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler.SpoiledFoodItem" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.SyncTickersForStacks(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.ItemStack})">
            <summary>Create tickers for the given stack groups, checks the validity of inventories and Create tickers accordingly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.OnGlobalShelfLifeMulitplierChanged">
            <summary> When <see cref="P:Eco.Gameplay.Systems.BalanceConfig.ShelfLifeMultiplier" /> changes all the food item expiration times gets updated so need to account for the new updated value. </summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.SyncTickerForStack(Eco.Gameplay.Items.ItemStack)">
            <summary> Checks whether stack has item for spoilage, to create tickers if it can spoil, update the ticker if time changes or remove the ticker if it doesn't have <see cref="T:Eco.Gameplay.Items.FoodItem" /> anymore. </summary>
            <param name="stack">The stack to check for and map ticker around.</param>
        </member>
        <member name="T:Eco.Gameplay.Garbage.SpoilageManager.ItemStackTicker">
            <summary>Used by <see cref="T:Eco.Gameplay.Garbage.SpoilageManager" /> to track the time at which <see cref="T:Eco.Gameplay.Items.FoodItem" /> is ready to spoil.</summary>
        </member>
        <member name="T:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler">
            <summary> Responsible for converting spoiled items into <see cref="F:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler.SpoiledFoodItem" /> item in batch <see cref="T:Eco.Gameplay.Items.InventoryChangeSet" />, this supports multithreaded by having locks on it in Spoilage Manager</summary>
        </member>
        <member name="F:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler.stacksToSpoil">
            <summary> Set of ItemStacks that are going to be spoiled. Gets added to while ticking the various ItemStackSpoilageTicker and then all the respective stacks are spoiled in multiple InventoryChangeSet actions per inventory.</summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler.ApplySpoilage">
            <summary> Spoil all the stacks pending spoilage, in separate inventory change set actions so if one fails doesn't prevent others from happening. </summary>
        </member>
        <member name="M:Eco.Gameplay.Garbage.SpoilageManager.ItemSpoiler.QueueForConversion(Eco.Gameplay.Items.ItemStack)">
            <summary> Marks the given stack as spoiled to get ticked later, if the item inside is spoiled. </summary>
        </member>
        <member name="T:Eco.Gameplay.Garbage.SpoilagePlugin">
            <summary> Plugin responsible for ticking the <see cref="T:Eco.Gameplay.Garbage.SpoilageManager" /> </summary>
        </member>
        <member name="T:Eco.Gameplay.Holidays.HolidayEvent">
            <summary>Represents a configured holiday event that can be run on Eco Server.</summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayEvent.HolidayName">
            <summary>
            The name of the holiday event. This name is also used for creating override content for the holiday
            on Eco Client. Example supplying "Christmas" here will look for override content called "OriginalName_Christmas".
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayEvent.Enabled">
            <summary>
            Flag for enabling/disabling this holiday without removing it from the server's 
            configuration. This is useful for holidays the server operator does not want to run.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayEvent.StartDate">
            <summary>Defines the start date of the holiday event. Years are automatically adjusted to match the current date.</summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayEvent.EndDate">
            <summary>Defines the end date of the holiday event. Years are automatically adjusted to match the current date.</summary>
        </member>
        <member name="T:Eco.Gameplay.Holidays.HolidayManager">
            <summary>
            Singleton plugin class that manages holidays. This class is responsible for checking if holidays are enabled and swapping out the current holiday.
            To utilize this on the client create addressable override content following the name pattern of NormalName_HolidayName. For example if you wanted to
            create a holiday for "Christmas" that changed the elk to reindeer you would create a new addressable override content called "Elk_Christmas". When no override
            content is present the default content is used.
            
            This system can also be utilized from Eco's modkit. Overridable content can also be loaded from a mod's AssetBundle. Create a GameObject with the same name
            scheme in the mod's objects scene.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Holidays.HolidayManager.CheckForHoliday">
            <summary>
            Runs every minute through the <see cref="F:Eco.Gameplay.Holidays.HolidayManager.updateHolidayWorker" /> <see cref="T:Eco.Core.Utils.Threading.PeriodicWorkerFactory" />. This process checks
            if holidays are currently enabled and if they are checks if the current date is within the range of any of the configured holidays.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Holidays.HolidayManager.GetCurrentHoliday(System.DateTime)">
            <summary>
            Retrieves the currently active holiday based on the supplied date. If no holidays are found in range of the supplied date 
            then null is returned. For holidays that span multiple years this algorithm automatically adjusts the start and end dates
            of the holiday so the years match based on the supplied date keeping the offset between the start and end years.
            
            Example. Configured yearly holiday that starts on 2023 and ends 2024 but the current year is 2025. This algorithm will
            change the start and end dates to 2025 and 2026 respectively.
            </summary>
            <param name="sampleDate"><see cref="T:System.DateTime" /> to check for holidays in range.</param>
            <returns><see cref="T:Eco.Gameplay.Holidays.HolidayEvent" /> if a holiday is found in range. Otherwise <c>null</c></returns>
        </member>
        <member name="M:Eco.Gameplay.Holidays.HolidayManager.OnEditObjectChanged(System.Object,System.String)">
            <summary>
            Called when the user changes the server settings for the holiday plugin. 
            Performs the normal config sav operation and checks if holidays are still enabled if they are not clears the current holiday.
            </summary>
            <inheritdoc cref="M:Eco.Core.Plugins.IEditablePluginData.OnEditObjectChanged(System.Object,System.String)" />
        </member>
        <member name="T:Eco.Gameplay.Holidays.HolidayConfig">
            <summary>Configuration model used by the <see cref="T:Eco.Gameplay.Holidays.HolidayPlugin" /> instance loaded from the "Holiday.eco" file in the server's config directory.</summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayConfig.HolidaysEnabled">
            <summary>Global flag for enabling/disabling all holidays without removing them from the server's configuration.</summary>
        </member>
        <member name="P:Eco.Gameplay.Holidays.HolidayConfig.Holidays">
            <summary>Represents all configured holiday events that can be run on Eco Server.</summary>
        </member>
        <member name="T:Eco.Gameplay.Holidays.HolidayPlugin">
            <inheritdoc cref="T:Eco.Gameplay.Holidays.HolidayManager" />
        </member>
        <member name="T:Eco.Gameplay.Housing.BuildingSpawner">
            <summary>Functions for spawning buildings and objects contained in them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.BuildingSpawner.SpawnBuildingWithObjectAndClaim(System.String,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,System.Boolean)">
            <summary>Spawn a building for the given object, creating a new deed and claiming on it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.BuildingSpawner.SpawnBuilding(Eco.Gameplay.Players.User,System.Int32,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Vector3i,Eco.Gameplay.Property.RoofType,System.Boolean,System.Boolean)">
            <summary>Spawns building with given tier, size and options.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.BuildingSpawner.SpawnBuilding(Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Gameplay.Housing.Internal.RoomSpecification,System.Boolean)">
            <summary>Spawn building for given <paramref name="roomSpecification" /> at given <paramref name="position" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.BuildingSpawner.SpawnRoom(Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Gameplay.Housing.Internal.RoomSpecification)">
            <summary>Spawn a room for given <paramref name="roomSpecification" /> at the given position.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.Internal.RoomSpecification">
            <summary>Room specification for <see cref="T:Eco.Gameplay.Housing.HousingCommands" />. Contains all information about room and may be used for spawn position search methods to ensure there enough space.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.Internal.RoomSpecification.Create(System.String,Eco.Shared.Math.Vector3i,Eco.Gameplay.Property.RoofType,System.Boolean,System.Int32)">
            <summary>Creates <see cref="T:Eco.Gameplay.Housing.Internal.RoomSpecification" /> with given material, size and options.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.Internal.RoomSpecification.Create(System.Int32,Eco.Shared.Math.Vector3i,Eco.Gameplay.Property.RoofType,System.Boolean)">
            <summary>Creates <see cref="T:Eco.Gameplay.Housing.Internal.RoomSpecification" /> with given tier, size and options.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.Internal.RoomSpecification.GetTierDoorType(System.Int32)">
            <summary>Returns default door type for <paramref name="tier" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.IHasDynamicHomeFurnishingValue">
            <summary>World objects can implement this interface to define an additional component that will be calulated to determine home furnishing value
            when evaluating property value.  This is used of things like PictureFrames which can hold artwork of dynamic value.</summary>
        </member>
        <member name="P:Eco.Gameplay.Housing.PropertyValues.IHasDynamicHomeFurnishingValue.DynamicFurnishingValue">
            <summary>Returns the dynamic value</summary>
        </member>
        <member name="P:Eco.Gameplay.Housing.PropertyValues.IHasDynamicHomeFurnishingValue.DynamicFurnishingTitle">
            <summary>How to describe the dynamic value in tooltips etc</summary>
        </member>
        <member name="P:Eco.Gameplay.Housing.PropertyValues.IHasDynamicHomeFurnishingValue.UniqueObject">
            <summary>If a unique object is defined, then it will test uniqueness based on this dynamic trait instead of repetitions of the same type (ie, the artist of the painting is the
            unique factor for picture frames, making repeated paintings from the same artist reduce in value compared to different artists).</summary>
        </member>
        <member name="P:Eco.Gameplay.Housing.PropertyValues.IHasDynamicHomeFurnishingValue.UniqueObjectName">
            <summary>What the type of the unique object is, described for tooltips and such.</summary>
        </member>
        <member name="P:Eco.Gameplay.Housing.PropertyValues.HomeFurnishingValue.UniquenessObject">
            <summary>When set, defines the value which determines an object uniqueness, insted of the type (which is the default). IE, a painting can link to the painting's owner to determine uniqueness per painter.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.HomeFurnishingValue.CalculateValue(Eco.Gameplay.Objects.WorldObject,System.Int32)">
            <summary>Determines the housing value including any reductions</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.HomeFurnishingValue.GetUniquenessObject(Eco.Gameplay.Objects.WorldObject)">
            <summary>Get the object which we use to determine uniqueness across the property. This may have a special callback attached
            (like PicutreFrame to get the artist) or be the default of the world object's type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.HomeFurnishingValue.Describe(Eco.Gameplay.Objects.WorldObject,System.Int32)">
            <summary>Describe the value, taking as a paramter how many of these exist across the whole property being scored.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.HousingConfig">
            <summary>Values related to the housing system, set via mods.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.HousingConfig.SetRoomCategories(System.Collections.Generic.IEnumerable{Eco.Gameplay.Housing.PropertyValues.RoomCategory})">
            <summary>Initialize the room categories used by the housing system.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.Internal.CulturalPropertyValue">
            <summary>When a property is of type 'cultural', its value will be computed with this class.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.Internal.CulturalPropertyValue.SetInfluence(System.Single,Eco.Shared.Localization.LocString)">
            <summary>Returns true if there was a change.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.Internal.ResidencyPropertyValue.ApplyAndDescribeMultipliersAndGetNewTotal(System.Single,Eco.Gameplay.Property.Deed,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>Change multiplier for difficulty and roommate penalty.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.Internal.StandardFurnishedRoomValue.GetRoomCategoryAndFurnishings(System.Collections.Generic.List{Eco.Gameplay.Housing.HousingComponent},Eco.Gameplay.Property.RoomStats,System.Collections.Generic.HashSet{Eco.Gameplay.Housing.PropertyValues.RoomCategory},Eco.Shared.Localization.LocString@)">
            <summary>Returns the defined list of components that contribute to this room and the room category it should be considered.
            Returns nulls plus a result if there is nothing valid.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.Internal.StandardFurnishedRoomValue.GetValuePerCategory(System.Collections.Generic.List{Eco.Gameplay.Housing.HousingComponent})">
            <summary>Generates a dictionary that lists the value per category of furnishing.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.Internal.StandardPropertyValue">
            <summary>Base class for property values derived from the regular furnishing values. Residency and cultural use this, though cultural will get separated later.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.Internal.StandardPropertyValue.DescribeTotal(Eco.Gameplay.Property.Deed,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>Describe the final points and how they affect things.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.PropertyValue">
            <summary>Determines the property value of a given deed, given whats built on it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.PropertyValue.CalcValueAndNotify(Eco.Gameplay.Property.Deed)">
            <summary> Calculate the value of the property.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.PropertyValueManager">
            <summary>Tracks and updates the value of deeds dependent on what kind of property they are. Watches for changes from the RoomsPlugin.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.RoomCategory">
            <summary>Types of rooms that we can support. </summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.Color">
            <summary>Color associated with this category.</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.SupportingRoomCategoryNames">
            <summary>A list of other room category names which this category can contribute its points to.</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.AffectsPropertyTypes">
            <summary>Which property types can furniture of this category support?</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.MaxSupportPercentOfPrimary">
            <summary>For support furnishings (that is, furnishings that dont match the primary room category, like a chair in the kitchen), the total value of the support category cannot exceed this percent of the primary categroy's.</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.CapToPercentOfRestOfProperty">
            <summary>When set, the value of rooms of this type is capped to the value of the rest of the house (the uncapped rooms).  For example, bathrooms are capped at X% of the rest of the house (because its not the main purpose of the dwelling, just a supporting role).</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.CanBeRoomCategory">
            <summary>When set, this cannot determine the type of a room, its a supporting category only (ex, 'Decoration' is a category of furniture but cannot be a category of room).</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.SupportForAnyRoomType">
            <summary>When set, room category can be a support category for any type of room, even if it's doesn't list it in its support category list (ie, 'Decorations' are useful in any type of room).</summary>
        </member>
        <member name="F:Eco.Gameplay.Housing.PropertyValues.RoomCategory.NegatesValue">
            <summary>Set this to true if the category nulls out housing points when in a room.</summary>
        </member>
        <member name="T:Eco.Gameplay.InfluenceObjects.IHasBaseInfluence">
            <summary>Placed on a worldobject component that has base influence, meaning it generates influence without culture. Only works for a deed host object.</summary>
        </member>
        <member name="T:Eco.Gameplay.InfluenceObjects.InfluenceChangeNotifier">
            <summary>Allows watching influence at a given plot position and getting a callback when changes occurr.</summary>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceChangeNotifier.SubscribeInfluenceChanged(Eco.Core.Utils.IThreadSafeSubscriptions,Eco.Shared.Voxel.PlotPos,System.Action)">
            <summary>Subscribe to Influence changes at the given position.</summary>
            <param name="subs">List where the subscription is stored.</param>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceChangeNotifier.MarkInfluenceChanged(System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos})">
            <summary>Called to tell us the list of changed plots and alert any subscribers.</summary>
        </member>
        <member name="T:Eco.Gameplay.InfluenceObjects.InfluenceChangeNotifier.InfluenceSubscription">
            <summary>Holds an influence subscription. Should stay private as its only used within this notifier</summary>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceMap.UpdateAndGetChangedPlots(System.Func{Eco.Shared.Voxel.PlotPos,System.Int32},System.Collections.Generic.IEnumerable{Eco.Gameplay.InfluenceObjects.IInfluencer})">
            <summary>Assign every value in the map with the results of the passed function, then trigger updates.
            Returns a list of positions that yielded a change.</summary>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceMap.UpdateMapEntryColor(Eco.Gameplay.InfluenceObjects.IInfluencer)">
            <summary> Updates the map entry color and notifies view changes for it.</summary>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceMap.DescribeMap">
            <summary>Describes the plot counts for this influence map of each influencer.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.IInteractor">
            <summary>Defines a type that has Interaction defined on it via InteractionAttribute.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.InteractionAttribute">
            <summary> Block of data sent to the client that defines how a general interactor works. Method applied to must have signature: void X(Player player, InteractionTriggerInfo trigger, InteractionTarget target, List{Tag} tagsTargetable) </summary>
            <remarks> NOTE: This attribute inherits directly from <see cref="T:Eco.Shared.Networking.RPCAttribute" />, so an RPC will be created for every method this is defined on. </remarks>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.Description">
            <summary>Description of the interaction, taken from the name of the method it's applied on, but can be overriden via our constructor.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.RPCName">
            <summary>Name of the RPC to call. This is called on the interactor, but if the interactor is null its called on the target.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.SubComponentTypeRPCTarget">
            <summary>If set, means that the RPC is called on the given subcomponent of a world object.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.TagsTargetable">
            <summary>Blocks, NetObjects, and Items that have ANY of these tags can trigger this interaction.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.RequiredEnvVars">
            <summary> Parameters that would allow this interaction to trigger (if a tag also matches). Exists to allow state-based definitions for WorldObjects (--e.g.: 'Turn on' vs 'Turn off', etc) </summary>
            <remarks> This is applied on top of tags. If this is null or empty, the interaction can be triggered. </remarks>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.DisallowedEnvVars">
            <summary>Environment vars that, if present and assigned any value besides 'false', will block the interaction.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.InteractionDistance">
            <summary>Max distance allowed to interact, 0 means default distance.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.Priority">
            <summary>When two interactions are set on the same trigger, priority determines which is displayed and avaialble.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.PredictedBlockAction">
            <summary>Define an action that can happen instantly on the client when the interaction takes place, and can be rewound if the server doesnt accept it.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.MinCaloriesRequired">
            <summary>Min calories required to perform the action. The ingteraction may still consume more than this.  And the consumption doesnt happen automatically, the interaction func must do it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.Interactors.InteractionAttribute.Init(System.Type,System.String)">
            <summary>Init an interaction definition defined on an interactor. </summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.IHasInteractions">
            <summary> Identifier for types that can host methods with the <see cref="T:Eco.Gameplay.Interactions.Interactors.InteractionAttribute" />. </summary>
            <remarks> We use heavy reflection in <see cref="M:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.Initialize" />, so we use this interface to reduce the scope of reflection to types that implement this.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.InteractionHexColors">
            <summary>Constants class containing the standardized contant colors used by Interaction coloring and highlights.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.InteractionTargetServerExtensions">
            <summary>Server side accessors for InteractionTarget</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.Interactors.InteractionTargetServerExtensions.TryCast``1(Eco.Shared.SharedTypes.InteractionTarget,``0@)">
            <summary>If a block is selected, try casting to the given interface. If an object is selcted, try casting that.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager">
            <summary>Info about available interactions that's shared with the client.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.InteractorToInteractions">
            <summary>A map of interactor types to a list of the interactions they can perform.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.ComponentToInteractions">
            <summary>Additional interactions that are defined based on the target of the interaction, like a world object or component of a world object.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.NetObjectNameToInteractions">
            <summary>Additional interactions that are defined based on the target of the interaction, like a world object or component of a world object.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.HandsInteractor">
            <summary>We share the same hands interactor for everyone since it has no state.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.LiveUpdateInteraction(Eco.Gameplay.Players.User,Eco.Gameplay.Property.Deed,Eco.Shared.Networking.INetObject,Eco.Shared.Items.AccessType,System.Boolean)">
            <summary>Updates an interaction with any extra data that needs to be known when its being displayed to the user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.Interactors.ServerInteractionManager.Initialize">
            <summary>Finds all the functions defining interactions, defined both on interactors and on targets.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Interactors.IAoeToolItem">
            <summary>Interface for tools that can affect multiple blocks with a single interaction.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.Interactors.IAoeToolItem.AreaOfEffectMode">
            <summary>Used to find all blocks this tool will affect when it's used.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.InteractUtils.TooFarWithFudgeAndNotify(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,System.Single)">
            <summary>Return true if the player is too far for the interaction, and notify the player and server. Gives 1 meter of 'fudge'
            since this is primarily used to detect hacking.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.Internal.InteractionLiveUpdaterServer">
            <summary>Handles adding extra information given a specific interaction target, like the authorization of that item, and any adidtional world object params
            that need to be sent to it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.Internal.InteractionLiveUpdaterServer.LiveUpdateInteraction(Eco.Gameplay.Players.User,Eco.Gameplay.Property.Deed,Eco.Shared.Networking.INetObject,Eco.Shared.Items.AccessType,System.Boolean)">
            <summary>Updates an interaction with any extra data that needs to be known when its being displayed to the user.</summary>
            We also pass in a 'forceEnvVarUpdate' which allows the client to tell us they want an update piggybacked here.
        </member>
        <member name="T:Eco.Gameplay.Items.AreaOfEffectMode">
            <summary>Base class for all AOE modes.</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.AreaOfEffectMode.requireCentralBlock">
            <summary>Set to true to ignore all blocks if central block doesn't meet the condition.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.AreaOfEffectMode.#ctor(System.Boolean)">
            <param name="requireCentralBlock">Set to true to ignore all blocks if central block doesn't meet the condition.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.AreaOfEffectMode.GetAffectedBlocks(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag})">
            <summary>Gets positions of all blocks affected by a tool during an interaction or an empty enumerable if no blocks are affected.</summary>
            <param name="player">Player who is using the tool.</param>
            <param name="centerPos">Position of the block player interacted with.</param>
            <param name="tagsTargetable">Only blocks that have any of these tags can be affected by this interaction.</param>
            <param name="mustHaveTags">Only blocks that have all of these tags can be affected by this interaction.</param>
            <param name="mustNotHaveTags">Only blocks that don't have any of these tags can be affected by this interaction.</param>
        </member>
        <member name="T:Eco.Gameplay.Items.SingleBlock">
            <summary>Makes tool affect only one block, effectively disabling AOE.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.MultiBlock">
            <summary>Simple mode that can affect several blocks given their offset from the block targetted by interaction and condition they have to meet.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Cone">
            <summary>Affects all blocks inside a cone that meet a specified condition.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AuthorizationInventory">
            <summary> Inventories of this type should be used when they can be accessed by other players.
            It's also possible to adjust authorization flags for some non-standard scenarios. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AuthorizationInventory.AuthorizationFlags">
            <summary> These flags allow to forbid or allow some scenarios when players interact with <see cref="T:Eco.Gameplay.Items.AuthorizationInventory" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.BlockItem.GetBlockItem(System.Type)">
            <summary> Returns <see cref="T:Eco.Gameplay.Items.BlockItem" /> for requested <paramref name="blockType" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.BlockItem.Place(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i)">
            <summary> Called from the client to finalize the 'Place' interaction. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ClothingInventory.SwapInventories(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.ClothingInventory)">
            <summary> Swap not hidden clothing between two inventories (empty slots are swapping too) </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ClothingInventory.LoadFromCustomizationData(Eco.Gameplay.Players.User,Eco.Shared.Gameplay.AvatarCustomizationData)">
            <summary> Load clothing from customization data. </summary>
            <remarks> At the moment, this should happen only on first login, to load from default avatar data. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Items.DurabilityItem">
            <summary> Items that can get broken or spoiled, that can be discrete or continious in progression, See DurabilityItems.md for more informations. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FertilizerNutrients">
            <summary>Holds information about the nutrient levels in a fertilizer item (each item has different values).</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FoodItem">
            All food items that are new start with a durability of 100%, when creating the item an ImmutableCountdown is created, what this does is take the time from when the item was created until it becomes spoiled.
            It should be clarified that every time the item changes state, a new counter is generated with the new parameters, that is, if the item changes storage or the item's durability changes for some reason, the total time is calculated and the remaining time as well. (taking into account the time that has already passed), and another ImmutableCountdown is created.
            There may be the occasion that there is a storage that preserves the food indefinitely, such as the square pot at the time of writing this comment.
            In this case, the immutable countdown can generate buggs with infinite time, therefore a paused counter is created, and the decomposition would not occur.
            If the Shelf life changes (gets in a storage that preserves food), the times change relative to each other, meaning that the total shelf life is increased by a multiplier and also the time remaining for the same multiplier.
            therefore the quality will not be improved, it will simply take longer to get spoiled.
            <summary> Food Items are items that spoil over time, See DurabilityItems.md </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.Merge(Eco.Gameplay.Items.Item,System.Int32,System.Int32)">
            <summary> Update Durability value before merging to items to apply correct durability value. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.UpdateSpoilageTime(System.Single)">
            <summary> Sets the spoilage time based on durability or updates the durability with spoilage progress if the storage is still the same. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.GetSpoilageTimeBasedOnDurability(System.Single,System.Boolean)">
            <summary> Create a new immutable countdown based on the given durability value and the current storage modifier. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.Consume(Eco.Gameplay.Players.Player,System.Boolean)">
            <summary>
            RPC that is called by client when its time to actually remove food item from inventory an eat it
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.ConsumeInternal(Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Players.User,System.Boolean,System.Action)">
            <summary> Wrapper for food consume process that is reused in Right click on UI (server side) and client request from toolbar </summary>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Items.FoodItem.OnUsed(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.ItemStack)">
            <summary> On food item right click - we point toolbar override slot with this item stack of food. for client so it knows what item will be used
            Also we immediately call consume (so item will be eaten with calories and removed from inventory)</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IEcopediaEntry">
            <summary> Interface for <see cref="T:Eco.Core.Systems.IRegistrar" /> entries which may be shown in Ecopedia. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IEcopediaEntry.IsVisibleInEcopedia">
            <summary> Returns if this entry should be displayed in Ecopedia. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Internal.DestinationStacksIter">
            <summary>Base class for all destination stacks enumerators. Wraps <see cref="F:Eco.Gameplay.Items.Internal.DestinationStacksIter.nested" /> enumerator and adds <see cref="M:Eco.Gameplay.Items.Internal.DestinationStacksIter.SetSourceItem(Eco.Gameplay.Items.Item)" /> to API.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Internal.DestinationStacksIter.SetSourceItem(Eco.Gameplay.Items.Item)">
            <summary>Set source item for that destination stack enumerator. It may change an enumerator. Returns <c>true</c> if enumerator reset.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Internal.SingleDestinationStacksIter">
            <summary>Implementation of <see cref="T:Eco.Gameplay.Items.Internal.DestinationStacksIter" /> for single target stack.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Internal.GeneralDestinationStacksIter">
            <summary>Implementation of <see cref="T:Eco.Gameplay.Items.Internal.DestinationStacksIter" /> for items movement. It filters destination stacks to either match item type or be empty. Then stacks ordered descending by quantity.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryRelated.ConsolidationUtils">
            <summary> Class used to consolidate storages (order inventories by type, quantity and quality).</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRelated.ConsolidationUtils.ConsolidateInventory(Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User)">
            <summary> Consolidate inventory items into least amount of stacks. Unique items are not consolidated. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRelated.ConsolidationUtils.MergeIntoAsFewStacksAsPossible(System.Collections.Generic.List{Eco.Gameplay.Items.ChangedStack},System.Int32,Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User)">
            <summary> Check the maximum amount that can add of this item, then unify all the same type items in a stack, if the stack reaches max limit, add another stack with the remaining amount. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryRelated.InventoryManager">
            <summary>Tracks all inventories so that they can be scanned for items.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IInventoryChangeSet.MoveStacks(Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.ItemStack)">
            <summary> Move the source stack items to the destination, combining/swapping depending on the items. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IInventoryContext">
             <summary>
             Used by <see cref="T:Eco.Gameplay.Components.VehicleComponent" /> to override the <see cref="T:Eco.Gameplay.Players.Player" />'s inventory context when mounted in a vehicle.
             <para>An inventory context can be overriden by setting InventoryContext or BuilderInventoryContext to the new inventory object that needs to be used.</para>
            
             <para>The context is used by <see cref="T:Eco.Gameplay.Components.Storage.StorageComponent" /> to read what contents are in the <see cref="T:Eco.Gameplay.Players.Player" />'s inventories.</para>
            
             <para>Ex. <see cref="T:Eco.Gameplay.Components.CraneToolComponent" /> overrides it's vehicles BuilderInventoryContext with its own ClawInventory so <see cref="T:Eco.Gameplay.Components.Storage.StorageComponent" />
             will use the crane's builder inventory instead of the player's when mounted.</para>
             </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IInventoryContext.InventoryContext">
            <summary>The toolbar inventory context. Handles ItemStacks and selecting.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IInventoryContext.BuilderInventoryContext">
            <summary>The builders inventory context. Handles items that need to be picked up.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryComponent">
            <summary>
            Inventory components track an attribute of an inventory, such as weight
            restrictions may use components to handle valid item destinations
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.WeightComponent">
            <summary>Used to track the total weight of an inventory.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WeightComponent.MaxWeight">
            <summary>Represents the max weight this inventory can support.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WeightComponent.Weight">
            <summary>Represents the true modified weight of this inventory.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Inventory.ManipulatableStacks">
            <summary>
            Stacks that can be manipulated through linked inventories, in sub-inventories that have similar item restrictions, override in concrete InventoryView to exclude certain stacks that would appear in <see cref="P:Eco.Gameplay.Items.Inventory.Stacks" />
            <para>See <see cref="T:Eco.Gameplay.Items.UserInventory" /> example, excluding the <see cref="T:Eco.Gameplay.Items.ClothingInventory" /> as it's restricted to clothing items only, very different from <see cref="T:Eco.Gameplay.Items.ToolbarBackpackInventory" /></para>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.ApplyChanges(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.Dictionary{Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.ChangedStack})">
            <summary>We make sure to call OnChanged to apply all the necessary changes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.TryRemoveItemsAsManyAsPossible(System.Type,System.Int32,Eco.Gameplay.Players.User)">
            <summary>Remove as much as we can, up to desired quantity, and return results.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.GetMaxAccepted(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Items.InventoryChangeSet,Eco.Gameplay.Items.Inventory)">
            <summary>
            Get the maximum amount of item are allowed to put into this inventory
            </summary>
            <param name="item"></param>
            <param name="currentQuantity">Current quantity of the Item in the Inventory</param>
            <param name="changeSet">Data of the current transfer</param>
            <param name="sourceInventory"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.GetMaxPickup(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory)">
            <summary>
            Check restrictions based on general data (for use outside changesets, some general pre-checks, etc).
            Get the maximum amount of items are allowed to pick up from the current Item stack
            </summary>
            <param name="item">Items that are being transferred</param>
            <param name="currentQuantity">Current quantity of the Item in the Inventory</param>
            <param name="user"></param>
            <param name="targetInventory"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.AcceptsItem(Eco.Gameplay.Items.Item)">
            <summary>Determines if the given item is accepted by the inventory regardless of the count.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.CheckRestrictions(Eco.Gameplay.Items.Inventory.RestrictionCheckType,Eco.Gameplay.Items.Item,System.Int32,System.Func{Eco.Gameplay.Items.InventoryRestriction,System.Int32},Eco.Gameplay.Items.InventoryRestriction@)">
            <summary>Used to check restriction violations affecting the move of an item for this inventory.
            Provides the strongest/most important restriction for further processing and returns the maximum amount this inventories stacks may accept of this item.</summary>
            <param name="checkType">The type of the operation (MaxPickup/MaxAccepted) that the restrictions are checked for.</param>
            <param name="item">The item that is being moved.</param>
            <param name="currentQuantity">The quantity that the stack currently holds.</param>
            <param name="checkMethod">The method used to check the restrictions: either MaxPickup or MaxAccepted.</param>
            <param name="strongestRestriction">If the move got restricted, assuming there might be multiple restrictions, the strongest/most important one will be provided with this out variable.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.TryGetBestRestrictionMessage(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.InventoryRestriction},Eco.Shared.Localization.LocString@)">
            <summary>Given a set of violated restrictions, will try to resolve a message that best describes all restrictions altogether.
            TODO: This was introduced as a quick fix for Store. Eventually inventory moves/restrictions/messages have to be rebuilt to keep a context of the initiating action.</summary>
            <param name="violatedRestrictions">A set of violated restrictions to use for resolution.</param>
            <param name="message">The generated message.</param>
            <returns>If a specialized message could be produced or not.</returns>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryChangeSet">
            <summary>A collection of modifications we wish to perform on an inventory</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.MergeStack(Eco.Gameplay.Items.ItemStack,System.Int32,Eco.Gameplay.Items.Item)">
            <summary>Merges <paramref name="stack" /> with <paramref name="newItem" /> (if it is <see cref="T:Eco.Gameplay.Items.IStackableMergable" />). Otherwise works as <see cref="M:Eco.Gameplay.Items.InventoryChangeSet.ModifyStack(Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.ChangedStack,System.Int32,System.Int32,Eco.Gameplay.Items.Item,System.Boolean)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.MergeItem(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Items.Item,System.Int32)">
            <summary>Merge <paramref name="item" /> with <paramref name="newItem" /> and returns merged item if <paramref name="item" /> is <see cref="T:Eco.Gameplay.Items.IStackableMergable" />. Otherwise just returns <paramref name="newItem" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.ModifyStack(Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.ChangedStack,System.Int32,System.Int32,Eco.Gameplay.Items.Item,System.Boolean)">
            <summary>Modifies inventory <paramref name="stack" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.MoveAsManyItemsAsPossible(Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Inventory)">
            <summary>Try to move all items from src to dst inventory with move result.</summary>
            <remarks>Only returns failure when not a single item is moved otherwise success</remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.MoveAllItems(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Inventory,System.Func{Eco.Gameplay.Items.ItemStack,System.Boolean})">
            <summary>Try to move all items from source to dst inventory with result.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.CheckAuthForMove(Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Inventory,System.Type,System.Int32@)">
            <summary> Checks if user authorized to move stacks between inventories and adjust allowed quantity for inventories with restricted amount (i.e. for distribution station). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.RemoveAsMuchAsPossible(Eco.Gameplay.Items.Stackable,System.Int32)">
            <summary> Tries to remove as much as possible <paramref name="stackable" /> up to <paramref name="requested" />. </summary>
            <returns> Returns all removed items with count. </returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.DescribeWhatItAdds">
            <summary>Return a comma-separated string of the recent items added to the inventory.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.GetDestinationStacksEnumerator(Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.ItemStack)">
            <summary>Returns appropriate destination stacks enumerator based on params.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryMoveResult">
            <summary>Result from inventory change set moved items</summary>
            <param name="Result"> Normal result from item inventory move changes </param>
            <param name="PartialMove"> whether or not move managed to take all items or only a portion</param>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryMoveResult.#ctor(Eco.Core.Utils.Result,System.Boolean)">
            <summary>Result from inventory change set moved items</summary>
            <param name="Result"> Normal result from item inventory move changes </param>
            <param name="PartialMove"> whether or not move managed to take all items or only a portion</param>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryMoveResult.Result">
            <summary> Normal result from item inventory move changes </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryMoveResult.PartialMove">
            <summary> whether or not move managed to take all items or only a portion</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryAccessType">
            <summary>Used to describe the access type of inventory (are we using in with player hands or from vehicle tool, etc)</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.RestrictionType">
            <summary>This helps in preparing a simple contextual error message for invalid inventory move (when all stacks produced a restriction).
            See <see cref="M:Eco.Gameplay.Items.Inventory.TryGetBestRestrictionMessage(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.InventoryRestriction},Eco.Shared.Localization.LocString@)" />.</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RestrictionType.Space">
            <summary>When everything can be added to the inventory and the only limit is space (currently only serves Stockpile).</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RestrictionType.Specialized">
            <summary>When only a specialized set of items can be added to the inventory (Fuel/Silo etc.).</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryRestriction">
            <summary>Restricts an inventory from accepting or applying an operation</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Message">
            <summary>Localized message shown to the user when the restriction checks do not pass.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.Item,System.Int32)">
            <summary>Custom handler for defining restriction max accepted rules.</summary>
            <returns>The max amount of items that can be accepted. Otherwise -1 for default behavior.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxPickup(Eco.Gameplay.Items.RestrictionCheckData,Eco.Gameplay.Items.Item,System.Int32)">
            <summary>Custom handler for defining restriction pickup rules.</summary>
            <returns>The max amount that can be picked up. Otherwise -1 for default behavior.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.RestrictionCheckData,Eco.Gameplay.Items.Item,System.Int32)">
            <inheritdoc cref="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.Item,System.Int32)" />
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Priority">
            <summary>The priority of the restriction. Used to find the most important restriction (<see cref="M:Eco.Gameplay.Items.Inventory.CheckRestrictions(Eco.Gameplay.Items.Inventory.RestrictionCheckType,Eco.Gameplay.Items.Item,System.Int32,System.Func{Eco.Gameplay.Items.InventoryRestriction,System.Int32},Eco.Gameplay.Items.InventoryRestriction@)" />)
            from all of the applied restrictions for a given inventory stack.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Type">
            <summary>See <see cref="T:Eco.Gameplay.Items.RestrictionType" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Items.PutOnlyRestriction">
            <summary>Prevents a user from picking up items from an inventory.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemTypeLimiterRestriction">
            <summary>Restricts an inventory instance to only accept items matching the given types. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NoAddRestictions">
            <summary>Prevents the inventory from accepting anything.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CarriedRestriction">
            <summary>Restricts an inventory instance to only accept items carried.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NoBuildingRestriction">
            <summary>Restricts the inventory from accepting building materials.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.RepairableRestriction">
            <summary>Restricts the inventory to only accept items that need to be repaired</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NotCarriedRestriction">
            <summary>Restricts the inventory to only accept items that are not carried.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.WeightRestriction">
            <summary>Prohibits the inventory Prohibits from accepting items beyond the weight limit</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FuelRestriction">
            <summary>Restricts the inventory to only accept fuel items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SeedRestriction">
            <summary>Restricts the inventory to only accept items that are seeds</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SpecificItemTypesRestriction">
            <summary>Restricts the inventory to only accept specific items</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagRestriction">
            <summary>Restricts the inventory to only accept items that match the given tags.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackableRestriction">
            <summary>Restricts an inventory so it can only accept specific stackable items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ClothingRestriction">
            <summary>Restricts an inventory to only accept fitting a specific slot</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackLimitRestriction">
            <summary>Limits the inventory stack sizes to a different quantity than <see cref="P:Eco.Gameplay.Items.Item.MaxStackSize" /></summary>
        </member>
        <member name="P:Eco.Gameplay.Items.StackLimitRestriction.MaxItems">
            <summary>The maximum stack size allowed by the restriction.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.StackLimitRestriction.StaticLimit">
            <summary>If true this inventory restriction will not apply external modifiers to its settings.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackLimitTypeRestriction">
            <summary>Limit the inventory stack sizes to a different quantity than <see cref="P:Eco.Gameplay.Items.Item.MaxStackSize" /> depending on item type table</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SiloRestriction">
            <summary>Sets an inventory to only accept items with tag seeds, crops, or fertilizer</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FoodStorageRestriction">
            <summary>Sets an Inventory to only accept food tag items</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SettlementRestriction">
            <summary>Sets an inventory to only accept items matching a specific settlement, for items associated with settlements</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.CanMoveItems(Eco.Gameplay.Items.Inventory,System.Type,System.Int32,Eco.Gameplay.Players.User,System.Int32@)">
            <summary> Checks whether it's possible for the <paramref name="user" /> to perform changes in this inventory. </summary>
            <param name="inventory"></param>
            <param name="itemType"> Some inventories can allow to move item of specific types (like in workables). </param>
            <param name="allowedQuantity"> Amount of items being moved, absolute value. The value may be adjusted by some restrictions (like in item distribution component). </param>
            <param name="delta"> Signed amount of items being moved. </param>
            <param name="user"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.TryGetFirstStackMatchingOrEmpty(Eco.Gameplay.Items.Inventory,System.Func{Eco.Gameplay.Items.Item,System.Boolean},Eco.Gameplay.Items.ItemStack@)">
            <summary>Tries to find first stack matching <paramref name="predicate" /> or if not found then uses first empty stack. It may fail if inventory is full.</summary>
            <returns><c>true</c> if either matching or empty stack was found; <c>false</c> if inventory is full and no matching stack.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.FindItemStack(Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Item)">
            <summary>Attempts to find a <see cref="T:Eco.Gameplay.Items.ItemStack" /> based on an <see cref="T:Eco.Gameplay.Items.Item" /> type instance inside the Inventory</summary>
            <param name="inventory">Inventory to search</param>
            <param name="searchItem"><see cref="T:Eco.Gameplay.Items.Item" /> type instance to search for</param>
            <returns>The first discovered <see cref="T:Eco.Gameplay.Items.ItemStack" /> instance if found. Otherwise null</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.ContainsItem(Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Item)">
            <summary>Checks if the inventory contains any instances of the requested search <see cref="T:Eco.Gameplay.Items.Item" /> type instance.</summary>
            <param name="inventory">Inventory to search</param>
            <param name="searchItem"><see cref="T:Eco.Gameplay.Items.Item" /> type instance to search for</param>
            <returns>True if an instance was found. Otherwise false</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStack.ReplaceStack(Eco.Gameplay.Items.Item,System.Int32,System.Boolean,Eco.Gameplay.Players.User)">
            <param name="notifyParentInventory">
            We set this to true when we want the parent inventory to be automatically notified about the stack change.
            We set it to false in the rare cases where we actually want to do that manually. (I.E when we want to replace many stacks in an inventory, it's better to do that and then notify the inventory in the end for better performance).
            </param>
            <param name="user">The user that's doing the replacement.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStack.ModifyFractional(Eco.Gameplay.Items.Item,System.Single,Eco.Gameplay.Players.User)">
            <summary>Modifies item together with it's <see cref="P:Eco.Gameplay.Items.ItemStack.FractionalQuantity" />.</summary>
            <param name="user">The user that's doing the replacement.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStack.Deconstruct(Eco.Gameplay.Items.Item@,System.Int32@)">
            <summary> Deconstructs <see cref="T:Eco.Gameplay.Items.ItemStack" /> into <see cref="P:Eco.Gameplay.Items.ItemStack.Item" /> and <see cref="P:Eco.Gameplay.Items.ItemStack.Quantity" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStackExtensions.CountItems(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.ItemStack},System.Type)">
            <summary>Sumes quantities of items matching type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStackExtensions.TryRemove(Eco.Gameplay.Items.ItemStack,System.Int32)">
            <summary>Subtract what we can and return the number removed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ToolbarBackpackInventory">
            <summary>Represents the player's combined toolbar and backpack inventories.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.UserInventory.SendInventoryNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,System.Int32}},System.Collections.Generic.List{Eco.Gameplay.Items.ItemStack})">
            <summary>Send notifications for items added in inventory</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.UserInventory.GetNotificationPosition(Eco.Gameplay.Items.Inventory)">
            <summary>Returns Instant Notification position depending on Inventory type</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Item">
            <summary>Base class for all inventory friendly items inside Eco.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.DisplayName">
            <summary> Returns display name for given item. This name same as class Display Name and should be specified as [LocDisplayName] attribute. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.WeightWithoutModifiers">
            <summary>Represents the true weight of this item as intended by the item's designers.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.Weight">
            <summary>Represents the <see cref="P:Eco.Gameplay.Items.Item.WeightWithoutModifiers" /> if this item with player defined modifiers attached.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.HasWeight">
            <summary>Flag determining if this item instance has associated weight.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Item.Destroy(System.Int32)">
            <param name="quantity">The quantity of the stack that's related to this item.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.Item.UnsubscribeUnique">
            <summary>This get called whenever a unique item is destroyed. This method will make sure that if the item is unique and has some subscriptions it will unsubscribe from them all.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemAttribute.TryGet``1(System.Type,``0@)">
            <summary> Tries to get item attribute of requested type. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IconGroup">
            <summary>
            Grouping for icons exported to text files.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AirPollutionAttribute">
            <summary> Attribute for items which makes an World Object with Air Pollution. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.LiquidProducerAttribute">
            <summary> Attribute for items which produces Liquid (or Gases). </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.MaxStackSizeAttribute">
            <summary>
            Define the max stack size of the item. Difficulty Settings may increase this value (<see cref="P:Eco.Gameplay.Items.ItemModifiers.StackSizeModifier" />) 
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.MaxStackSizeAttribute.Default">
            <summary>Controls the default maximum stack size of items. Override this to change the global stack size of items that don't already have an instance of <see cref="T:Eco.Gameplay.Items.MaxStackSizeAttribute" />. Defaults to 100.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CanMakeBlockFormAttribute">
            <summary> This tool can make forms, based on its tier. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CarryTypesLimitedAttribute">
            <summary>
            When the given item can only hold specific items, such as the shovel.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.LawsDropdownIgnoreAttribute">
            <summary>
            To ignore some items in laws picker.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.BlockItemInfo">
            <summary>Block information about block item passed to client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InteractableItemInfo">
            <summary>Interactable information about interactable item passed to client.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InteractableItemInfo.InteractDistance">
            <summary> For IInteractingItem, the distance that it can be interacted with. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InteractableItemInfo.HighlightBlockIDs">
            <summary> For IInteractingItems, the block IDs that will get highlighted. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemInfo">
            <summary>General information about item passed to client. Also see inherited classes for additional info.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemInfoManager">
            <summary>Keeps item infos synced with the client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemInfoManager.Initialize">
            <summary>Generate item infos</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemInfoManager.GetItemInfo(Eco.Gameplay.Items.Item)">
            <summary>Generate item info from item. Detects which item info type item is.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ToolItemInfo">
            <summary>Tool related information about tool passed to client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemPersistentData">
            <summary>Contains the persistent data for each component and worldobject itself deriving IPersistentData, allowing that data to be preserved and 
            restored as the object is placed and put down. This is stored on the WorldObjectItem when the WorldObject is picked up, and on the WorldObject itself when it's placed.</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.ItemPersistentData.ResetButton">
            <summary>Clickable tooltip section, triggers ClearOnRequest (see ResetDataTooltip).</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ClearPersistentItem(System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>We make sure to remove invalid items from the peristent data list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.TryGetPersistentData``1(System.Object@)">
            <summary>Tries to obtain persistent data for <typeparamref name="TComponent" /> if it was previously added by <see cref="M:Eco.Gameplay.Items.ItemPersistentData.TryAddPersistentDataFromComponent(Eco.Gameplay.Items.IPersistentData)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.SetPersistentData``1(System.Object)">
            <summary>Sets persistent data for the component of type <typeparamref name="TComponent" />. If <paramref name="data" /> is <c>null</c> then removes component data.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.TryAddPersistentDataFromComponent(Eco.Gameplay.Items.IPersistentData)">
            <summary>Tries to add <see cref="P:Eco.Gameplay.Items.IPersistentData.PersistentData" /> from <paramref name="component" /> if it wasn't previously added.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.TryRestorePersistentDataToComponent(Eco.Gameplay.Items.IPersistentData)">
            <summary>Tries to restore data to <see cref="P:Eco.Gameplay.Items.IPersistentData.PersistentData" /> of <paramref name="component" /> if it is in <see name="entries" />. If restored successfully then corresponding entry removed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.Clear">
            <summary>Internal way of cleaning. Completely removes all entries without any checks.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ClearOnRequest(Eco.Gameplay.Players.Player)">
            <summary>Cleaning requested by the player. Notifies entries with <see cref="T:Eco.Gameplay.Items.IClearRequestHandler" /> interface and removes all entries without <see cref="T:Eco.Gameplay.Items.IClearRequestHandler" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ClearOnTrade">
            <summary>Removes all entries with <see cref="T:Eco.Gameplay.Items.IClearOnTrade" /> interface. It also will call <see cref="M:Eco.Gameplay.Items.IPermanentDestroyHandler.OnPermanentDestroy" /> for all such entries which implements <see cref="T:Eco.Gameplay.Items.IPermanentDestroyHandler" /> interface.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.RemoveEntries(System.Func{System.Object,System.Boolean})">
            <summary>Removes all entries matching <paramref name="filter" />. It also will call <see cref="M:Eco.Gameplay.Items.IPermanentDestroyHandler.OnPermanentDestroy" /> for all such entries which implements <see cref="T:Eco.Gameplay.Items.IPermanentDestroyHandler" /> interface.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ShowResetDialog(Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Players.User)">
            <summary>A dialog to be shown when the reset button is clicked.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.EnumerableItemExtensions.MakeSafe``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <param name="allowEmptyStack">Sometimes we still want to return the stacks that are empty (quantity == 0).</param>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemUtils.CanBeStackedOn(Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Item)">
            <summary>Can these items be stacked in general? Pays attention to the IUniqueStackable interface, which will allow some unique items to stack.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemUtils.CanBeAutomaticallyStackedOn(Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Item)">
            <summary>Checks whether these items will be automatically stacked. 
            E.g. food items with different spoilage can be stacked manually, but not automatically when picked up or moved from a storage,
            so checking only if they can stack will break the logic of food items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IPersistentData">
            <summary> This interface is used to store data when an object is transformed into an item and to restore it afterwards. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IClearOnTrade">
            <summary> Item data class with this interface will be removed from <see cref="P:Eco.Gameplay.Items.ItemPersistentData.Entries" />
            when the item is being sold. For a demo see <see cref="T:Eco.Gameplay.Components.AuthItemData" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IClearRequestHandler">
            <summary> Item data class with this interface will be notified when someone decides to manually reset the item's persistent data (e.g. via a tooltip).
            Result message will be shown to the player. Entries that return failed result will not be removed from the list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.TryHandleClearAndComposeFeedback(Eco.Gameplay.Items.IClearRequestHandler,Eco.Gameplay.Players.Player,Eco.Shared.Localization.LocStringBuilder)">
            <summary> Triggers clear request handler and adds the result message to the provided string builder. Returns handler's bool result. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.CollectWorldObjectPersistentData(Eco.Gameplay.Items.IPersistentData,Eco.Gameplay.Objects.WorldObject)">
            <summary>This will gather IPersistentData components from the object and store them into PersistentData as a ThreadSafeDictionary.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.AssignWorldObjectPersistentData(Eco.Gameplay.Items.IPersistentData,Eco.Gameplay.Objects.WorldObject)">
            <summary>Takes the data from an item and inserts it into the worldobject being placed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.DestroyRampBlocks(System.Type[],Eco.Shared.Math.Vector3i[])">
            <summary> Destroys all blocks that belong to a ramp </summary>
            <param name="blockTypes"> Expected types of blocks at matching <paramref name="positions" /> </param>
            <param name="positions"> Positions of all blocks that belong to ramp </param>
            <remarks> Blocks at positions stored in <paramref name="positions" /> will be destroyed if they have type matching same index in <paramref name="blockTypes" /> </remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.DestroyRampBlocks(Eco.Shared.Math.Vector3i,Eco.World.Blocks.Ramp,Eco.World.Blocks.Block)">
            <summary> Destroys a ramp </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.GetRampBlockData(Eco.Gameplay.Items.RampItem,Eco.World.Blocks.Block,Eco.Shared.Math.Vector3i)">
            <summary> Get data about all blocks that belong to a ramp given one of it's blocks and this block's position </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Recipes.IngredientElement">
            <summary>Dynamic quantity tag stack.</summary>
            <remarks>Should never be used to represent an actual item.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.Recipe.ActivateVariant(Eco.Gameplay.Items.Recipes.RecipeVariant)">
            <summary> Activates <see cref="T:Eco.Gameplay.Items.Recipes.RecipeVariant" /> for this recipe. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.RecipeFamily.SkillsNeeded">
            <summary> Returns the skills that are needed to craft this recipe, as well as to craft the table this recipe is made on. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Recipes.RecipeManager">
            <summary>Accessors for all recipes.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Recipes.RecipeVariant">
            <summary> Recipe variant with different ingredients which may be activated for <see cref="T:Eco.Gameplay.Items.Recipes.Recipe" /> based on some conditions (like difficulty settings). </summary>
        </member>
        <member name="F:Eco.Gameplay.Items.Recipes.RecipeVariant.Presets">
            <summary> Mapping between presets and list of recipe variants for the preset. All these variants will be applied to their recipe families when preset activated (see <see cref="M:Eco.Gameplay.Items.Recipes.RecipeVariant.ActivatePreset(System.String)" />). </summary>
        </member>
        <member name="F:Eco.Gameplay.Items.Recipes.RecipeVariant.Ingredients">
            <summary> Set of ingredients for the recipe variant which will replace current set of ingredients when activated. See <see cref="M:Eco.Gameplay.Items.Recipes.Recipe.ActivateVariant(Eco.Gameplay.Items.Recipes.RecipeVariant)" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.Recipes.IngredientElement[])">
            <summary>
            Registers <paramref name="recipeFamily" /> default recipe <paramref name="ingredients" /> variant for <paramref name="preset" />.
            Then you can just activate all registered recipe variants for the <paramref name="preset" /> at once with <see cref="M:Eco.Gameplay.Items.Recipes.RecipeVariant.ActivatePreset(System.String)" />.
            <paramref name="preset" /> may have any value, it is just a reference name you can use to activate variants when required.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.RecipeVariant.Register``1(System.String,Eco.Gameplay.Items.Recipes.IngredientElement[])">
            <inheritdoc cref="M:Eco.Gameplay.Items.Recipes.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.Recipes.IngredientElement[])" />
            <typeparamref name="T" /> is recipe family type.
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.RecipeVariant.Register(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,Eco.Gameplay.Items.Recipes.IngredientElement[]}})">
            <summary> Registers multiple recipe variants for a <paramref name="preset" />. <paramref name="mapping" /> param has mapping between <see cref="T:Eco.Gameplay.Items.Recipes.RecipeFamily" /> type and set of ingredients for the <paramref name="preset" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipes.RecipeVariant.RegisterDefault``1(System.String)">
            <summary> Registers default (current, usually from startup) ingredients list of recipe family of type <typeparamref name="T" /> for the <paramref name="preset" />. See <see cref="M:Eco.Gameplay.Items.Recipes.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.Recipes.IngredientElement[])" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.RepairableItem">
            <summary> Represents an Item that can be repaired and is affected on usage, See DurabilityItems.md </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.Durability">
            <summary> Durability for <see cref="T:Eco.Gameplay.Items.RepairableItem" /> uses a value from 0 to <see cref="F:Eco.Gameplay.Items.DurabilityItem.DurabilityMax" /> and is based on <see cref="F:Eco.Gameplay.Items.RepairableItem.durability" /> </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.SkilledRepairCost">
            <summary> The amount needed for to fully repair a broken item.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.DurabilityChangedEvent">
            <summary> An event invoked on server side, used to update shown tooltips on client side for the given item. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.RepairItem">
            <summary> Template for the repaired item needed, cost is calculated based on missing durability. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.RepairTag">
            <summary> The repair tag needed, used if <see cref="P:Eco.Gameplay.Items.RepairableItem.RepairItem" /> is null, this is for cases where multiple items can repair this item. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RepairableItem.RepairableUILink(Eco.Gameplay.Players.User)">
            <summary> Show Proper UI Link for the cost needed to repair this item. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RepairableItem.GetRepairStack(Eco.Gameplay.Players.User)">
            <summary> Gets the repair stack that includes the repair tag or item and the quantity needed to repair the item fully. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.RepairableItem.SkillReqs">
            <summary> The Skills required to repair this item. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RepairableItem.RepairCost(Eco.Gameplay.Players.User)">
            <summary> Calculates the repair cost for the item based on <see cref="P:Eco.Gameplay.Items.DurabilityItem.PercentBroken" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RepairableItem.UseDurability(System.Single,Eco.Gameplay.Players.Player)">
            <summary> Applies durability changes when the item is used. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RepairableItem.GetDurability">
            <summary> Get the current durability of the item. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagDefinition">
            <summary> Tag definition which contains additional attributes for tag. May be used by Mods to configure tags for displaying in different sections or filters. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.All">
            <summary> Contains mapping for all tag definitions. Where <c>key</c> is the lowercase tag name and <c>value</c> is <see cref="T:Eco.Gameplay.Items.TagDefinition" /> itself. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.Name">
            <summary> Tag name. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.PluralName">
            <sumary> An optional plural name for tags. </sumary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.ShowInFilter">
            <summary> If the tag should be should in filters. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.AutoHighlight">
            <summary> If the tag should be auto highlighted (i.e. in chat). </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.ShowInEcopedia">
            <summary> If the tag should be shown in Ecopedia. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagDefinition.Register(Eco.Gameplay.Items.TagDefinition)">
            <summary> Registers new <see cref="T:Eco.Gameplay.Items.TagDefinition" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagManager">
            <summary>Create tags into the tag registrar, using ones that exist already (to preserve ID's) 
            and creating new ones as needed (perhaps a mod gets added)</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagManager.GetOrMake(System.String)">
            <summary>Creates a tag with the given name (or returns existing one if already created)</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagStack">
            <summary>
            should handle all of the tags =&gt; item conversions and comparisons.
            Tag stacks SHOULD NOT be used to represent actual items.
            Mostly should be not-displayed to the user (crafting elements are used for that).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.GarbageBagBlock.UpdateByInventory(Eco.Gameplay.Items.DecayingInventory)">
            <summary> Updates world with <see cref="T:Eco.Gameplay.Items.GarbageBagBlock" /> corresponding to <paramref name="inventory" /> and returns synced block. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.WorkOrder">
            <summary>An item that represents a work order being performed at a crafting table.</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.WorkOrder.shouldSendNotificationOnHalt">
            <summary> This makes sure that the notification is sent out only one time.
            to handle the case of other work orders of the same type on the crafting table and make it avoid shooting multiple notifications of the same type.
            It is set to false by the first work order to halt and set back to true on preventing only one notification.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.UpdateState">
            <summary> Updates work order state when requirements changes (like resources or labor added). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CheckTime(System.Boolean)">
            <summary> Checks if a work order should change state based on its internal timers. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.TryLinkToCraftingComponent(Eco.Gameplay.Components.CraftingComponent)">
            <summary> Tries to link <see cref="T:Eco.Gameplay.Items.WorkOrder" /> to <see cref="P:Eco.Gameplay.Items.WorkOrder.CraftingComponent" /> (usually on load). It may fail if <see cref="T:Eco.Gameplay.Items.WorkOrder" /> is invalid. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.EstimateProducts(System.Int32)">
            <summary> Estimates output products for specified <paramref name="iterations" /> count. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetIterationProducts">
            <summary>
            <p>Gets products for current iteration. It uses scrap for partial product output.
            For last iteration it emits product rounded up, for all other iterations it emits product rounded down with accounting for scrap from previous iterations.</p>
            </summary>
            <sample>
            <p>I.e. for 0.5 Tailing and 5 iterations you will have:</p>
            <li>1. No tailing.</li>
            <li>2. 1 Tailing.</li>
            <li>3. No tailing.</li>
            <li>4. 1 Tailing.</li>
            <li>5. 1 Tailing (last iteration).</li>
            <p>In total you have 2.5 rounded up (to 3).</p>
            </sample>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.DisableSameTypeWorkOrderNotifications">
            <summary>This checks for the crafting component's work orders of same type to disable notifying the user of the issue, since the first work order have the same issue.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CheckCraftingComponentStatus">
            <summary> Checks if the crafting component's parent is already disabled and sets the work order state accordingly. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetCaloriesPerLaborUnit(Eco.Gameplay.Players.User)">
            <summary> Returns labor units per one calorie using worst user skill's multiplicative strategy. Don't allow to go below 1%. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetMaxIterationsForLaborReservation">
            <summary>
            Returns max iterations for which labor may be reserved.
            For short crafts (less than <see cref="F:Eco.Gameplay.Items.WorkOrder.CraftTimePerLaborReservationUnit" />) it will have more iterations per <see cref="P:Eco.Gameplay.Items.WorkOrder.LaborReservationMultiplier" /> unit.
            For long crafts (greater than or equal to <see cref="F:Eco.Gameplay.Items.WorkOrder.CraftTimePerLaborReservationUnit" />) it will have one iteration per <see cref="P:Eco.Gameplay.Items.WorkOrder.LaborReservationMultiplier" /> unit.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetMaxLaborReservation">
            <summary> Returns max labor reservation. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.UpdateAllowedLabor">
            <summary> Updates <see cref="P:Eco.Gameplay.Items.WorkOrder.AllowedLabor" /> using following constraints - at least one ingredient should be added to the craft. After that you can fulfill order with the labor. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.Needs(Eco.Gameplay.Items.Item)">
            <summary> Return true if this or a future iteration needs the given item.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CalculateIterationsForAvailableResources(Eco.Gameplay.Items.Inventory)">
            <summary>
            <p>Calculates estimated number of iterations which may be completed with available resources.</p>
            <b>Notice! This method is incredibly slow and should only be used as rare as possible!</b>
            <p>It scans for all linked inventories to find out potential resources and also for all linked components it collects their linked components to get crafting components which may output to
            linked storages.</p>
            <p>It is very rough estimate after all:
            <ul>
            <li>There no guarantee that another crafting component won't output to other not linked inventory;</li>
            <li>There no guarantee that another crafting component won't contribute to another work order;</li>
            <li>There no guarantee items counted in storages won't go to another work order or won't be picked up by player;</li>
            <li>There no guarantee even within single order that counted items won't be used as another ingredient, because they may have match multiple ingredients
            (i.e. have multiple tags which matches different ingredients or may be used as specific item for one ingredient and match by tag for another ingredient).</li>
            </ul></p>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.GetAllObjectsTooltip(Eco.Gameplay.Players.Player)">
            <summary> Generates tooltip displaying list of all world objects created from this item type in the world </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WorldObjectItem.ShouldCreate">
            <summary>If true, the system will automatically create the world object item when placed. If false, then the item must manually do it in 'PlacingObject'</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.Place(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> RPC that attempts to place the WorldObject that is represented by this item. </summary>
            <remarks> Will still do server-side checks to see if it can indeed be placed, and can fail if it can't. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.CanPlaceObject(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Override this function if you want to have async processing for Place Object action (like asking a citizen for confirmation). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.PlacingObject(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Items.ItemStack,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Do anything special that needs to be done when this thing is placed, by putting it into a game action pack.  The future placed object can be retreived by 
            the passed func, inside posteffects (its assigned in a previous post effect, already setup to run when this is called)</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.Move(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,Eco.Shared.Networking.INetObject)">
            <summary> Attempts to move the WorldObject that this item represents, from its existing point to specified position and rotation. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.GetMoveInfo(Eco.Gameplay.Players.Player,Eco.Shared.Networking.INetObject)">
            <summary> Retrieves the initial info required for a WorldObject's movement, like deed/settlement restrictions and messages, calories required, etc. </summary>
            <remarks> Contains enough info for the client to do the necessary validations and display things properly. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.OnPreWorldObjectPlaced(Eco.Gameplay.Objects.WorldObject)">
            <summary>This is called immediately before placement, before initialization and net object activation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.OnPostWorldObjectPlaced(Eco.Gameplay.Objects.WorldObject)">
            <summary>This called after the world object is placed, added to the world object manager and all its components initialized.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WorldObjectItem.GetOccupancyContext">
            <summary> Default occupancy config set to SideAttached </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagUtils.MeetsTagRequirements(System.Type,System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag},System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.Tag})">
            <summary>Checks if given type meets all tag requirements. Pass null to requirement to ignore it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagUtils.TagNames(System.Object,System.Boolean)">
            <summary> Returns string collection of object's tags. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagUtils.GetBestTag(System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Collects tags of entries and tries to find the best match that is present in each of them. </summary>
        </member>
        <member name="T:Eco.Gameplay.Localization.LocalizationAssemblyParser">
            Extract server assembly localization strings. From Attributes:
            <see cref="T:Eco.Shared.Networking.EcoAttribute" />
            <see cref="T:Eco.Shared.Localization.LocalizedAttribute" />
            <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" />
        </member>
        <member name="M:Eco.Gameplay.Localization.LocalizationAssemblyParser.ExtractChatCommandStrings(System.Type,System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData},System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData})">
            <summary>Adds localized data for all methods with <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> on <paramref name="type" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Localization.LocalizationAssemblyParser.AddChatCommandLocalizedData(System.String,System.String,System.String,System.String,System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData})">
            <summary>Add localized data for chat command.</summary>
        </member>
        <member name="M:Eco.Gameplay.Localization.LocalizationAssemblyParser.AddParamsLocalizedData(System.String,System.String,System.Reflection.MethodInfo,System.Collections.Generic.List{Eco.Shared.Localization.StringLocalizedData})">
            <summary>Add strings for each parameter that can be added to the command.</summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.MaintenancePlugin">
            <summary>
            Server plugin instance for handling automatic shutdown/maintenance notifications for Eco Server. 
            It will automatically post a notification on the configured countdown intervals found in the Maintenance configuration options under <see cref="P:Eco.Gameplay.Maintenance.MaintenancePluginConfig.CountdownIntervals" />
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.MaintenancePlugin.AutoRestartScheduled">
            <summary>Determines if an automatic maintenenace window is set.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.MaintenancePlugin.UserShutdownScheduled">
            <summary>Determines if a user defined maintenance window is set. </summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.UpdateAnnounceIntervals">
            <summary>Updates <see cref="F:Eco.Gameplay.Maintenance.MaintenancePlugin.announceIntervals" /> on init or when config changes to have sorted from lower to greater announce intervals for <see cref="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetAnnounceRemainingSeconds(System.Int32)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.UpdateAutoShutdown">
            <summary>
            Updates our currently cached <see cref="F:Eco.Gameplay.Maintenance.MaintenancePlugin.autoScheduledMaintenance" /> to account for the current day and currently configured
            automatic shutdown hour to determine the next time the server will automatically shutdown.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetAnnounceRemainingSeconds(System.Int32)">
            <summary>Returns remaining time in seconds until next announce for given <paramref name="remainingSeconds" /> time.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.TryGetNextSchedule(Eco.Gameplay.Maintenance.ScheduledMaintenance@)">
            <summary>Tries to retrieve the next scheduled maintenance if any</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.ScheduleUserMaintenance(System.DateTime,System.String,Eco.Gameplay.Maintenance.MaintenanceReason,System.Boolean)">
            <summary>Schedules a new user defined maintenance period</summary>
            <param name="time"><seealso cref="T:System.DateTime" /> the maintenance shutdown should occur.</param>
            <param name="message">Message stating message of shutdown.</param>
            <param name="reason">Reason for the maintenance. Defaults to <see cref="F:Eco.Gameplay.Maintenance.MaintenanceReason.Shutdown" /></param>
            <returns>true if the maintenance was scheduled. Otherwise returns false</returns>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.ScheduleUserMaintenance(System.String,System.String,Eco.Gameplay.Maintenance.MaintenanceReason)">
            <inheritdoc cref="M:Eco.Gameplay.Maintenance.MaintenancePlugin.ScheduleUserMaintenance(System.DateTime,System.String,Eco.Gameplay.Maintenance.MaintenanceReason,System.Boolean)" />
            <param name="timeStr">DateTime string to schedule the maintenance for.</param>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.CancelUserMaintenance(System.Boolean)">
            <summary>Clears the currently setup user maintenance periods.</summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.MaintenancePluginConfig">
            <summary>Defines the configuration options used by <seealso cref="T:Eco.Gameplay.Maintenance.MaintenancePlugin" /></summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.MaintenancePluginConfig.CountdownIntervals">
            <summary>Defines the announcement countdown intervals in minutes. The 30 second countdown is handled internally by code.</summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.MaintenanceReason">
            <summary>Represents a reason for a scheduled maintenance.</summary>
        </member>
        <member name="F:Eco.Gameplay.Maintenance.MaintenanceReason.Shutdown">
            <summary>Maintenance reason representing a normal application shutdown. Exists with the value of <see cref="F:Eco.Core.Plugins.ApplicationExitCodes.NormalShutdown" /></summary>
        </member>
        <member name="F:Eco.Gameplay.Maintenance.MaintenanceReason.Restart">
            <summary>Maintenance reason representing an automatic restart. Exits with the value of <see cref="F:Eco.Core.Plugins.ApplicationExitCodes.ApplicationRestart" /></summary>
        </member>
        <member name="F:Eco.Gameplay.Maintenance.MaintenanceReason.Update">
            <summary>Maintenance reason representing an automatic update. Exits with the value of <see cref="F:Eco.Core.Plugins.ApplicationExitCodes.ApplicationUpdate" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.ScheduledMaintenance">
            <summary>Represents a scheduled maintenance period.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.ScheduledTime">
            <summary>Defines the date and time of automatic shutdown. This value is in UTC.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.LocalScheduledTime">
            <summary>Defines the date and time of thew automatic shutdown. This value is in local machine time.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.TimeRemaining">
            <summary><see cref="T:System.TimeSpan" /> representing the remaining time until maintenance.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.SecondsRemaining">
            <summary>Integer representing the amount of seconds remaining before this maintenance window.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.MaintenanceMessage">
            <summary>Reason for maintenance/shutdown.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.IsExpired">
            <summary>Boolean flag determining if this maintenance period is expired.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.IsSet">
            <summary>Boolean flag determining if this maintenance period is set.</summary>
        </member>
        <member name="F:Eco.Gameplay.Maintenance.ScheduledMaintenance.MaintenanceReason">
            <summary>Determines the reason for application shutdown.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.Common.ItemRenameMigration">
            <summary><see cref="T:Eco.Gameplay.Migrations.Common.ItemRenameMigration" /> simplifies renaming of <see cref="T:Eco.Gameplay.Items.Item" /> classes. It takes care about item objects (if existed) and existing work orders for that item.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.Common.MailMessageMigration">
            <summary>Base migration for Mail Messages.&gt;</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.Common.MailMessageMigration.OverridesMethod(System.String)">
            <summary>Checks if migration implementation overrides a method with <paramref name="methodName" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.Common.MailMessageMigration.ShouldMigrateMessage(System.String,System.String)">
            <summary>Checks if mail message should be migrated.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.Common.MailMessageMigration.MigrateCommonId(System.String,System.String)">
            <summary>Migrates CommonId for mail message.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.Common.MailMessageMigration.MigrateText(System.String,System.String)">
            <summary>Migrates Text for mail message.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.MigrationDummyBlock">
            <summary>Dummy block without properties/fields for migration purposes. May be used to declare new or intermediate block type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.MigrationDummyItem">
            <summary>Dummy block without properties/fields for migration purposes. May be used to declare new or intermediate item type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_10_0.GamePickerListRequiredTagMigration">
            <summary>All required tags that were "Object" should instead be empty.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_10_0.InvalidItemAndObjectMigration">
            <summary> Migrates all objects that are now considered abstract, replaces with non-abstract objects. </summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.GetOrCreateChatReceiverByTag(System.String)">
            <summary>Resolves <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver" /> (User or Channel) from <paramref name="tag" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.GetOrCreateChannel(Eco.Gameplay.Migrations.V0_9_5.ChatMigration.Context,System.String)">
            <summary>Gets or creates <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel" /> by name.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.Context">
            <summary>Lazy loading context with all registrars and caches.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.GenericGamePickerListMigration">
            <summary> Migrates all existing <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" />s to <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList`1" />, using <see cref="P:Eco.Gameplay.Civics.GameValues.GamePickerList.MustDeriveType" /> as 'T'.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.StoreOffersToCategoriesMigration9dv5">
            <summary> Migration related to splitting offers by categories at store </summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_6.CivicArticleMigration.MigrateConditions(Eco.Core.Serialization.Migrations.DataMigration,System.Type,System.String,System.String)">
            <summary>This will help to convert old condition member to the new GamePickerList entry.
            To create a game picker entry we will first create a value of a type we need and convert it to a GamePikerList entry.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_6.DistrictMapMigration">
            <summary> Migrates DistrictMap's `Districts` ControllerList to ControllerDictionary. </summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_6.DoorObjectMigration">
            <summary>Migrates all existing DoorObject to HewnDoorObject because DoorObject made abstract.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_6.RegistrarIdMigration.MigrateRegistrar``1(System.Type[])">
            <summary>
            Migration for registrars to Universal IDs.
            - Remembers mapping between old id and a registrar object
            - Converts IdToObj dictionary to collection of Objs
            - Resolves references for old ids using created mapping 
            - Return old IDs mapped to their objects.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_6.RegistrarIdMigration.MigrateUsers">
            <summary>
            Migration for Users to new ids
            - Remembers mapping between old id and user name
            - Resolves user references using mapped name and registrar lookup by name 
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_6.RegistrarIdMigration.MigrateTags">
            <summary>
            Migration for Tags to new ids
            - Remembers mapping between old id and tag name
            - Resolves tag references using mapped name and registrar lookup by name 
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_6.SettlementTypeMigration">
            <summary> Migration related to Settlement.SettlementType migrated from enum to class </summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_6.TradeOfferMigration">
            <summary> From the version 3.9208 find all the stores and update the max durability /// </summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_7.InvalidItemAndObjectMigration">
            <summary> Migrates all objects that are now considered abstract, replaces with non-abstract objects. </summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_7.ResidencyLinksMigration">
            <summary>Removes user id from residency links.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_7.ResidencyLinksMigration.MigrateText(System.String,System.String)">
            <summary>Removes user id from residency links.</summary>
        </member>
        <member name="T:Eco.Gameplay.Minimap.IMinimapObject">
            <summary>Represents an object that can be displayed on the minimap.</summary>
        </member>
        <member name="T:Eco.Gameplay.Minimap.MinimapObject">
            <summary>Straight implementation of the IMinimapObject interface, used to allow objects to make use of minimap icons separate from themselves (IE, when we want
            to share a minimap object without syncing the entire object, like with trees/world objects).</summary>
        </member>
        <member name="M:Eco.Gameplay.Minimap.MinimapObject.UpdatePosition(System.Numerics.Vector3,System.Nullable{System.Single})">
            <summary> Prevents excesive updates of minimap icons. It will update position only if it changed position by 0.3m or if have at least 1 degere of difference of rotation. </summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.AllowPluginModulesAttribute.GetStackables">
            <summary> Returns <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.Tags" /> and <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.ItemTypes" /> combined into single enumerable. </summary>
            <returns> <c>null</c> if both <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.Tags" /> and <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.ItemTypes" /> is null, concatenation of items and tags otherwise. </returns>
        </member>
        <member name="T:Eco.Gameplay.Modules.EfficiencyModule">
            <summary>
            Abstract class for efficiency modules (both resource and speed) which may be used to enhance a table.
            It may only <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> values which associated to same <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> or if <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> not specified then apply to any value.
            </summary>
            <sample>
            This code creates Hewing Efficiency Module which modifies both resource and speed efficiency and only applies to values associated with HewingSkill.
            <code>
            class HewingEfficiency1 : EfficiencyModule
            {
               public HewingEfficiency1() : base(ModuleTypes.ResourceEfficiency | ModuleTypes.SpeedEfficiency, typeof(HewingSkill), 0.9f) { }
            }
            </code></sample>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType">
            <summary> Module will only be applied to values associated with same <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> if specified. </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.GenericMultiplier">
            <summary> Module efficiency generic multiplier (applies to all recipes). Dynamic value in <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> will be multiplied on this to get final value. </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.SkillMultiplier">
            <summary> Module efficiency skill-related multiplier (only applies to recipes for <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" />). Dynamic value in <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> will be multiplied on this to get final value. </summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)">
            <inheritdoc cref="M:Eco.Gameplay.Modules.PluginModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" />
        </member>
        <member name="T:Eco.Gameplay.Modules.IModule">
            <summary> Interface for in-game modules. Now it is only used for PluginModule, but going to be extended for all module types. Provides API point for modifying dynamic modules within <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Modules.ModuleTypes">
            <summary> Possible <see cref="T:Eco.Gameplay.Modules.PluginModule" /> types. </summary>
        </member>
        <member name="T:Eco.Gameplay.Modules.PluginModule">
            <summary> Base abstract class for plugin modules which may be used as plugin for a table to enhance it in some way (like increase efficiency, extend labor queue etc). </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.PluginModule.ModuleTypes">
            <summary> Types of the modules (ResourceEfficiency, SpeedEfficiency etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.PluginModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)">
            <summary> Modified <paramref name="value" /> using the module. I.e. if <see cref="P:Eco.Gameplay.DynamicValues.ModuleModifiedValue.ValueType" /> is <see cref="F:Eco.Gameplay.DynamicValues.DynamicValueType.Efficiency" /> then it may be decreased by some percent. </summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.BuildingWorldObjectBlock">
            <summary>
            Solid world object block used as a placeholder in occupied blocks. Marked as solid on the client, for builder purposes.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)">
            <summary>
            Marks Eco object as dirty. This object will be saved in background by StorageManager.
            It prevents too often saves for object for often modifications and ensures object will be eventually save latest modifications.
            If object isn't thread-safe for concurrent modifications then use <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.Modify``1(``0,System.Action{``0})" /> instead of make direct changes and call <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)" />.
            </summary>
            <param name="obj">object marked as dirty.</param>
        </member>
        <member name="M:Eco.Gameplay.Objects.EcoObjectManager.Modify``1(``0,System.Action{``0})">
            <summary>
            If Eco object isn't safe for concurrent modifications then instead of using <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)" /> directly make all object modifications inside of modifyAction.
            It also marks object as dirty.
            It will guarantee object won't be saved during modification and no other concurrent modification will be performed to that object.
            </summary>
            <param name="obj">object to modify.</param>
            <param name="modifyAction">action which modifies object.</param>
        </member>
        <member name="T:Eco.Gameplay.Objects.ITickOnDemand">
            <summary>Interface for components (and other objects) which may want to have call to <see cref="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand" /> when closest <see cref="M:Eco.Gameplay.Objects.WorldObjectManager.TickAll" /> happens. It it was added within <see cref="M:Eco.Gameplay.Objects.WorldObject.Tick" /> then it will be processed same tick. They may be registered with <see cref="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand">
            <summary>Ticks only when explicitly requested (see <see cref="T:Eco.Gameplay.Objects.ITickOnDemand" /> docs).</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)">
            <summary>
            Adds <paramref name="tickable" /> to closest (current or next) <see cref="M:Eco.Gameplay.Objects.WorldObjectManager.TickAll" /> which may not want to tick every time, but instead tick only when specific event happens.
            It may be useful if you wanna delay component state update until tick time, because it may have lot of updates between ticks and processing multiple syncs for every update
            may significantly impact performance. At same time we don't wanna to <see cref="M:Eco.Gameplay.Objects.WorldObjectComponent.Tick" /> every time, because these syncs may not happen for long time
            for most of components and it will just waste CPU time.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.IFreezable">
            <summary> Physics objects that can be freezed, so unity physics wont affect them anymore. Sample: rubble, which after some time of physic simulation gonna to be attach to something and no longer move. 
            This is used mainly for optimizations reasons, so it wont simulate all rubble objects all the time, but there are also another case for that: by example, prevent shop truck from be moved away by physic simulation. </summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.RubbleObject">
            <summary> Represents rubble object. These objects are physicly simulated some time and frozen after that. It's done for optimization reasons so rubbles not gonna be simulated forever. </summary>
        </member>
        <member name="P:Eco.Gameplay.Objects.RubbleObject.PickingUp">
            <summary>This flag should be set when rubble is picking up to prevent concurrent picking same rubble. If you can't set this flag then usually you just need to skip the rubble.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.Breakup(Eco.Gameplay.Players.Player)">
            <summary> Breaks the chunk of rubble into pieces </summary>
            <returns> List of the rubble pieces </returns>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.GetRandomRubble(System.Type)">
            <summary> Returns random rubble type from block's meta info if it exists. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.Spawn(Eco.Gameplay.Players.Player,System.Numerics.Vector3@,System.Type[])">
            <summary> Not inteneded to be invoked directly, use atomic actions or public `Try-` accessors. </summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.WaterWorldObjectBlock">
            <summary>
            A WorldObject Water Block that replaces a Terrain Water Block. Occupies the space in the water, blocking placement
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Objects.WorldObject.CachedSettlementAtPos">
            <summary>Get the settlement associate with this world object.  Defined as the lowest level settlement
            that influences this position.  This is cached data built from the influence map.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.CreateEntity">
            <summary>Called when the net entity is created.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.SetAdminForceEnabled(System.Boolean)">
            <summary>Can be called to force this to be enabled, regardless of component enabled sates.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.ToggleAnimatedState(Eco.Gameplay.Players.Player,System.String)">
            <summary> Toggles the animated state with given name to its opposite state, assuming the calling player has at least consumer access. </summary>
            <remarks> Extra useful for modders that would like to include a variety of states and control them in different ways (e.g.: Player input to turn lights on/off while driving a vehicle). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.MoveWorldObjectTo(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Moves world object by updating position, rotation, block occupancy and triggers moved events.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.CloseUIForAll(System.Boolean)">
            <summary>Force all viewers of the world object UI to close it</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.OnDestroy">
            <summary>Method called from <see cref="M:Eco.Gameplay.Objects.WorldObject.Destroy" /> when world object destroys. May be overriden in inherited classes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.CreateStorageHandle">
            <summary>Creates <see cref="P:Eco.Gameplay.Objects.WorldObject.StorageHandle" /> for world object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.OnCreatePreInitialize">
            <summary>Called before components are created at all.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.OnCreatePostInitialize">
            <summary>Called upon creation, after all components have been initialized.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.DoInitializationSteps">
            <summary>Perform the steps needed for initialization, which is called after OnCreate, and every server start.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.Initialize">
            <summary>Initialize the object and components.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.PostInitialize">
            <summary>For when you have autogen and non-autogen halves of a class that both want to override Initialize. Currently Initalize always happens in the autogen file. Any initalization that happens in PostInitialize will override changes from Initalize.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.ComponentsInitialized">
            <summary>Called after all components have been initialized. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.AddOccupancyRule``1(System.Func{Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Occupancy.OccupancyInfo})">
            <summary>Adds a new dynamic predicate rule to the occupancy dictionary. Note that a predicate rule will be checked first before returning a normal occupancy.</summary>
            <param name="predicate">Takes in a <see cref="T:Eco.Gameplay.Objects.WorldObject" /> instance and returns the occupancies.</param>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.GetOccupancyRangeOrDefault(System.Type)">
            <summary>Returns a world range that encompasses the occupancy. This is an exclusive range.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.GetOccupancyRangeWorldPos">
            <summary>Return a world range that encompasses the whole object in its current position and occupancy.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.GetOccupiedPropertyPositions(System.Type,System.Numerics.Vector3,Eco.Shared.Math.Quaternion)">
            <summary>Returns all plots intersecting with occupied block positions.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.SendUIComponents(Eco.Gameplay.Players.Player)">
            <summary> Sends UI components to the <paramref name="player" />. See <see cref="T:Eco.Gameplay.Objects.WorldObjectComponentClientAvailability" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.ReleaseUIComponents">
            <summary>Releases UI opened by the client. Usually it means to detach all UI components so they may release resources on client and stop receiving component updates. Some UIs may be opened without consumer access so we shouldn't ask any access for RPC to release it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.QueryInteraction(Eco.Gameplay.Players.Player)">
            <summary>Queries available interaction on the world object for <paramref name="player" />. Result depends on user access type, so RPC auth shouldn't be applied.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.InteractOnComponent(Eco.Gameplay.Players.Player,System.Type,System.String,Eco.Shared.SharedTypes.InteractionTriggerInfo,Eco.Shared.SharedTypes.InteractionTarget)">
            <summary>We create this RPC to allow calling an RPC on a component for which the client doesnt have a view, so it uses the world object + component type
            Note: this should be removed once we have a more general system for calling RPCs on sub-components</summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.Continue">
            <summary>Determines flow when processing several things, used as a return value.</summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.WorldObjectComponent">
            <summary>Base class for all world object components. Icon attribute should be applied on a particular descendant, do not put it here.</summary>
        </member>
        <member name="P:Eco.Gameplay.Objects.WorldObjectComponent.Enabled">
            <summary>Flag representing whether or not this component is functioning.  World object enabled state is true if all components are enabled.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectComponent.Initialize">
            <summary>Called to initialize the <see cref="T:Eco.Gameplay.Objects.WorldObjectComponent" /> instance. Components that need a tab also should define HasIcon for themselves, so record a warning if check is failed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectComponent.Destroy">
            <summary>Called to destroy the <see cref="T:Eco.Gameplay.Objects.WorldObjectComponent" /> instance.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectComponent.OnBeforeObjectMoved">
            <summary> Called once the object's move action has been confirmed, but before the actual movement takes place (so the position will be the one before the movement). </summary>
            <remarks> Use this to clean up anything that needs to be cleaned up (e.g.: leftover blocks of stockpile). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectComponent.OnAfterObjectMoved">
            <summary> Called once the object's move action has been confirmed and the position has been updated. </summary>
            <remarks> Use this to re-initialize anything that needs it (e.g.: leftover blocks of stockpile). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.GetWorldObjectsFromComponent(System.Type,System.Boolean)">
            <summary>We get all the world objects that have the specified component.</summary>
            <param name="includeHiddenObjects">Do we want to also get the hidden objects ?</param>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.ObjectIsHidden(System.Type)">
            <summary>We check whether the specified object type or its related item is hidden or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)">
            <inheritdoc cref="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)" />
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.TryMoveWorldObject(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Gameplay.Objects.WorldObject,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Attempts to move an already placed WorldObject to a new position. </summary>
            <remarks> For stockpiles, calories will be used based on their total weight. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.DestroyPermanently(Eco.Gameplay.Objects.WorldObject)">
            <summary><list type="number">
            <item> Triggers OnPermanentDestroy on object's components. </item>
            <item> Packs the objects into an item and triggers OnPermanentDestroy on its entries. </item>
            <item> Destroys the object. </item>
            </list></summary>
        </member>
        <member name="T:Eco.Gameplay.Objects.MayHaveComponentAttribute">
            <summary> Declare this objects that may or may not have a given component. This is needed because any component that is not [Required] or [MayRequire] will be removed on server load, as a way of migrating away old component. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectUtil.CheckForPickUpAsync(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.Player)">
            <summary> Confirms with the player pick up decision based on <see cref="M:Eco.Gameplay.Objects.WorldObjectUtil.PickupConfirmation(Eco.Gameplay.Objects.WorldObject)" /> and <see cref="T:Eco.Gameplay.Economy.Contracts.Contract" />s that depend on it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectUtil.PickupConfirmation(Eco.Gameplay.Objects.WorldObject)">
            <summary>Queries all the components on the object being picked up, asks for their pickupconfirmation strings and assembles the message. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectUtil.SelfAndComponentsWithInterface``1(Eco.Gameplay.Objects.WorldObject)">
            <summary>Return ourselves and any component that derives from the given interface.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectUtil.TryPickupComponents(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Objects.WorldObjectUtil.PickupType,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User,Eco.Gameplay.GameActions.GameActionPack,System.Boolean)">
            <summary> Calls TryPickup for components in the WorldObject, and adds them to the inventory when possible. </summary>
            <remarks> If any component 'TryPickup' instance succeeds, the actionPack won't fail and valid items will be moved. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Objects.MemoryManager">
            <summary> Used to find memory leaks, by example, world objects that are still exists in memory even after removal from the world. </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.BlockOccupancy">
            <summary>Represents an occupancy position in a world object. Used to check if a block is available relative to the world object position. They are mainly used in WorldOccupancyAutogen.cs to declare each occupancy from a WorldObject </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.BlockOccupancyType">
            <summary>Special block occupancy that is used by world object for many purpose. 
            Specify this in world object prefab for autogenerate or at static world object constructor (see WaterwheelObject)</summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils">
            <summary> Contains methods/logic related to specific implementations of occupancies and placement context calculations/processes. By being internal it means that they are used exclusively by the occupancy system. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.GetBlocksAttachedToOneSide(Eco.Gameplay.Occupancy.OccupancyInfo,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,Eco.Shared.Math.DirectionAxis)">
            <summary> Return positions of wall blocks adjacent to the attachable occupancy blocks depend on Placement Side. (Absolute position which refers to world coordinates)</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.GetBlocksAttachedToOneSide(Eco.Gameplay.Occupancy.OccupancyInfo,Eco.Shared.Math.DirectionAxis)">
            <summary> Return positions of wall blocks adjacent to the attachable occupancy blocks depend on Placement Side. (Relative positions to the world objects position)</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.CalculateAttachableSurface(Eco.Gameplay.Occupancy.OccupancyInfo,Eco.Shared.Math.DirectionAxis)">
            <summary> Calculate a surface that a world object can be attached to in one direction.
            It contains a list of blocks that have highest/lowest offset in one particular direction.
            The result should be cached in cachedAttachableSurface. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.TakeFurthestBlocksByAxis(System.Collections.Generic.IEnumerable{Eco.Gameplay.Occupancy.BlockOccupancy},Eco.Shared.Math.DirectionAxis)">
            <summary> Take the furthest blocks at one axis.
            Example: attachable surface with Right axis contains blocks that have the same highest X offset.
              1
             234   =&gt;   4,7 
             567
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.GetPlacementString(Eco.Shared.Math.DirectionAxisFlags)">
            <summary> Return all possible placement string connected with or</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.CustomDirectionName(Eco.Shared.Math.DirectionAxis)">
            <summary> Returns name of side is referring to, e.g, walls, ground. ceiling etc.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.CustomDirectionNamesDistinct(Eco.Shared.Math.DirectionAxis[])">
            <summary>Reduce duplicate wall name in CustomDirectionName</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.GetUnavailablePositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,System.Collections.Generic.List{Eco.Gameplay.Occupancy.PositionsRequirement})">
            <summary> Goes through every position in PositionsRequirement and returns those that failed to meet the requirement function</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.GetRequirementRelevantChunkPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,System.Collections.Generic.List{Eco.Gameplay.Occupancy.PositionsRequirement})">
            <summary> Returns all the chunks that span the positions defined in Occupancy Info list of positions requirements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.EvaluatePositionsRequirement(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,Eco.Gameplay.Occupancy.PositionsRequirement)">
            <summary> Applies the requirement function to each position and whether or not they are all valid</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.Internal.OccupancyInternalUtils.WaterDepthUnavailablePositions(System.Collections.Generic.List{Eco.Shared.Math.Vector3i},System.Int32)">
             <summary> Similar to the placement logic for placing a buoy, it checks that it is placed on top of water and that a solid block is found at maximum depth, 
            and if any of the two previous requirements fails it returns the said position</summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.OccupancyContext">
            <summary> A class that contains the definitions of methods needed for placement related stuff, such as trying to place an object, which positions are invalid when placing an object,
            which chunks does the placement affect, the current placement status of an object already placed.
            More detailed information can be found here: https://github.com/StrangeLoopGames/Eco/wiki/Occupancy-System. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyContext.CanPlaceObject(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            Evaluates give the current occupancy context as to whether or not the object can be placed.
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyContext.GetSurfaceUnavailablePositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns a list of positions that are invalid when placing an object, e.g holding a workbench and trying to place it above empty space </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyContext.GetRelevantChunkPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns the chunks touched by world object occupancy</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyContext.CurrentPlacementStatus(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Evaluates if the the current world object placement is valid, and their respetive message status  e.g Placed on solid ground.</summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.SideAttachedContext">
            <summary> Given a side(s), it checks for solid ground placement at the attached positions of the occupancies position, e.g think of the side of a box, where the box is composed of the occupancies position</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.SideAttachedContext.CanPlaceAt(Eco.Gameplay.Occupancy.OccupancyInfo,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,Eco.Shared.Math.DirectionAxisFlags)">
            <summary>Check if there's at least one valid placement side.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.SideAttachedContext.CurrentPlacementStatus(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Evaluates the current placement status of the world object, by using OccupancyHelper.CanPlace() which checks the blocks attached to the defined side</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.SideAttachedContext.GetRelevantChunkPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns the chunks where all of the object's occupancy positions are found</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.SideAttachedContext.GetSurfaceUnavailablePositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Checks through all blocks attached to the sides and returns invalid positions where the blocks aren't solid ground</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.SideAttachedContext.CanPlaceObject(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Tries to place object on solid ground at one of the sides defined</summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.PositionsRequirementContext">
            <summary> Given a list of positions requirements it checks for each one to be valid, this means evaluating all of their positions by their requirement, such as being placed on solid ground, water, empty space.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.PositionsRequirementContext.CurrentPlacementStatus(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Evaluates each position requirements and returns it's current status as to whether is valid or not </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.PositionsRequirementContext.GetRelevantChunkPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns the chunks where all of the positions from the positions requirements are found </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.PositionsRequirementContext.GetSurfaceUnavailablePositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns all invalid positions which didn't met their respective requirement. e.g water, empty space, solid ground etc.</summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.WaterDepthContext">
            <summary> It makes sure that the object is placed on water, it checks for a solid block within the given depth</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.WaterDepthContext.#ctor(System.Int32,Eco.Gameplay.Occupancy.OccupancyInfo)">
            <summary> Allows to create water depth context from occupancy info, it caches the blocks attached to its down side as the positions to check depth. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.WaterDepthContext.#ctor(System.Int32,System.Collections.Generic.List{Eco.Shared.Math.Vector3i})">
            <summary> Allows to create water depth context by manually setting the positions to check. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.WaterDepthContext.GetRelevantChunkPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns chunks related to the generated downward columns of positions from the positions to check and depth. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.WaterDepthContext.GetSurfaceUnavailablePositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns invalid positions on surface if it isn't placed on water, and also the columns of positions in case the depth check is invalid. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.WaterDepthContext.CanPlaceObject(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Placement logic for placing water depth, it checks that it is placed on top of water and that a solid block is found at maximum depth </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.OccupancyContextUtils">
            <summary> Contains functionality that allows us to operate on OccupancyContexts and make a versions of them readable by the client. </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyContextUtils.GetPlacementRequirements(System.Type)">
            <summary> Gathers the placement requirements for objects of specified type and packs them into a struct that's shareable to the client. </summary>
            <remarks> That struct is used by the client to pre-emptively validate or invalidate the placement, and display useful info without querying the server.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.OccupancyInfo">
            <summary> Contains information about the space that a world object occupies, in the form of a list of block occupancies, that in itself contain information about 
            the position relative to the world objects position, blocktype and occupancy type. 
            More detailed information can be found here: https://github.com/StrangeLoopGames/Eco/wiki/Occupancy-System.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyInfo.GetRange(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns <see cref="T:Eco.Shared.Math.WorldRange" /> at <paramref name="origin" /> position and with specified <paramref name="rotation" />. The range is exclusive.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyInfo.GetBlockPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Returns enumerable of occupancy blocks in world space for specified <paramref name="position" /> and <paramref name="rotation" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyInfo.Contains(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,System.Numerics.Vector3,Eco.Shared.Math.Vector3i)">
            <summary> Checks if object at <paramref name="origin" /> position rotated by <paramref name="rotation" /> and with range extended by <paramref name="extraExtents" /> contains <paramref name="position" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyInfo.CreateWorldRange(System.Collections.Generic.IEnumerable{Eco.Gameplay.Occupancy.BlockOccupancy})">
            <summary> Creates a World Range that contains a list of BlockOccupancy. </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.OccupancyRequirementComponent">
            <summary> Will enable/disable worldobject status if it passes through the world object placement requirements, by default the worldObject will use a surface side from 
            the defined occupancy position to calculate placement requirements, and some specific ones will use surface requirement for more complex  requirements</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyRequirementComponent.UpdateStatus(System.Collections.Generic.List{Eco.Core.Utils.ValResult{System.Boolean}})">
            <summary> Updates the status of the world object based on the results of the placement requirements. </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.OccupancyUtils">
            <summary> Contains public functions related to the occupancy system.</summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyUtils.GetOccupancyUnavailableBlocks(System.Collections.Generic.IEnumerable{Eco.Gameplay.Occupancy.BlockOccupancy},Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,System.Type[])">
            <summary>
            Check if a space (defined by occupancy, position and rotation) is empty or occupied.
            Returns all block positions(not wrapped) that are blocking the occupancy.
            Called when player is trying to place an object.
            <paramref name="blockers" /> represents the block types that can block the placement of an object (e.g. water, solid ground, etc.).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Occupancy.OccupancyUtils.GroundBelow(Eco.Gameplay.Occupancy.OccupancyInfo,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary> Returns positions of ground blocks below the occupancy blocks that have Y offset of 0, 
            if occupancy contains BuildingWorldObjectBlock types only return ground blocks below them </summary>
        </member>
        <member name="T:Eco.Gameplay.Occupancy.PositionsRequirement">
            <summary>Contains list of positions relative to the world object and the requirement they should abide to when placing it, as well as which part of the world object is it referring to 
            and the placement message the requirement refers to</summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.TryGetOutputPosition(Eco.Shared.Math.Vector3i@)">
            <summary>Returns chimney output position if it exits.</summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.IsPipeOutputCloseEnough(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>Checks if pipe output it close enough to the object output (within <see cref="F:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.MaxPipeHorizontalOffset" /> by both horizontal axes).</summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.MaxCanReceive(System.Type)">
            <summary> Max (potential) amount of items with <paramref name="itemType" /> which can be received. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.Consume(Eco.Gameplay.Pipes.PipePayload,System.Boolean)">
            <summary> Consumes <paramref name="input" /> optionally using buffer if <paramref name="useBuffer" /> set. If buffer used then all non instantly consumed capacity will go to the buffer. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.TryFlush(System.Single)">
            <summary> Flushed all non-converted amount to converter. Returns <c>false</c> if converter can't accept it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.ConsumeUnchecked(Eco.Gameplay.Pipes.PipePayload,System.Boolean)">
            <summary> Same as <see cref="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.Consume(Eco.Gameplay.Pipes.PipePayload,System.Boolean)" />, but without cycles check. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.SetEnabled(System.Boolean,Eco.Shared.Localization.LocString)">
            <summary> Enables/disables component and updates status. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.CalculateMaxAmount(System.Single)">
            <summary> Calculates max potentially possible amount to receive. Actual consumed amount may be lower depending on consumer state (disabled, output limited etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.EnsureAmountWanted">
            <summary> Ensures wanted amount calculated. </summary>
        </member>
        <member name="T:Eco.Gameplay.Placement.BlockPlacementUtils">
            <summary>Functions to assist in placing blocks</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.BlockPlacementUtils.PlaceAndNotify(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.BlockItem,Eco.Shared.Math.Vector3i)">
            <summary>Place a block at the given position, stacking or dropping as appropriate.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.BlockPlacementUtils.PlaceBlockUnstacked(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,Eco.Gameplay.Items.BlockItem)">
            <summary> Place a block unstacked, needs unoccupied space. </summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.BlockPlacementUtils.PlaceBlockStacked(Eco.Gameplay.Players.Player,Eco.World.Blocks.Block,Eco.Shared.Math.Vector3i,Eco.Gameplay.Items.BlockItem)">
            <summary> Place a block in an existing stack. </summary>
        </member>
        <member name="T:Eco.Gameplay.Placement.IHostedObject">
            <summary>Add this interface when an object can't exist without a host object. IE. for a more detailed example see <see cref="T:Eco.Gameplay.Civics.Misc.IProposable" /> and <see cref="T:Eco.Gameplay.Civics.Misc.SimpleProposable" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.IHostedObject.AssignHostObject(Eco.Gameplay.Objects.WorldObject)">
            <summary>We assign the hosted object to its new host while at the same time updating what's needed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.IHostedObject.CanBeAssignedTo(Eco.Gameplay.Placement.IOrphanAssignment)">
            <summary>We check whether this hosted object can be assigned to the new container or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.IHostedObject.UpdateHostedObjectValidity">
            <summary>We update the validity of the hosted object according to whether it's still orphan or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.HostedObjectExtension.SetHostObject(Eco.Gameplay.Placement.IHostedObject,Eco.Gameplay.Objects.WorldObject)">
            <summary>Set the hosted object on a specified world object(it can be null), doing the proper needed updates.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.HostedObjectExtension.CheckHostState(Eco.Gameplay.Placement.IHostedObject)">
            <summary>We check the validity of the hosted object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.HostedObjectExtension.GetHostedObject(System.Collections.Generic.IEnumerable{System.Type},Eco.Gameplay.Objects.WorldObject)">
            <summary>Returns objects that are currently hosted on this world object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.HostedObjectExtension.CalcTimeToDisable(Eco.Gameplay.Placement.IHostedObject)">
            <summary>Calculate how much time is left until the hosted object is disabled permanently.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.HostedObjectExtension.InitializeHostedObject(Eco.Gameplay.Placement.IHostedObject)">
            <summary>We use this to initialize the hosted object when necessary.</summary>
        </member>
        <member name="T:Eco.Gameplay.Placement.IMoveableWithRestrictions">
            <summary> Interface for WorldObjects that have restrictions on the 'MoveWorldObject' action (e.g.: some WorldObjects should not be moved outside the influence of their settlement, or to another deed). </summary>
            <remarks> Implement on WorldObjects directly. Automatically detected and invoked by WorldObjectManager.TryMoveWorldObject. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Placement.IMoveableWithRestrictions.CanMove(Eco.Gameplay.Objects.WorldObject,Eco.Shared.Math.Vector3i)">
            <summary> Determines whether the movement of a WorldObject can be performed or not. </summary>
        </member>
        <member name="T:Eco.Gameplay.Placement.IMoveableWithinSettlement">
            <summary> Plug'n'Play movement restriction for WorldObjects that can not be moved outside their settlement with the 'MoveWorldObject' action. </summary>
            <remarks> Implement on the affected WorldObject directly. Fail message can be altered per implementing class to better suit its needs. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Placement.IMoveableWithinDeedAndInfluence">
            <summary> Plug'n'Play movement restriction for WorldObjects that can not be moved outside their deed with the 'MoveWorldObject' action, or outside the influence of the associated settlement. </summary>
            <remarks> Implement on the affected WorldObject directly. Fail message can be altered per implementing class to better suit its needs. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Placement.OrphanAssignmentExtensions.OrphanAssignmentInitializeAsync(Eco.Gameplay.Placement.IOrphanAssignment,System.Boolean)">
            <summary>We use this initializer when we want to wait for the player choice before doing anything else.</summary>
            <param name="immediateAssignement">We set this to true when we want to initialize the container immediatly instead of waiting for after creation.</param>
        </member>
        <member name="M:Eco.Gameplay.Placement.OrphanAssignmentExtensions.OrphanAssignmentOnCreate(Eco.Gameplay.Placement.IOrphanAssignment)">
            <summary>During creation, we need to peform the orphan assignment.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.OrphanAssignmentExtensions.AssignOrphans(Eco.Gameplay.Placement.IOrphanAssignment,System.Boolean)">
            <summary>When creating, we give the option to attach orphaned entries of the appropriate type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.OrphanAssignmentExtensions.SingleOrphanAllowed(Eco.Gameplay.Placement.IOrphanAssignment,Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{Eco.Gameplay.Placement.IHostedObject})">
            <summary>Allow only one orphan to be set.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.OrphanAssignmentExtensions.SetOrphans(Eco.Gameplay.Placement.IOrphanAssignment,Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{Eco.Core.Systems.INamed},System.Collections.Generic.IEnumerable{Eco.Core.Systems.INamed})">
            <summary>Assign a set of proposables as orphans.</summary>
        </member>
        <member name="T:Eco.Gameplay.Placement.WorldObjectPlacementUtils">
            <summary>Funcs for helping place world objects.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.TryPlaceWorldObjectNow(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Gameplay.Items.ItemStack,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <inheritdoc cref="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.TryPlaceWorldObject(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Gameplay.Items.ItemStack,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)" />
        </member>
        <member name="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.TryPlaceWorldObject(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Items.WorldObjectItem,Eco.Gameplay.Items.ItemStack,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Do the steps for placing a world object from a worldobjectitem.</summary>
            <param name="containingStack">Reduces this stack if it succeeds, if set.</param>
            <return>A function that will let the caller retreive the object that is finally placed in a PostEffect, which can then be used in subsequent PostEffects.</return>
        </member>
        <member name="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.FinishPlacement(Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject)">
            <summary>Do notices for a finished placed world object. If an item doesnt create with 'ShouldCreate' flag, it needs to do this expliclty! Otherwise, it happens automaticall.</summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.IsValidPlacement(Eco.Gameplay.Items.WorldObjectItem,System.Numerics.Vector3,Eco.Shared.Math.Quaternion)">
            <summary>
            Same as <see cref="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.IsValidPlacement(Eco.Gameplay.Items.WorldObjectItem,System.Numerics.Vector3,Eco.Shared.Math.Quaternion,System.Collections.Generic.List{Eco.Shared.Math.Vector3i}@)" /> except that this version ignores the occupied block positions.
            Use this if it's not necessary to know what are the occupied blocks.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Placement.WorldObjectPlacementUtils.IsValidPlacement(Eco.Gameplay.Items.WorldObjectItem,System.Numerics.Vector3,Eco.Shared.Math.Quaternion,System.Collections.Generic.List{Eco.Shared.Math.Vector3i}@)">
            <summary>
            Given a world object, a position and a rotation, check if it's a valid placement position for the world object.
            <paramref name="occupiedBlockPositions" /> is a list that will be filled inside this function, containing every block position that is already occupied by an object.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Plants.PlantEntity.SkillType">
            <summary> The skill this plant should give EXP to when harvested. Null if it doesn't return anything</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantEntity.TryHarvest(Eco.Gameplay.Players.Player,System.Boolean,Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Items.InventoryChangeSet,Eco.Gameplay.Items.Item)">
            <summary> Harvest a plant. </summary>
            <param name="player"></param>
            <param name="picked">True this picked directly (ie pressing E), or false if harvested with a tool.</param>
            <param name="pack"></param>
            <param name="changeSet"></param>
            <param name="tool"></param>
        </member>
        <member name="T:Eco.Gameplay.Plants.PlantGameActions">
            <summary>Plant related game actions.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.TrySeed(Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Creates <see cref="T:Eco.Gameplay.GameActions.GameActionPack" />, adds plant seed action to it and tries to perform.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.TrySeedFromInventory(Eco.Gameplay.Items.SeedItem,Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.Inventory,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Creates <see cref="T:Eco.Gameplay.GameActions.GameActionPack" />, adds plant seed action to it, removes seed item from inventory and tries to perform.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.AddSeedAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Adds plant seed action to <paramref name="pack" /> and spawn tended plant as post effect.</summary>
        </member>
        <member name="T:Eco.Gameplay.Plants.PlantActionAware">
            <summary>Override authentication for tree</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantActionAware.ShouldOverrideAuth(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Gameplay.GameActions.GameAction)">
            <summary>Override for tree. Who chopped the tree gain access to its trunks</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.AdditionalUserState`2">
            <summary>
            A mod friendly way of adding additional state to Users.
            </summary>
            <typeparam name="T">The type of the state to save.  Must be convertable to and from a string.</typeparam>
            <typeparam name="TSelf">Self type.</typeparam>
        </member>
        <member name="P:Eco.Gameplay.Players.Avatar.CarriedItem">
            Carried item ref from carried inventory, this is always available on client and updated in both server/client on changes. Its in Avatar class since there are no need to sync it for offline users 
        </member>
        <member name="T:Eco.Gameplay.Players.AvatarTool">
            <summary> Controller for avatar tool states. Helps to sync current tool across players and local views. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.BaseUserIDList`1.AddAndNotifyOrDescribe(Eco.Gameplay.Systems.Chat.IChatClient,System.String,System.String,System.Nullable{Eco.Shared.Localization.LocString},System.String)">
            <summary>Add user to the collection and notify result or describe result</summary>
            <param name="invoker"></param>
            <param name="targetIdOrName"></param>
            <param name="time">For how long user should stay in the list. If empty : time is five years. Format: 1m, 1h, 1d, 1w</param>
            <param name="listDisplayName"></param>
            <param name="reason"></param>
        </member>
        <member name="M:Eco.Gameplay.Players.BaseUserIDList`1.FindAndAddOrRemoveToList(Eco.Gameplay.Systems.Chat.IChatClient,System.String,System.String,System.Boolean,System.Nullable{Eco.Shared.Localization.LocString},System.String)">
            <summary> Helper that shows elements of the collection or tries to add or remove provided string element (updates config if something was changed). </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.BiomeRestrictionsManager.TeleportToClosestLand(Eco.Gameplay.Players.User)">
            <summary>Called from the client whenever player runs out of calories while swimming</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.BiomeRestrictionsManager.CheckBiomeChanges(Eco.Gameplay.Players.User)">
            <summary>Called whenever player moves tiles to check if new tile is in a separate biome and apply biome specific modifiers</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.HighlightPurpose">
            <summary>Enum to set the purpose of adding Object to Highlight, to be able to filter it for various operations. </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.ConstantHighlightInfo">
            <summary>Used for combining Object to highlight and the purpose "marker" to store in main dict of entities to highlight. </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.ConstantHighlightSetting">
             <summary>Syncs which Objects need to be highlighted. Every <see cref="T:Eco.Gameplay.Players.User" /> now has this. So any
             object that must be constantly highlighted on the user's client, must be added through <see cref="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryAddOrUpdate(Eco.Shared.Networking.INetObjectPosition,Eco.Gameplay.Players.HighlightPurpose,System.Double)" /> giving the objects that implements
             <see cref="T:Eco.Shared.Networking.INetObjectPosition" />, purpose <see cref="T:Eco.Gameplay.Players.HighlightPurpose" /> for the objects to be differed what for they are added, and time for highlighting
             (this could be set to infinite). There is <see cref="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryRemove(Eco.Shared.Networking.INetObjectPosition,Eco.Gameplay.Players.HighlightPurpose)" /> if you know what you need to remove and <see cref="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryRemoveByFunc(System.Func{Priority_Queue.SimplePriorityQueue{Eco.Gameplay.Players.ConstantHighlightInfo,System.Double},Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.ConstantHighlightInfo}})" /> if you need to remove objects
             from highlight by some rules or checks, gives ability to remove a collection of objects.
            
             Now used only for MasterTracker talent. This by event gets user and through the user adds(TryAddOrUpdate) here an object(animal) with time limit -
             this will trigger an update for client. And would be immediately highlighted. After this due to limitations for this talent it checks objects for deletion
             through TryRemoveByFunc, this would also trigger an update for client to immediately remove highlight for client. All removals passed to private TryRemove method
             to make a proper deletion. Do not change objsToHighlight collection by hand.</summary>
        </member>
        <member name="F:Eco.Gameplay.Players.ConstantHighlightSetting.objsToHighlight">
            <summary> PriorityQueues contains objects for highlight on client as element, and expire timestamp (using <seealso cref="P:Eco.Simulation.Time.WorldTime.Seconds" />) as priority </summary>
        </member>
        <member name="F:Eco.Gameplay.Players.ConstantHighlightSetting.owner">
            <summary> User owning this instance of setting </summary>
        </member>
        <member name="F:Eco.Gameplay.Players.ConstantHighlightSetting.ObjectRemoved">
            <summary>Raised for every object that removed from highlight both by time or removed by hand. </summary>
        </member>
        <member name="P:Eco.Gameplay.Players.ConstantHighlightSetting.IDsObjectToHighLight">
            <summary> This dictionary sends to client ids of objects to highlight as key</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryAddOrUpdate(Eco.Shared.Networking.INetObjectPosition,Eco.Gameplay.Players.HighlightPurpose,System.Double)">
            <summary> Adding Object to <see cref="T:Priority_Queue.SimplePriorityQueue`2" />. Use zero or less as infinite time to highlight. And populates to client</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryRemove(Eco.Shared.Networking.INetObjectPosition,Eco.Gameplay.Players.HighlightPurpose)">
            <summary>Removes Object from highlight and from dict with timers.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ConstantHighlightSetting.TryRemoveByFunc(System.Func{Priority_Queue.SimplePriorityQueue{Eco.Gameplay.Players.ConstantHighlightInfo,System.Double},Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.ConstantHighlightInfo}})">
            <summary>Remove entities from list by passed Func. If func returns null - do nothing. Does not populates to client, client handles invalidation for itself.
            If one of items failed to remove because of no such item in queue - returns false. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ConstantHighlightSetting.ClearExpired">
            <summary>Removes all entities expired by time. If time set to 0 or lower are not removed by this method. </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.DefaultUserMarkUpService">
            <summary>Default implementation of <see cref="T:Eco.Gameplay.Players.IUserMarkUpService" /> with user name marked up just as UI link.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ExhaustionMonitor.Energize(System.Single)">
            <summary>Give this user an extra number of hours of energy.  This rolls over.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Food.Cravings.Message">
            <summary> The message describing the craving, shown in tooltip for the user.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.Stomach.Nutrients">
            <summary>The nutrients in our belly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Stomach.PlayFoodReaction(Eco.Gameplay.Items.FoodItem)">
            <summary> Get and play the food reaction for eating SFX </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Stomach.BurnCalories(System.Single,System.Boolean)">
            <summary> Burns the specified amount of calories from the stomach. </summary>
            <remarks> Some waste management happens internally if waste is enabled in the config. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.DoEat(Eco.Gameplay.Players.User,Eco.Gameplay.Items.FoodItem)">
            <summary>Build the string created when eating the item, send any notices if fav/worst food is discovered, and return a string description of it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.TastePrefToStringShort(Eco.Gameplay.Players.ItemTaste.TastePreference)">
            <summary> Converts TastePreference enum value to short description string </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.TastePrefToStringDetailed(Eco.Gameplay.Players.ItemTaste.TastePreference)">
            <summary> Converts TastePreference enum value to detailed description string </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.GetFoodTaste(Eco.Gameplay.Items.FoodItem)">
            <summary>Return how a food item tastes (string enum value)</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.GetTastePrefStringShort(Eco.Gameplay.Items.FoodItem)">
            <summary>Return how a food item tastes (short localized description) </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.GetTastePrefStringDetailed(Eco.Gameplay.Items.FoodItem)">
            <summary>Return how a food item tastes (detailed localized description) </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.GroupMarker">
            <summary>Wraps world marker to make a single world marker appear to many users.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.ISessionAuthorizer">
            <summary>Interface for implementing custom user authorization rules for incoming player connections</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ISessionAuthorizer.AuthorizeSession(Eco.Shared.Authentication.LoginSession)">
            <summary>Checks if the <seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance is authorized to connect to this server.</summary>
            <param name="session"><seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance to authorize</param>
            <returns><c>true</c> if the session is authorized. Otherwise <c>false</c> to continue processing.</returns>
        </member>
        <member name="T:Eco.Gameplay.Players.IUserMarkUpService">
            <summary>
            <see cref="T:Eco.Gameplay.Players.IUserMarkUpService" /> is an interface exposed as <c>ServiceHolder{IUserMarkUpService}.Obj</c> for <see cref="T:Eco.Gameplay.Players.User" /> for marking up name, chat tag and name with reputation.
            It exposed to service to make it extendable by Mods (i.e. for custom titles, prefixes etc).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpName(Eco.Gameplay.Players.User)">
            <summary>Marks up <paramref name="user" /> name.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpChatTag(Eco.Gameplay.Players.User)">
            <summary>Marks up chat tag for <paramref name="user" />. This marked up text used in chat for displaying message sender/recipient</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpReputationAndName(Eco.Gameplay.Players.User)">
            <summary>Marked up name combined with marked up reputation.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MountManager">
             <summary>
             Handles the player's mounting and dismounting.
            
             <para>Use <see cref="E:Eco.Gameplay.Players.MountManager.MountEvent" /> and <see cref="E:Eco.Gameplay.Players.MountManager.DismountEvent" /> to attach listeners for when the player mounts a vehicle.</para>
             </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MountManager.OnMount(Eco.Gameplay.Components.MountComponent)">
            <summary>Fired when player has mounted a vehicle.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MountManager.OnDismount(Eco.Gameplay.Components.MountComponent)">
            <summary>Fired when player has dismounted a vehicle.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MovementHackDetector">
            <summary>This class detects when player hacks movement with teleport or increased speed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MovementHackDetector.Waypoint">
            <summary>Stores waypoint info for hack detection.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MovementHackDetector.AddWaypoint(System.Numerics.Vector3,System.Single,System.Double,System.Single@)">
            <summary>
            Adds waypoint for player movement. It contains position, max allowed velocity and client timestamp.
            When new waypoint added and if previous waypoint exists then it checks if distance between waypoints reachable with velocity at last waypoint.
            It doesn't check vertical component, because you may fall or jump with higher speed, but it should be fine in most cases.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MovementHackDetector.Clear">
            <summary>Clears waypoint info. I.e. if you get admin rights and should ignore abnormal movement until admin mode disabled.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.SetMaxAllowedVelocity(System.Nullable{System.Single})">
            <summary>Sets the new MaxAllowedVelocity value. Can be null.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.Player.TwitchEnabled">
            <summary>
            Flag determining if the player currently has the Twitch integration enabled.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Players.Player.OnTwitchEnableStateChange">
            <summary>
            Called when the client changes the value of <see cref="P:Eco.Gameplay.Players.Player.TwitchEnabled" />.
            </summary>
        </member>
        <member name="F:Eco.Gameplay.Players.Player.MountManager">
            <summary>Handles all player vehicle mounting and dismounting logic.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.OpenInfoPanel(System.String,System.String,System.String)">
            <summary> Open info panel </summary>
            <param name="title"></param>
            <param name="text"></param>
            <param name="category"> The category, based on which will be remembered preferred positions and size. </param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.OpenObjectives">
            <summary> Opens the Objectives UI on the client. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.LargeInfoBox(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Opens a large popup dialog box with the supplied text and header.</summary>
            <param name="header">Header of the new popup dialog.</param>
            <param name="message">The text to display to the user in the popup dialog.</param>
            <param name="button">Text to display on the button. Defaults to "Ok".</param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.LargeInfoBoxWithTwoButtons(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Opens a large resizable popup dialog box with the supplied text, header and two buttons.</summary>
            <param name="header">Header of the new popup dialog.</param>
            <param name="message">Text to display to the user in the popup dialog.</param>
            <param name="buttonOne">Text to display on the first button ('Ok' by default).</param>
            <param name="buttonTwo">Text to display on the second button ('Copy' by default).</param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.InputString(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Presents a text input dialog to the user to send a text back to the server or hit cancel.</summary>
            <param name="message">Message to show to the user about the text they are entering</param>
            <param name="defaultText">Default text to place into the input field</param>
            <returns>Text entered by the user if they hit confirm. Otherwise returns the value of <see cref="F:System.String.Empty" /></returns>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.InputPasswordString(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Presents a password input dialog to the user to send a text back to the server or hit cancel.</summary>
            <inheritdoc cref="M:Eco.Gameplay.Players.Player.InputString(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString})" />
        </member>
        <member name="M:Eco.Gameplay.Players.Player.InputLargeString(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Int32)">
            <summary>Presents a large text input dialog to the user to send a text back to the server or hit cancel.</summary>
            <inheritdoc cref="M:Eco.Gameplay.Players.Player.InputString(Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString})" />
            <param name="maxLength">Sets the max number of characters that the user can enter into the text field.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.OptionBox(Eco.Shared.Localization.LocString,System.Collections.Generic.List{System.String})">
            <summary>Shows a dialog with a dropdown.</summary>
            <param name="message">The text to be shown.</param>
            <param name="options">Options to be added to the dropdown.</param>
            <returns>Index of the selected item. -1 if the player cancels the dialog.</returns>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.SetTwitchState(System.Boolean)">
            <summary>Sets the client's current Twitch enabled status state.</summary>
            <param name="state">State that the client is currently in.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.TryDamage(Eco.Shared.Networking.INetObject,System.Single)">
            <summary> Delegates damage to <see cref="P:Eco.Gameplay.Players.Player.User" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.SetTwitchEnabled(System.Boolean)">
            <summary>Sets the player's twitch enabled state</summary>
            <param name="state">Client's new Twitch integration enabled state</param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.CheckEmotes(Eco.Shared.Networking.INetClient,Eco.Shared.States.AnimationEmote,Eco.Shared.States.ExpressionEmote)">
            <summary>
            Sends an RPC only to the player who requested the emote. Player will check if possible to play the emote and then notify the server.
            This function is called from a chat command call when a player wants to change their emote.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.ChangeBodyEmote(Eco.Shared.States.AnimationEmote)">
            <summary>
            These RPCs are called from local player (i.e. owner of this Player) after local player checks if it's possible to play the emote.
            Sends an RPC to all clients. Notify the clients to start playing an emote animation.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.IsValidPlacement(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>
            This function is called by the client when the player is in 'shadow placement' mode.
            It checks if a placement position is valid or not, by receiving the position and rotation of the object to be placed from the player.
            Returns true if the placement is valid, false otherwise. Also returns the blocks that are blocking the object placement position, if any.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerExtensions.MsgOrMailLoc(Eco.Gameplay.Players.User,System.FormattableString,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary> Sends a message to the user if online. if the user is offline the same message will be sent but to the mail, so that it gets seen when the user logs in.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerExtensions.MsgOrMail(Eco.Gameplay.Players.User,Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary> Sends a message to the user if online. if the user is offline the same message will be sent but to the mail, so that it gets seen when the user logs in.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerRPCs.ClientRPC(Eco.Gameplay.Players.Player,System.String,System.Object[])">
            <summary> Send Only to the Player's own client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerRPCs.ClientRPC(Eco.Gameplay.Players.Player,System.String,System.Action,System.Object[])">
            <summary> Send Only to the Player's own client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TimeLog.SecondsPlayedToday">
            <summary>Return the time played in the current day (not the last 24 hours, but in the last set of 24 hours since server start)</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TimeLog.ActiveDays(System.Single)">
            <summary>Counts the amount of days the player was online enough to be considered active.</summary>
            <remarks>A day is counted as active if the player was online for at least <paramref name="minimumHours" /> that day.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Players.TimeUser">
            <summary>
            User which has Date when action can be applied
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UIUtils.CloseUIForAllPlayers(Eco.Gameplay.Utils.IPlayerUseTracking,System.String,System.Boolean,System.Func{Eco.Gameplay.Players.Player,Eco.Shared.Serialization.BSONObject})">
            <summary>Tell every user we've tracked as using this thing to Close the given UI, passing the given bson (for specifying the instance etc)</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.User">
            <summary>
            Partial class for <see cref="T:Eco.Gameplay.Players.User" /> for implementing the <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> interface
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Players.User.AllCitizenships">
            <summary>Citizenship of town, and its country, and its federation, etc (if they exist)</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.User.Achievements">
            <summary>List of achievement names.</summary>
            <remarks>We serialize this even though it comes from the Achievement Manager so achievements can work on a given world even without that.</remarks>
        </member>
        <member name="P:Eco.Gameplay.Players.User.CachedAchievements">
            <summary>Achievements that were given to user while offline, cached so they can be granted when they log back in for steam achievements to work properly</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.#ctor(System.String)">
            <summary> Constructor used only for creating fake users in benchmarks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.NotifyIncomeAndExpensesChange">
            <summary>Force a change in Income and expenses object to update the state of it on client side.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.LoginCompleted">
            <summary> To be called when client already have assigned WorldObserver. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.ParseCachedAchievements">
            <summary>Goes over cached achievements for this user and grants them, called when they enter the world</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.TabSelected(System.String)">
            <summary> On client-site event used when the user select a tab</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.SetUserTexture(System.Byte[])">
            <summary>Sets received byte array from the client as the user's avatar image.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.SetClientData(Eco.Shared.Items.InitialData)">
            <summary> Sets client initial data for this user and calls any methods that use data for setup, Called right after data is returned from the client request</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.TryDamage(Eco.Shared.Networking.INetObject,System.Single)">
            <summary> Tries to make damage to user. If fails for some reason (in example User out of calories) then returns <c>false</c>. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.OpenServerWebpage(System.String)">
            <summary>Asks the user if they would like to open the web path on the server's internal web server.</summary>
            <param name="webPath">The web path you wish to open.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.User.OpenWebpage(System.String)">
            <summary>Asks the user if they would like to open a external website url.</summary>
            <param name="url">The web url you wish to open.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.User.OpenDiscordInvite(System.String)">
            <summary>
            Opens the overlay modal for joining a Discord guild, given its invite code.
            An invite code for a server may look something like eco for a verified server—the full invite being discord.gg/eco something like X3JeE4CV for a non-verified server,
            the full invite being https://discord.gg/X3JeE4CV.
            </summary>
            <param name="code">The invite code for the guild you wish to invite the user to.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.User.OkBoxLoc(System.FormattableString)">
            <summary>Displays an ok box to the player, if the user has a player to show it to.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.InfoBoxLoc(System.FormattableString)">
            <summary>Displays an on screen info boxto the player, if the user has a player to show it to.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.Migrate(Newtonsoft.Json.Linq.JObject)">
            <summary>Migration for the UserConfig from v.0 to v.1. We are using JObject for changes so we need to read, change and populate it once.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.TryGetValues(Newtonsoft.Json.Linq.JObject,System.String,Newtonsoft.Json.Linq.JToken@)">
            <summary>Returns original values collection for user list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.ConvertToStringList(Newtonsoft.Json.Linq.JObject,System.String)">
            <summary>Converts value for <paramref name="name" /> as list of strings. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.ConvertToTimeUserList(Newtonsoft.Json.Linq.JObject,System.String)">
            <summary>Converts value for <paramref name="name" /> as list of <see cref="T:Eco.Gameplay.Players.TimeUser" /> instances with very long ban time.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserDisplay.SetStatus(System.String,Eco.Shared.Localization.LocString)">
            <summary>Add statuses to user's display.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserDisplay.UpdatePropertyStatus">
            <summary>Updates property status only by player's current position.</summary>
            todo: make this private, and make it trigger via events
        </member>
        <member name="T:Eco.Gameplay.Players.UserIdType">
            <summary>Defines all user identification types understood by Eco</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.UserManager">
            <summary>Singleton instance containing all the users in the game, logged in or not.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserManager.Usernames">
            <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all registered usernames.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserManager.Users">
            <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all registered users.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserManager.Admins">
            <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all registered administrative users.</summary>
        </member>
        <member name="F:Eco.Gameplay.Players.UserManager.OnlineUsers">
            <summary><see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all online users.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserManager.TwitchUsers">
            <summary><see cref="T:System.Linq.Enumerable" /> containing all currently logged in users with Twitch integration enabled.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserManager.TwitchStreamerCount">
            <summary>Total number of Twitch enabled users currently logged into the server.</summary>
        </member>
        <member name="F:Eco.Gameplay.Players.UserManager.MinUserNameLength">
            <summary> Minimum User name length accepted, different from other Registrars value, see <see cref="T:Eco.Core.Systems.RegistrarConstants" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.SetSpawnLocation(Eco.Shared.Math.Vector3i)">
            <summary>Sets the currently configured spawn location.</summary>
            <param name="loc">New spawn location to save to <seealso cref="P:Eco.Gameplay.Players.UserConfig.SpawnLocation" />.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.WithTempUserManager(System.Action)">
            <summary>Creates temp user management for time while action is running. Mainly for testing purposes.</summary>
            <param name="action">action to be executed with temp legislation.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.RefreshPerformanceMetrics">
            <summary>Updates our stored metric valeus in the <see cref="T:Eco.Core.DebugStatistic.PerformancePlugin" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.GetOrRelocateSpawnPosition">
            <summary>Get or create a new spawn point.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.AuthorizeClientConnection(Eco.Shared.Authentication.LoginSession)">
            <summary>Checks if an incoming <seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance is authorized to connect.</summary>
            <param name="session"><seealso cref="T:Eco.Shared.Authentication.LoginSession" /> object to authorize</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.AddSessionAuthorizer(Eco.Gameplay.Players.ISessionAuthorizer)">
            <summary>Adds a <seealso cref="T:Eco.Gameplay.Players.ISessionAuthorizer" /> instance to the UserManager's checklist</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.RemoveSessionAuthorizer(Eco.Gameplay.Players.ISessionAuthorizer)">
            <summary>Removes a <seealso cref="T:Eco.Gameplay.Players.ISessionAuthorizer" /> instance from the UserManager's checklist</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.UserRecommendationHandler">
            <summary>Responsible for mailing recommendations to the user, listens to different events and based on it mails the owning user certain actions that can boost gameplay.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserRecommendationHandler.Initialize(Eco.Gameplay.Players.User)">
            <summary>Initializes the recommendation handler to the owning user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserRecommendationHandler.CheckForOptimalHousingValue(Eco.Gameplay.Property.Deed)">
            <summary>Checks for optimal housing values and sends a mail to the owning user if there is a recommendation to change.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserUI.CurrentTab">
            <summary> Information of the last tab selected by the user </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserUI.Logout">
            <summary>When the player logout, we close any open ViewEditor and unsubscribe.</summary>
        </member>
        <member name="T:Eco.Gameplay.PowerGrids.PowerGrid">
            <summary>
            Represents a power grid. A <see cref="T:Eco.Gameplay.PowerGrids.PowerGrid" /> is a collection of <see cref="T:Eco.Gameplay.Components.PowerGridComponent" />s that all share the same energy type.
            A power grid is always fully connected. The three major operations on a power grid are <see cref="M:Eco.Gameplay.PowerGrids.PowerGrid.Join(Eco.Gameplay.Components.PowerGridComponent,Eco.Gameplay.Components.PowerGridComponent)" />, <see cref="M:Eco.Gameplay.PowerGrids.PowerGrid.DisconnectAndSplit(Eco.Gameplay.Components.PowerGridComponent)" />, and <see cref="M:Eco.Gameplay.PowerGrids.PowerGrid.Tick" />.
            <see cref="T:Eco.Gameplay.PowerGrids.PowerGrid" /> is not thread safe.
            </summary>
            <remarks>
            A <c>PowerGrid</c> automatically registers itself to <see cref="T:Eco.Gameplay.PowerGrids.PowerGridManager" /> when it is constructed. To de-register the <c>PowerGrid</c>, use the <see cref="M:Eco.Gameplay.PowerGrids.PowerGrid.Cleanup" /> function.
            Internally, the <see cref="T:Eco.Gameplay.Components.PowerGridComponent" />s are stored as an undirected graph in adjacency set representation.
            <see cref="T:Eco.Gameplay.PowerGrids.PowerGrid" />s are not stored. They are re-constructed every time the server loads the world.
            </remarks>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGrid.Tick">
            <summary>Tick the power grid, update the stored power supply and demand. All power grids tick in parallel, so no race conditions allowed here.</summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGrid.Join(Eco.Gameplay.Components.PowerGridComponent,Eco.Gameplay.Components.PowerGridComponent)">
            <summary>Add <paramref name="current" /> to <paramref name="target" />'s power grid and mark them as connected.</summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGrid.DisconnectAndSplit(Eco.Gameplay.Components.PowerGridComponent)">
            <summary>Remove a component from the power grid. Detect whether removing the component breaks the connected-ness of the power grid connection graph. If that is the case, split this power grid into multiple grids based on connected components.</summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGrid.FloodFill(Eco.Gameplay.Components.PowerGridComponent,System.Collections.Generic.HashSet{Eco.Gameplay.Components.PowerGridComponent})">
            <summary>
            A modified BFS flood fill algorithm designed for the <see cref="M:Eco.Gameplay.PowerGrids.PowerGrid.DisconnectAndSplit(Eco.Gameplay.Components.PowerGridComponent)" /> function.
            As the graph is being explored, those nodes are removed from unclaimedRoots. If at any point unclaimedRoots becomes empty, the flood fill returns immediately.
            That is an optimization to speed up a common case where, when removing a component that's close to many other components, the power grid would not split.
            In that case, a BFS would quickly identify that is the case and return early without having to explore the entire graph.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGrid.Cleanup">
            <summary>Clears internal storage and removes this power grid from <see cref="T:Eco.Gameplay.PowerGrids.PowerGridManager" />, which will stop ticking this power grid. Call this function when the power grid should be destroyed.</summary>
        </member>
        <member name="T:Eco.Gameplay.PowerGrids.PowerGridManager">
            <summary>A central manager for all power grids. It is responsible for handling changes in power grid structure and for ticking all power grids.</summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGridManager.ProcessPowerGridChanges">
            <summary>Process all queued power grid component changes. Changes are processed sequentially to avoid race conditions.</summary>
        </member>
        <member name="M:Eco.Gameplay.PowerGrids.PowerGridManager.GetSleepTime">
            <summary>Calculate the amount of time (in ms) to sleep between ticks. Sleep time is calculated so that this manager uses approximately 5% of cpu, and clamped between 1000ms and 5000ms to ensure consistent updates.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.PositionNeighborsDeed(Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos)">
            <summary>Check if the given plot pos neighbors any plot on this deed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.CheckCanRemovePlotAndNotify(Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos,Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos})">
            <summary>Check whether we can remove that plot from this deed or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.CheckDeedIsContiguousAndNotify(Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos},Eco.Shared.Localization.LocString)">
            <summary>We check whether by removing or adding the specified plots the deed stay contiguous or become split.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.GetContiguousPartsWithAlterations(Eco.Gameplay.Property.Deed,System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos})">
            <summary>
            Gets all contiguous parts for deed after adding to it to Add plots and removing toRemove
            It's used to show dialog about changes (remove some deed will create N deeds by example) and to split deed to subdeeds if needed
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.ClaimWithConfirmation(Eco.Gameplay.Players.User,Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos,Eco.Shared.Localization.LocString,Eco.Gameplay.Items.ItemStack)">
            <summary> Claims a deed after user confirmation via ConfirmBox </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.DeedOwnedByAbandonedPlayer(Eco.Gameplay.Property.Deed)">
            <summary>If all the owners are abandoned then this deed is considered abandoned also.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.PropertyValue">
            <summary>The value of this deed, based on its type.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.CachedAssignedSettlementOfStake">
            <summary>Return the settlement influencing this position, by looking at the components on the stake. Can be a settlement stake, a foundation, or a homestead stake.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.BlockChildInfluence">
            <summary>True if claimed land on this plot is locked to the settlement assigned only.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.UpdateInfluencingSettlement">
            <summary>Update what settlement is associated with this deed. This can change when a homemstead component changes allegiances.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.IsHomesteadDeed">
            <summary>Is this deed claimed via a homestead claim stake?</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.ChangeHostObject(Eco.Gameplay.Objects.WorldObject)">
            <summary>Sets the host object, the placed claim stake or foundation that allows the deed to claim property.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.SetDeedPropertyType(Eco.Gameplay.Players.Player,Eco.Shared.Items.PropertyType)">
            <summary>Verify property change is valid and apply it if so, or inform user why not if not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.ForceDeedPropertyType(Eco.Shared.Items.PropertyType)">
            <summary>Force changing the property type, clearing residents as needed.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.RelevantUsers">
            <summary> Residents and owners </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.UpdateCenterPos">
            <summary>Update our cached center position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.ForceChangeOwners(Eco.Gameplay.Aliases.IAlias)">
            <summary>Changes owner of the deed without any checks.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.TryChangeOwners(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Aliases.IAlias,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Perform related checks and pass the changing action through the action manager.</summary>
            <param name="pack">A game action pack to use.</param>
            <param name="changer">The one who will be 'Citizen' in all the checks and child actions.</param>
            <param name="newOwner">New owner of the deed.</param>
            <param name="transferAction">Is it needed to trigger a PropertyTransfer game action.</param>
            <param name="autoPerform">Is it needed to invoke pack.TryPerform() within this method.</param>
            <param name="okBox"></param>
            <param name="superAccess">There will be no check whether the changer has access to the property. Currently used for sales in the real estate desk.</param>
            <returns>Returns either result of CanChangeOwner chek or the result of the pack.TryPerform() invokation.</returns>
        </member>
        <member name="M:Eco.Gameplay.Property.DeedFactory.CreateDeed(Eco.Gameplay.Players.User,System.String,Eco.Shared.Items.PropertyType)">
            <summary>Creates a new deed with the specified User as the owner and creator.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.DeedFactory.CreateDeed(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Players.User,System.String,Eco.Shared.Items.PropertyType)">
            <summary>Creates a new deed with the specified IAlias as owner and User as creator.
            The owner should never be null, in case the owner is null, the deed will remain unowned and also the name of the deed will be default (e.g.: Deed 1), unless the deedName is set.
            If the owner is setted then it would be forced to be the owner of the deed and it would take its name as reference to create a deed name (e.g.: Playertropolis).
            The creator is the first user that made the deed, also in case of changing the owner, the creator does not retain any rights in the deed, only the title as the creator.</summary>
        </member>
        <member name="T:Eco.Gameplay.Property.IOwnableHandle">
            <summary> A reference to an object which can be owned by a deed.  The deed must be able
            to serialize this without duplicating the object. </summary>
        </member>
        <member name="T:Eco.Gameplay.Property.IDeedOwned">
            <summary>
            An object which can be owned by a deed.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyCommands.TargetOwner(Eco.Gameplay.Players.User,Eco.Shared.Networking.INetObject,Eco.Gameplay.Players.User)">
            <summary> own the target world object's deed, if it has credit component update it to avoid its closure. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyCommands.ChangeWorldObjectCreditOwnershipToTargetUser(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.User)">
            <summary> Update Credit component for the target user to give access directly to it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyExtensions.PlotPosToOwnableHandles(System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos})">
            <summary> Converts provided plot pos vectors to OwnableHandles for deed operations.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyUtils.ForceClaim(Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,Eco.Shared.Math.Rect)">
            <summary>Force all the plots under the given rect in world space to be claimed, on the given settlement if set. Handles wrapping.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyUtils.GetUnclaimedPlotWorldPosNearUser(Eco.Gameplay.Players.User)">
            <summary>Find a plot thats not yet claimed starting from the given user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyUtils.GetUnclaimedPlotWorldPos(Eco.Shared.Voxel.PlotPos)">
            <summary>Find a plot thats not yet claimed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyUtils.GetUnclaimedPlotPos(Eco.Shared.Voxel.PlotPos)">
            <summary>Find a plot thats not yet claimed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyUtils.GetNeighboringPlotCount(System.Collections.Generic.HashSet{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.HashSet{Eco.Shared.Voxel.PlotPos})">
            <summary>Given a list of plots, return how many of the neighboring spaces are occupied by a plot from 'neighborPlots' as 'Count', and return the total number of
            neighboring plots as 'Total'.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.AllOwnedDeeds(Eco.Gameplay.Players.User)">
            <summary>All deeds who have the specified user as part of the owners. This is a slow operation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.AllDeedsOwnerIs(Eco.Gameplay.Aliases.IAlias)">
            <summary>All deeds that are specifically owned by the specified alias. This is a slow operation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.RemoveDeed(Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,System.Boolean)">
            <summary>This removes the deed, when force parameter is true it forces the process avoiding prompts and laws.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.MakePropertyClaimNotification(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final claim or unclaim notification</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlotHandle.PlotPos">
            <summary>NOTE: This is the position in WORLD SPACE, not plot grid</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.PlotPos">
            <summary>This is the position in PLOT-GRID, not world space</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.CenterWorldPos">
            <summary>Shortcut for <code>Eco.World.World.GetTopGroundPos(this.PlotPos.CenterWorldPos)</code></summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.CornerWorldPos">
            <summary>Shortcut for <code>Eco.World.World.GetTopGroundPos(this.PlotPos.CornerWorldPos)</code></summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.TryDestroy(Eco.Gameplay.GameActions.GameActionPack,Eco.Shared.Items.ResidencyChangeReason)">
            <summary> Attempts to destroy the Residency objects. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.UpdateResidentsForRooms(Eco.Core.Utils.ThreadSafeAction{Eco.Gameplay.Rooms.Room,Eco.Gameplay.Players.User},Eco.Gameplay.Players.User)">
            <summary>Invoke a resident update for every room in this residence.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.GetResidencyHouse(Eco.Gameplay.Players.User)">
            <summary> Returns any deed rented by user, which have any plot. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.CanBecomeResident(Eco.Gameplay.Players.User)">
            <summary>Sets visibility of the accept-invite button.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.BecomeResident(Eco.Gameplay.Players.Player)">
            <summary>RPC version of BecomeResident method. May require confirmation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.BecomeResidentOfOwnResidency(Eco.Gameplay.Players.User,Eco.Shared.Items.ResidencyChangeReason)">
            <summary>Simplified version of become resident method which doesn't ask any confirmation and usually initiated by automated workflows (i.e. first deed creation, deed removal etc).</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.BecomeResidentInternal(Eco.Gameplay.Players.User,Eco.Shared.Items.ResidencyChangeReason,Eco.Gameplay.Property.RentForProperty.FeeInfo)">
            <summary>Internal version of BecomeResident function which works without user confirmation. Still may fail.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.TryRemoveAllResidents(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Property.Deed,Eco.Shared.Items.ResidencyChangeReason)">
            <summary> Adds actions to remove all residents, this doesn't process the pack </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ResidencyExtensions.IsResidentType(Eco.Gameplay.Players.User,Eco.Shared.Items.SpecialResidents,System.Collections.Generic.IEnumerable{Eco.Gameplay.Property.Deed})">
            <summary>
            Check if a user belongs to a resident type (resident, renter, landlord, owner or invited)
            owner: someone who owns the property
            landlord: an owner + has non-owning residents
            resident: a person who is a resident on  the property
            renter: a person who is a resident and not an owner
            Owner or Landlord can't be renter or invitee
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.RoomChecker.CheckSolidAxis(Eco.Shared.Math.DirectionAxisFlags,Eco.Shared.Math.Axis,System.Nullable{Eco.Shared.Math.DirectionAxis}@)">
            <summary>
            Checks if for specified axis both edges are solid.
            If one of edges isn't solid then it will save it in openDir.
            If openDir already set then it will return false, because only one dir may be opened.
            </summary>
            <param name="solidEdges"></param>
            <param name="axis"></param>
            <param name="openDir"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Property.RoomChecker.TryGetWindowAxis(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Axis@)">
            <summary>
            Tries to get window axis for specified pos. It also checks if current pos is window.
            </summary>
            <param name="pos"></param>
            <param name="windowAxis"></param>
            <returns></returns>
        </member>
        <member name="T:Eco.Gameplay.Property.RequireOwnedRoomAttribute">
            <summary>For objects that need to be on a fully owned room to function</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.QueueRoomTest(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Queue up this position to be checked against all Rooms to determine if a Room has changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.QueueRoomValueRecalculation(System.Int32)">
            <summary> Queue up this RoomID to recalculate the relevant Room's RoomValue. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.GetEnclosedRoomForWorldObject(Eco.Gameplay.Objects.WorldObject)">
            <summary>Returns the room only if all the blocks of the World Object are inside the same room.
            If not all the blocks are in the same room or no room was found returns <see cref="P:Eco.Gameplay.Rooms.RoomData.GlobalRoom" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.GetEmptySpace(Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User)">
            <summary> Search for an empty space that fits a rectangle with a given size, use user position as initial position. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.GetEmptySpace(Eco.Shared.Math.Vector3i,Eco.Shared.Math.WrappedPosition3i)">
            <summary> Search for an empty space that fits a rectangle with a given size, use given position as initial position. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.Update(Eco.Core.Utils.ThreadSafeList{Eco.Gameplay.Rooms.Room},Eco.Core.Utils.ThreadSafeDictionary{Eco.Shared.Math.WrappedWorldPosition3i,Eco.Gameplay.Rooms.Room},System.Collections.Generic.IEnumerable{Eco.Shared.Math.WrappedWorldPosition3i},System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> Update rooms to reflect the actual blocks. Adds to the passed list and sets up world objects.</summary>
            <param name="rooms">Full list of rooms, which is added to.</param>
            <param name="posToRooms">Mapping from positions to rooms</param>
            <param name="positions">Positions that we need to check for updates</param>
            <returns>The changes that occurred during the update: new, changed, and removed rooms.</returns>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.UpdateValueOnly(System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> A more limited update that simply builds the room values, keeping the existing room stats on each room. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.UpdateRoomValuesAndFlagDeed(System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> Updates the RoomValues of specific rooms and informs the associated Deed to update as necessary. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.ProcessChanges">
            <summary>Process all room changes (added, changed, removed).</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.AttachContainedWorldObjects(Eco.Gameplay.Rooms.Room)">
            <summary>Attaches all contained world objects to the room and removes them from detached.</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.DetachNotContainedWorldObjects">
            <summary>Detaches all not contained world objects from their rooms and moves them to GlobalRoom.</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.TestChanges(System.Collections.Generic.IEnumerable{Eco.Shared.Math.WrappedWorldPosition3i})">
            <summary>
            Two step algorithm. First - recollect all possible positions, where it may modify somehow room. 
            After that - delete rooms in these positions and try create rooms there again (it won't create room where it was already added)
            </summary>
            <param name="positions"></param>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Annexation.AnnexationManager">
            <summary>Maintains a list of all the settlements that can annex another or are in progress of it (so they can get advance warning)</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Annexation.AnnexationManager.DoAnnex(Eco.Gameplay.Players.User,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.IAnnexable,System.Boolean)">
            <summary>Perform an annex of target settlement into source settlement. If user set, verify they are the leader.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Annexation.AnnexationManager.AnnexLesserType(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Annex a type lesser than ours (like a country annexing a town) and return result.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Annexation.AnnexationManager.AnnexSameType(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Annex same type (like a town annexing another town) and return result.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Annexation.AnnexationRecord">
            <summary>Stores a record of every settlement that can annex another, or its progress towards that.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.ClaimStakeObject">
            <summary> claim stake objects can have a selectable parent town.</summary>  
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.ClaimStakeItem">
            <summary>A claim stake allows claiming plots contiguous with the stake.  This version is for non-settlement usages.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.HomesteadClaimStakeObject">
            <summary>homestead claim stake objects can have a selectable parent town.</summary>  
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.HomesteadClaimStakeItem">
            <summary>A claim stake allows claiming plots contiguous with the stake.  A homestead claim stake allows choosing which town settlement parents you.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.Internal.ClaimStakeItemBase">
            <summary>Defines common features for attempting to place claim stakes.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.Internal.ClaimStakeObjectBase">
            <summary>The object that claims a plot and allows the claiming of more plots (using a deed map) based on the number
            of claim-papers that are attached.  Plots must be contiguous to the claim stake.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.SettlementClaimStakeObject">
            <summary>Settlement claim stake objects are linked to a single settlement.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakes.SettlementClaimStakeItem">
            <summary>A settlement claim stake item is different than a homestead one in that it is locked to a given settlement permanently.
            Also will make the store match them to the required settlement in the config options, so you can buy/sell and maintain the settlement associated.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.ClaimStakes.SettlementClaimStakeItem.Settlement">
            <summary>The settlement that generaed the claim stake</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimToolBaseItem">
             <summary>
            The ClaimToolBaseItem serves as a representation of the 'Claim Tool' object.
            It contains the actions performed to expand, or remove plots from selected deed/property.
             </summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.ClaimToolBaseItem.UnlimitedClaiming">
            <summary>If this is set, allow it to claim without papers.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.ClaimToolBaseItem.OnUsed(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.ItemStack)">
            <summary>Allow changing assigned deed when right-clicked.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Components.CitizenRosterComponent">
            <summary>Main component for interacting with the list of citizens on a town settlement.  Allows inviting and applying through the roster.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Components.HomesteadFoundationComponent">
            <summary>Component that lets a homestead claim stake notify the owner when towns become in range, and displays data about the town its associated to. Personal claimstake can only
            be part of the town youre a citizen of. </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.HomesteadFoundationComponent.Eco#Gameplay#Settlements#Components#IClaimStakeComponent#DeedChanged">
            <summary>Must be called by the placing thing after the deed is all setup.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Components.Internal.SettlementReqs">
            <summary>Lil helper for monitoring culture requirements of a settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.Internal.SettlementReqs.MinSettlementsRequired(Eco.Shared.Items.SettlementType,System.Boolean)">
            <summary>Determines sub-settlement requirements based on founded status of a settlement type.</summary>
            Subtract one from type index because we dont specify for towns, which can't have child settlements.
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.Internal.SettlementReqs.MinCitizensRequired(Eco.Shared.Items.SettlementType,System.Boolean)">
            <summary>Determines settlement citisen requirements based on founded status of a settlement type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Components.SettlementClaimStakeComponent">
            <summary>A component for claim stakes that can specify a settlement as their parent.  Not used for settlements being parented to other settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.SettlementClaimStakeComponent.Eco#Gameplay#Settlements#Components#IClaimStakeComponent#DeedChanged">
            <summary>Must be called by the placing thing after the deed is all setup.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.SettlementClaimStakeComponent.StakeOwnerUpdated">
            <summary>Update the settlement that owns this stake.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.SettlementClaimStakeComponent.SetInfluencingSettlement(Eco.Gameplay.Settlements.Settlement)">
            <summary>We update the lowest influencing settlement by also making sure to notify the settlement that's influencing it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Components.SettlementFoundationComponent.DoFounding(Eco.Gameplay.Civics.Elections.Election)">
            <summary>Helper that forces founding of the settlement. Called directly when founding via ratification. 
            Takes an optional param for an election that founded it, stored for posterity.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Components.SettlementRosterComponent">
            <summary>Allows display of member settlements, applicants, etc.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.CrisisClaimsManager">
            <summary>Standalone manager that flags citizens to stop contributing claims after leaving a settlement and putting it into crisis. </summary>
            <remarks>Once the crisis is resolved, this manager will make sure the settlements gain the claims they deserve.                    </remarks>
        </member>
        <member name="M:Eco.Gameplay.Settlements.CrisisClaimsManager.CanProvideClaims(Eco.Gameplay.Players.User)">
            <summary> A user cannot provide claims if their previous settlement is currently in crisis. </summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Culture.CultureManager">
            <summary>Manages various tracking of culture.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Culture.CultureManager.CultureCreatingUserCount">
            <summary>Returns how many users have produced &gt; 0 culture.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Culture.CultureManager.GlobalCultureOfCreatedWorks">
            <summary>Global culture sum for *actual* cultural values (ie, the settlement reduction is applied in the sum for artwork)</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Culture.CultureManager.CitizenCultureRanksText">
            <summary>Shows the ranks of all culture creating citizens.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Culture.CultureManager.CulturalWorksRanksText">
            <summary>Displays all the top cultural works generating culture.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Culture.CultureManager.DescribeCultureCreated(Eco.Gameplay.Players.User)">
            <summary>Describes the total culture and number of works a user has made with a link to the full list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Culture.CultureManager.DescribeCulturalRank(Eco.Gameplay.Players.User)">
            <summary>Describes the rank of the user with a foldout going to the full list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Culture.CultureManager.DescribeAllCulture">
            <summary>Makes a nice summary for all the culture in the world.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.IAnnexable">
            <summary>Something that can be annexed (settlement or homestead deed)</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.IAnnexable.HasAncestor(Eco.Gameplay.Settlements.Settlement)">
            <summary>True if the given settlement is a parent anywhere up the hierarchy</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.AnnexationRecordBuilder.RecalcAnnexRecords(System.Collections.Generic.IEnumerable{Eco.Gameplay.Settlements.Settlement})">
            <summary>Update ability of all settlements to annex another, ooking only at given settlements. Null means check all.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.AnnexationRecordBuilder.DirtyTargets(System.Collections.Generic.IEnumerable{Eco.Gameplay.Settlements.Settlement})">
            <summary>Update all the targets of the settlements that were already dirtied.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.AnnexationRecordBuilder.CalcRecord(Eco.Gameplay.Settlements.Annexation.AnnexationRecord,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.IAnnexable)">
            <summary>Evaluate how close one settlement is to annexing another and return the result.  Takes an existing record to update, and creates a new one if null is passed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.AnnexationRecordBuilder.SendNoticesIfNeeded(System.Boolean,System.Single,Eco.Gameplay.Settlements.Annexation.AnnexationRecord)">
            <summary>If it's getting closer to being able to annex, let them know.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.CultureGeneratingDeedsBuilder">
            <summary>Determines which deeds should generate culture in a settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.InfluenceBuilder.SetInfluencedPlotsForSettlements(System.Collections.Generic.IEnumerable{Eco.Gameplay.Settlements.Settlement},Eco.Shared.Utils.Array2D{System.Int32})">
            <summary>Mark the given settlements for their influenced plots</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementBuilders.InfluenceBuilder.GetSettlementAccordingToInfluencePointsOnlyAtPos(Eco.Shared.Voxel.PlotPos,System.Nullable{Eco.Shared.Items.SettlementType},Eco.Gameplay.InfluenceObjects.Influence[])">
            <summary>Gets the point influencing the given position, considering only the influence points, not anything else like assigned settlement on stakes, which can affect it otherwise.
            Influence points to consider can be injected, or if null, use the settlement's.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementChangeDetector.ForceUpdateAll">
            <summary>Set everything to update next tick, and make the tick happen right away.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.ChangeDetection.SettlementChangeDetector.HomesteadUpdated(Eco.Gameplay.Property.Deed)">
            <summary>We make sure to dirty all the settlements that have the specified deed as target so that we can update the annexation interface related to that deed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Internal.SettlementFoldoutBuilder">
            <summary>Handles making tooltips with RPC callbacks for filling in details for settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.SettlementFoldoutBuilder.GetStatusForSettlement(Eco.Shared.Math.Vector2i)">
            <summary>Returns status text to show details of the settlement for given position</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Internal.SettlementInfluence">
            <summary>Handles settlement influence for a given settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.SettlementInfluence.InfluencePoints">
            <summary>Calls getInfluenceSourceDeeds which resolves to <see cref="P:Eco.Gameplay.Settlements.Settlement.InfluenceSourceDeeds" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.SettlementInfluence.CouldInfluence(Eco.Shared.Voxel.PlotPos)">
            <summary>Return true if the influence could influence the given plot pos, if there wasnt other settlements/homesteads in the way.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Internal.SettlementInfluenceManager">
            <summary>Handles management of influence and related systems for all settlements.  Does all the watching and
            notifying that makes settlements update their influence.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Internal.SettlementInternalUtils">
            <summary>Utils meant to only be used by settlement system.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Internal.SettlementInternalUtils.InfluencesTouch(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.IAnnexable)">
            <summary>Check if any influence is neighboring a plot influenced by the other.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementComponent">
            <summary>Component that has some tracking for a settlement</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Settlement">
            <summary>A settlement defines 'influence' in the world upon which its government is applied and land can be claimed.
            It also maintains a list of citizens associated with the government, and polices for changing citizens.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.AssignedCulturalDeeds">
            <summary>The cultrual properties chosen on a diplomacy desk, foreced to be part of the set of influencing deeds.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.InfluenceSourceDeeds">
            <summary>The current cached list of influence source deeds, which can change when none are assigned. It uses all the assigned ones, then takes remaining ones in descending order to reach the max count.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.Settlement.WorldObjectsWithAssignedJurisdiction">
            <summary>Tracks all world objects that have a jurisdiction which is assigned to us.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.AllCurrentCivicArticlesCached">
            <summary>All the active articles, from both the constitution and any amendments that modify that list.  Will contain invalid articles too.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.TypeAndName">
            <summary>The type of settlement prepending the name. IE, "Town Johnkville"</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.UnfoundSettlement">
            <summary>Revert to unfounded, which happens when annexed into the same type of settlement.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.HasValidConstitution">
            <summary> Returns false when where is currently no active and valid constitution. </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.IsSettlementCoreProposable(Eco.Gameplay.Civics.Misc.IProposable)">
            <summary>Returns true if the given proposable is one our special ones listed above.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.GetCoreProposable(System.Type)">
            <summary>Provides any of the built-in proposables the settlement makes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.GetCoreSettlementParts">
            <summary>Itrerates through the linked parts of the settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.ClearCoreProposables">
            <summary>Remove all references to the core proposables, as in cases of annexing where we dont want them to get updated.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.Influences(Eco.Shared.Math.Vector2i)">
            <summary>Returns true if the settlement influences the given position.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementCachedData">
            <summary>Tracks various properties of settlements needed for different things, and keeps them updated.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementCachedData.CultureDescription">
            <summary>Cached sum of all culture values on all deeds of the settlement</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementCachedData.AnnexationRecords">
            <summary>Records of annexation where this settlement is the source or target.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementCachedData.Deeds">
            <summary>Cached list of deeds associated with this settlement</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCachedData.AnnexationRecordsUpdated">
            <summary>Called by annexation builder when the enumerable may have changed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementCitizenship">
            <summary>Tracks the citizens of a settlement using a Roster type, so new citizens can apply/be invited/accepted/etc.</summary>
            <remarks>Also tracks the number of claims and stakes that get spawned as population increases.                      </remarks>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCitizenship.Initialize(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Civics.Demographics.Demographic)">
            <summary>Setup citizenship management for a settlement</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCitizenship.CheckAllowUserWithHomesteadFromLeaving(Eco.Gameplay.Players.User,System.Boolean)">
            <summary>We check whether the specified user has a homestead placed and if so prevent him from leaving.</summary>
            <param name="isJoiningAnotherSettlement">Is this user leaving a settlement to join another or not ? When the user is leaving a settlement to join another 
            we would check whether his homestead in the radius of influence of that settlement to know whether to let him do that or not.</param>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCitizenship.QueueCitizensCacheUpdate">
            <summary>Event to update our citizens in any roster, as well as citizens in our children settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCivicActionsUtils.CanInviteOrApply(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement,System.Boolean)">
            <summary>Check for settlement joining/inviting validity</summary>
            <remarks>`inviting` boolean is to determine we are inviting or applying to the target settlement</remarks>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementCommon">
            <summary>Common stuff shared by various parts of the settlement system.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.SettlementConfig.LeaderNames">
            <summary>Randoms names for leaders, by settlement type.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.SettlementConfig.DefaultSuffixes">
            <summary>These names will be appended when starting a town.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementConfig.CultureToInfluenceRadiusMapper">
            <summary>Formula that determines the influence radius given the culture.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.SettlementConfig.CultureToInfluenceMappingPerSettlementType">
            <summary>This is linked here so that it can be displayed in the ecopedia details, but its not used directly, the mapper above is called.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.SettlementConfig.InventorySourceForAnnexationCosts">
            <summary>This type of object associated with a settlement is queried for inventory to perform an annexation.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementDebug">
            <summary>Various debug flags concenting settlements that are typically enabled via chat commands.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementFactory">
            <summary>Creating and destroying settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementFactory.CreateSettlement(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.User,Eco.Shared.Items.SettlementType,Eco.Gameplay.Civics.Constitution,Eco.Gameplay.Civics.Demographics.Demographic,Eco.Gameplay.Civics.ElectionProcess,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>Create a brand new settlement and fill it in, and create extra parts like leaders and immigration.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementFoundationItem`1">
            <summary>Base class for items that claim a settlement. Contains functions for defining how property can be claimed
            without overlapping with existing settlements or other plots.  Manages the display of that available land on the client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementFoundationObject">
            <summary>Base class for objects that define a new settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.PositionIsInsideFoundedOrUnfoundedSettlement(Eco.Gameplay.Settlements.Settlement,Eco.Shared.Voxel.PlotPos)">
            <summary>Test if a position is considered 'inside' a settlement's influence, where with an unfounded settlement we
            consider the position once the base influence is cast.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.CoversPercentageOfPlots(Eco.Gameplay.Settlements.Settlement,System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos},System.Single,System.Single@)">
            <summary>Check if a percentage of Plots are within the radius of our settlement's influence.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.PositionIsInsideUnfoundedSettlement(Eco.Gameplay.Settlements.Settlement,Eco.Shared.Math.Vector2i)">
            <summary>We check whether the specified position is inside the unfounded settlement or not. If the settlement was already founded, then this will always return true.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.CouldOrWillInfluence(Eco.Gameplay.Settlements.Settlement,Eco.Shared.Math.Vector2i)">
            <summary></summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.InfluenceRangeOverlap(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Simple check if influences of settlements overlap</summary>
            <remarks>Returns true if distance between settlements is less than sum of their influence radii</remarks>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementInfluenceUtils.MinCoverageDescription(Eco.Gameplay.Settlements.Settlement)">
            <summary>Returns a LocString describing required influence coverage of plots</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ISettlementAssociated">
            <summary>For items and other types that have an associated settlement. Allows using inventory restrictions that limit to a specific settlement (like claim stakes that can only
            hold claim papers from a specific settlement)</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementManager">
            <summary>Handles settlement creation and tracking, mapping their influence as well.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementManager.GetInfluenceAccordingToInfluencePointsOnlyAtPos(Eco.Shared.Voxel.PlotPos,System.Nullable{Eco.Shared.Items.SettlementType},Eco.Gameplay.InfluenceObjects.Influence[])">
            <summary>Gets the point influencing the given position, considering only the influence points, not anything else like assigned settlement on stakes, which can affect it otherwise.
            Passed null means take lowest.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementParentage">
            <summary>Class that determines the parent settlement for another settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.GetSettlementAtHigherLevel(Eco.Shared.Items.SettlementType)">
            <summary>Returns this settlement if the type matches us, otherwise if its a higher type it passes it
            too our parent to check.  If its lower type, it return null.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.HasAncestor(Eco.Gameplay.Settlements.Settlement)">
            <summary>True if ourself or any parent up the hierarchy matches the given settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.Lineage">
            <summary>Return enumerable of this settlement, then each parent in order.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.LineageName(System.Boolean)">
            <summary>Describe the parents of this settlement and this settlement itself in a single string.  Can do via commas or new lines.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.ParentSettlementUpdated">
            <summary>When the parent settlement changes, all the children parent settlement needs also to be marked as changed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementProperty">
            <summary>Component to Settlement that handles spawning/despawning stakes and claims as citizens come and go.  
            Handles property crises when not enough citizens for property.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementProperty.StakesInfluencedBySettlement">
            <summary>These are all the stakes used by this settlement (all the stakes currently influenced by this settlement).</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.SettlementParentChanged(System.Object,Eco.Core.PropertyHandling.MemberChangedBeforeAfterEventArgs)">
            <summary>Get called whenever this settlement parent changes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.UpdateStakesAndClaims(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User})">
            <summary>This version of UpdateStakesAndClaims is only used to subscribe to abandoned demographic when the users changes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.ClaimAndStakeInventoryChanged">
            <summary>Called by our holder object to let us know the inventory holding the claims and stakes has recently changed.  We only care if there's a property crisis, though,
            because there might be stakes/claims we need to despawn.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.RegisterExternalClaimSpawns(System.Int32,System.Int32)">
            <summary>Some things can spawn claim stakes outside our normal processes, like annexing a settlement.  This will increment the stakes and claims, perhaps even past the maximum, which may invoke a crisis/</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.BuildCrisisNotice(Eco.Shared.Localization.LocString)">
            <summary>Creates a crisis notice for the current time. 
            <paramref name="destinationDesc" />A description of where to return the stakes and claims.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.RemoveSurplusStakes(System.Collections.Generic.List{System.Object})">
            <summary>We remove the surplus of stakes from the specified list (depended on stakes delta).</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.RemoveSurplusPapers(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.ItemStack})">
            <summary>We remove the surplus of papers from the specified list in way where all deeds lose some of their claims with the quantity depending on how many papers those deeds are using.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.RemoveItems(System.Collections.Generic.List{Eco.Gameplay.Items.ItemStack},System.Int32,Eco.Shared.Localization.LocStringBuilder)">
            <summary>Remove items from a list of them, writing out what we do.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.RemoveItem(Eco.Gameplay.Items.ItemStack,System.Int32,Eco.Shared.Localization.LocStringBuilder)">
            <summary>Remove From a stack the wanted quantity.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementPropertyUtils.ShouldAllowClaim(Eco.Gameplay.Players.User,Eco.Gameplay.Settlements.Settlement,Eco.Shared.Voxel.PlotPos)">
            <summary>Look at all immigration policies on settlements at the given location and see if youre allowed to claim land here.</summary>
            <param name="associatedSettlement">this is set if claiming on a claim stake that is associated to a particular settlement.</param>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementRoster">
            <summary>A list of settlements that can only be changed with mutual civic actions. Used for deciding parentage of settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementRoster.TryRemove(Eco.Gameplay.Settlements.Settlement,System.Boolean)">
            <param name="ignoreParents">
            If this is set to false then we will check whether the parent settlements allow child settlements to secede and if not, the specified settlement
            will instead be joing one of the parents as a direct child when it leaves its current parent.
            </param>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementSpawner">
            <summary>Spawns settlements with a variety of user decided options. Will become a source for a scenario spawner someday.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementSpawnHelper">
            <summary> Helper class that precalculates and contains spawn data when spawning settlements. </summary>
            <remarks> It exists to reduce math calculations and hold all size logic, so spawning code can stay clean and on-point. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementSpawnHelper.GetSettingsForChildSettlement(System.Int32)">
            <summary>Quick access to child count, child size, and the amount of columns for children. </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.CheckAnnexationTimer(Eco.Gameplay.Settlements.Settlement,Eco.Shared.Localization.LocString)">
            <summary>See if there's an active annexation clock on this settlement preventing stuff.s</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.SelfOrParent(Eco.Gameplay.Settlements.Settlement,Eco.Shared.Items.SettlementType)">
            <summary>Return the settlement of the given type, examining parents if it's not our type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.SelfAndParents(Eco.Gameplay.Settlements.Settlement)">
            <summary>Return the passed settlement, then its parent, etc recursively.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.AllParents(Eco.Gameplay.Settlements.Settlement)">
            <summary>We get all the parents of the specified settlement (we don't return the settlement itself).</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.TopParent(Eco.Gameplay.Settlements.Settlement)">
            <summary>We get the top parent of this settlement or else we return the settlement itself.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.GetSettlementAtPos(Eco.Shared.Items.SettlementType,Eco.Shared.Math.Vector2i)">
            <summary>Return the settlement of the given type at the given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.GetLowestLevelSettlementAtPos(Eco.Shared.Math.Vector2i)">
            <summary>Return the settlement of the lowest type (town before country before federation) at the given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.InfluencesAtLevel(Eco.Shared.Items.SettlementType)">
            <summary>Iterators of the influence points at a given level of settlement..</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.GetSettlementsAtPos(System.Nullable{Eco.Shared.Math.Vector3i})">
            <summary>Return the settlements currently influencing the given position, in order of the enum</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.GetSettlementsAtPos(Eco.Shared.Voxel.PlotPos)">
            <summary>Return the settlements currently influencing the given position, in order of the enum</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.HasParentOrSelf(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Returns true if the given settlement is the same.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.HasChildOrSelf(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Returns true if the given settlement is contained as a child settlement of this one, or if it *is* this one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.NotifyLoc(Eco.Gameplay.Settlements.Settlement,System.FormattableString)">
            <summary>Send a message to all citizens.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.AllTypes">
            <summary>Returns all the settlement types available.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.ForAllTypes(System.Action{Eco.Shared.Items.SettlementType})">
            <summary>Perform an action on all types of settlements.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.SettlementsOfType(Eco.Shared.Items.SettlementType)">
            <summary>Iterates through all settlements in existance of the given type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.DoClaimForSettlement(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Shared.Items.SettlementType,Eco.Gameplay.Items.WorldObjectItem)">
            <summary>Claim land in advance of placing a settlement foundation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.GetOrMakeTown(Eco.Gameplay.Players.User,Eco.Shared.Math.Vector2i)">
            <summary>Return the town influencing the given location, or make a new headless one that covers this location.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.SelfAndAllChildrenSettlementsRecursive(Eco.Gameplay.Settlements.Settlement)">
            <summary>Iterate through all children, and their children, etc, as well as the passed settlement itself.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.CanSecedeFromParents(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement@)">
            <summary>We check whether this settlement can secede and become independant or not.</summary>
            <param name="preventingSettlement">The lowest settlement that would prevent any seceding.</param>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.ReplaceClaimStake(Eco.Gameplay.Settlements.ClaimStakes.SettlementClaimStakeObject,Eco.Gameplay.Settlements.Settlement)">
            <summary>This will just change an already placed stake from a settlement to another (related deed will not change influencing settlement).</summary>
            <returns>Returns whether the claim stake was replaced or not.</returns>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.AllowOwnership(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Aliases.IAlias)">
            <summary>We check whether the specified alias is allowed to own some properties inside this settlement or not.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementUtils.AllowDeedInteraction(Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Property.Deed)">
            <summary>Check whether this settlement can interact with the specified deed or not (like performing laws on it).</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.Skill.InitializeSkills">
            <summary> Static skill initializer. </summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillCommands.SkillTypeByName(Eco.Gameplay.Players.User,System.String)">
            <summary>Find a skill type by any string</summary>
        </member>
        <member name="F:Eco.Gameplay.Skills.Skillset.UserSkillLevelChangedEvent">
            <summary> Raised when any skill of any user changes level </summary>
        </member>
        <member name="T:Eco.Gameplay.Skills.SkillTree">
            <summary>Helper class to send skill trees to client, skills are organized into trees based on reflection, with skills
                that have no required skills being root-level tree skills</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.DiscoveredBy">
            <summary>The user who Discovered the Skill.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.CachedSkillReqs">
            <summary>The requirements built from the tier.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.StaticSkill">
            <summary>The item in the global list of items representing the skill</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ProfessionChildren">
            <summary>The children of the skill tree in profession/speciality basis.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.RequiredSkillLevelsMap">
            <summary>The children of this skill based on its SkillBook ingredients. (research basis), The key is the child skill tree and the value is the level of the parent skill at which it can unlock at.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.PlayerCountAtEachLevel">
            <summary>Level for professions means 'how many specialties under that profession'. For specialties, means the level of the specialty.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.LevelToRecipeUnlocked">
            <summary>The map of recipes unlocked at each level.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.TreeResearchRank">
            <summary>Specifies the node depth for the research tree.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ResearchProject">
            <summary>The current active research project.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.IsUsingSkillBook">
            <summary> True if there are recipes available for the skill book. </summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ResearchWorkOrders">
            <summary>Current active workorders for the skill book that tech this skill.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.IngredientChildren">
            <summary>The collection of the skill tree children by its ingredients.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.BuildSkillTrees">
            <summary>Build the skill trees.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.SetUpIngredientChildren(System.Collections.Generic.IDictionary{System.Type,Eco.Gameplay.Skills.SkillTree})">
            <summary>Instantiate ingredient children for each skill tree. </summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.MakeNonTransitive(System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.RequiresSkillAttribute}})">
            <summary>Make the given dictionary of parents non transitive (i.e removes parents that repeat on a branch. </summary>
        </member>
        <member name="T:Eco.Gameplay.Skills.SkillTree.RequiresSkillAttributeEqualityComparer">
            <summary>Checks for Requires Skill Attribute Skill <see cref="T:System.Type" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.CheckForResearchAttributes(System.Type)">
            <summary>Get Required skills to obtain skillbooks for the given skill.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetRequiredSkillForItem(System.Type)">
            <summary>Get Required skills to obtain skillbooks for the given skill.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.BuildTreeList(System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.SkillTree},Eco.Gameplay.Items.SkillBook[],System.Collections.Concurrent.ConcurrentDictionary{System.Type,Eco.Gameplay.Skills.SkillTree},Eco.Gameplay.Skills.SkillsLookUp)">
            <summary>Iterates through the given set of data to build SkillTrees to the given SkillsLookup.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetDependentSkillsRecursive(System.Type,System.Collections.Generic.Dictionary{System.Type,Eco.Gameplay.Skills.RequiresSkillAttribute})">
            <summary>Gets the skill Types that depend on the given skill Type, directly or undirectly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetDependentSkills(System.Type,System.Collections.Generic.Dictionary{System.Type,Eco.Gameplay.Skills.RequiresSkillAttribute})">
            <summary>Gets the skill Types that directly depend on the given skill Type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetRequiredSkillsMap(System.Type,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.RequiresSkillAttribute}})">
            <summary>Get the skill type and at which level that skill depend on the given skill type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.Talent.OnLearned(Eco.Gameplay.Players.User)">
            <summary>
            This method called when talent just learned to apply modifications to existing objects (like reduce requirements, update statuses etc).
            </summary>
            <param name="user"></param>
        </member>
        <member name="M:Eco.Gameplay.Skills.Talent.RegisterTalent(Eco.Gameplay.Players.User)">
            <summary>
            This method called every time when talent added to user either when learned or deserialized.
            Use this method for callbacks registration.
            </summary>
            <param name="user"></param>
        </member>
        <member name="T:Eco.Gameplay.Skills.TalentManager">
            <summary>This manager is responsible for talent collection and also for talents versioning.
            If the version set in <see cref="F:Eco.Gameplay.Skills.TalentManager.DefaultVersion" /> is higher then <see cref="F:Eco.Gameplay.Skills.TalentManager.CurrentVersion" /> (which loads from serialized data)
            all talents for all users will be reset.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Chat.IChatClient">
            <summary>
            <para>
            The interface that something needs to implement in order to perform chat commands.
            Used by User and RCON currently. Chat commands can accept either a <seealso cref="T:Eco.Gameplay.Players.User" /> or an <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />
            </para>
            
            <para>
            Difference between using <seealso cref="T:Eco.Gameplay.Players.User" /> vs. <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> as the first argument include:
            <list type="bullet">
            <item><description>If they accept a <seealso cref="T:Eco.Gameplay.Players.User" />, they are allowed to have full access to that <seealso cref="T:Eco.Gameplay.Players.User" />'s interface, but those chat commands cant be called by headless clients like RCON</description></item>
            <item><description>If they accept an <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />, they have a limited set of properties (below) which they can access from the chatClient, but both Users in game and headless clients such as RCON can call these functions.</description></item>
            </list>
            </para>
            
            <para>Generally if you only need to issue return displays and make modifications to the world, you should make the chat command accept <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />, so headless clients like RCON can call it.</para>
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.Name">
            <summary> Represents the display name of this <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.MarkedUpName">
            <summary> Represents the markup display name of this <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.ImplementationName">
            <summary> Represents the internal name of this implementation. Used in things suchas error messages </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.GetChatAuthLevel">
            <summary>
            Returns this Invoker's <seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel" /> value for use in command permission checks
            </summary>
            <returns><seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel" /> if the Invoker</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.TempServerMessage(Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary>
            Sends a message to the command invoker that is intended to be temporary. This method may not be supported by all command invokers. If the method is not 
            supported these messages should be routed to a normal <seealso cref="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLocStr(System.String,Eco.Shared.Services.NotificationStyle)" /> message call.
            </summary>
            <param name="message">Message to send to the invoker from a chat command</param>
            <param name="category"><seealso cref="T:Eco.Shared.Services.NotificationCategory" />The chat tags associated with this message</param>
            <param name="style"><seealso cref="T:Eco.Shared.Services.NotificationStyle" /> of the message to be sent</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLoc(System.FormattableString,Eco.Shared.Services.NotificationStyle)">
            <summary>
            Sends a generic message to the command invoker from a chat command using the specified <seealso cref="T:Eco.Shared.Services.NotificationStyle" /> style to determine how to display it for
            invokers that support it.
            </summary>
            <param name="msg">Message to send to the invoker from a chat command</param>
            <param name="style"><seealso cref="T:Eco.Shared.Services.NotificationStyle" /> of the message to be sent</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.ErrorLoc(System.FormattableString)">
            <summary>Sends a error message to the command invoker from a chat command</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.OkBoxLoc(System.FormattableString)">
            <summary>Displays an ok box to the client (or just a string if its a console)</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.EnvVars.IHasEnvVars">
            <summary>Flags a class as having EnvVars.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.EnvVars.EnvVarAttribute">
            <summary>Put this on a property or method taking a User, which returns any serializable value.
            EnvVars (Environment Variables) are for high-voltaile, fast-update properties that are needed, like interaction tests.
            They are queried on demand, cached on the client, and the server notifies the client when the cache is invalidated
            (but unlike with Views, does not send an updated value, it waits till the next query).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.EnvVars.EnvVarManager.UserHasEnvVarsForObj(Eco.Gameplay.Players.User,Eco.Core.Controller.IController)">
            <summary>Check the cache to see if the given user is recorded as having cached the needed object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.EnvVars.EnvVarManager.GetEnvVarsSelfAndComponents(Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject)">
            <summary>Gets the env vars for the world object and all its components.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.FeatureConfig.IsFeatureOfTypeAvailable(System.Type)">
            <summary> Checks if the type has any related feature and returns true if all its related features are enabled. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.FeatureConfig.IsFeatureEnabled(System.String)">
            <summary> Checks if the given feature name is currently enabled. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.InitialSpawn.InitialSpawnPlugin">
            <summary>Plugin that owns data for the InitialSpawnManager, handling choices when players enter a world.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel">
            <summary>Channels are managed via <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager" />. Channel has a Manager/User permission set using Aliases, that allows creating rich and contextual communication hubs in game.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.OnChangeUsersOrManagersUserSet(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User})">
            <remarks>Prams only needed so that we can pass this method to <see cref="P:Eco.Gameplay.Aliases.IAlias.UserSetChangedEvent" />.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.GetLinkableName">
            <summary>Define a string that will be parsed as a link for the Channel, so we do not overlap custom names of channels and simple words or names of other objects.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.OnLinkClicked(Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Systems.NewTooltip.TooltipClickContext,Eco.Gameplay.Players.User)">
            <summary>Set this channel as a receiver (change output tag) with clicking on it's name in the Chat Log.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.SetChannelName(Eco.Gameplay.Players.Player,System.String)">
            <summary>Custom RPC needed for draft dialog title edit: cannot use SetName because it will cause Registrar entry rename - we don't want it while in draft mode</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.EditChannel(Eco.Gameplay.Players.Player)">
            <summary>Edit request by player, needed for Auto views setup</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager">
            <summary>Handles all global concerns of Channels: creation, editing, removal. Also initializes special/system channels. Is synced to each individual client via <see cref="P:Eco.Gameplay.Systems.GlobalData.Channels" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.CreateChannel(Eco.Gameplay.Players.Player)">
            <summary>Opens editor UI with a default (public) channel draft, that will be active and usable only after saving.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.EditChannel(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>Opens editor UI for the given channel.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.RemoveChannel(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>When player requests to remove channel (will check permissions and popup confirm dialog)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.RemoveChannel(Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>Remove channel and all associated chat messages</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.Get(Eco.Gameplay.Systems.Messaging.Chat.Channels.SpecialChannel)">
            <summary>Retrieves a special channel given it's type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.MakeDefaultChannel(System.String,Eco.Gameplay.Players.Player)">
            <summary>Sets up a default channel that can be used by everyone.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatDataPartition">
            <summary>Persistent Chat Data. May be used as stand-alone chat messages storage or as a partition of <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> (as used in <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.ChatManager" />).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatDataPartition.RemoveAll(System.Predicate{Eco.Gameplay.Systems.Messaging.Chat.ChatMessage})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.AddCommandHandler(System.Type)">
            <summary>Adds handler type. May be used for types which not auto-discovered by reflection (i.e. when some commands only available under specific conditions).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary>
            Execute a command string directly, from a <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> rather than a <seealso cref="T:Eco.Gameplay.Players.User" />. This allows only a subset of chat commands
            (those that accept <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instead of User as their first property). Does not require the beginning forward slash '/')
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.RemoveChannelReferencesFromChat(Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>
            Remove a specific channel, that was deleted from the game, from all the tabs that have it in their "Chat Sources"(the list of all the channels that can be displayed in that tab)
            and all associated chat messages
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.EscapeMessage(System.String)">
            <summary>Remove not allowed tags from the given string.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.RemoveMessages(System.Predicate{Eco.Gameplay.Systems.Messaging.Chat.ChatMessage})">
            <summary>Removes all messages matching <paramref name="predicate" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.TryResetChatSettings">
            <summary>Reset chat settings of all users to use the default. Mostly used for testing and playtest.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatMessage">
            <summary> Used in server/client side and for storage.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatMessage.ToBson(Eco.Shared.Networking.INetClient)">
            <summary>Not IBSONSerializable because takes INetClient arg to pack controllers</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.SanitizeChatInput(System.String)">
            <summary>Given a raw chat message, strips it from size tags and control characters.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.ResolveReceiver(System.String,System.String@)">
            <summary>Given a raw chat message, attempt to extract receiver and actual message part.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.FindChannelInChatMessage(System.String)">
            <summary>Given a raw chat message, looks up the first part before space to attempt to resolve a <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel" />.</summary>
            <remarks>Used exclusively by <see cref="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.ResolveReceiver(System.String,System.String@)" />.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.FindUserInChatMessage(System.String)">
            <summary>Will take the longest name that can be found at the beginning of a text line.
            E.g. Text: @test client 1 [some more text] we will take @test client 1 as a user chat tag, and @test will be skipped.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings">
            <summary>
            Client's chat settings are stored on the server within this class (instead of UserPrefs)
            Client can reorder tabs but can't add or remove tabs (using ChatManager's RPCs instead)
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.TryAddTab(Eco.Shared.Networking.INetObject)">
            <summary>Called when client requests adding via AddRPC call from ViewUIContainer - no traditional add allowed, instead draft dialog will be shows</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.AddTab(Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Requests client to open draft chat tab editor, tab will be added only if pressed Apply button</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.EditTab(Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Requests client to open draft chat tab editor.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.HideTab(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase)">
            <summary>Requests client to move the tab to the Hidden Tabs list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.InsertOrEditTab(Eco.Gameplay.Players.Player,System.Int32,System.Boolean)">
            <summary>Requests client to open draft chat tab editor. Can be new tab or existing tab</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.InsertTabAndSetActive(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase,System.Int32,System.Boolean,System.Boolean)">
            <param name="activateTab">Should we set the tab as active ?</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.OnRemove(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>If the tab removed was not the last one (generally there is always at least one tab), make the next tab active.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.EnsureTabExistsForReceiver(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.Boolean,System.Boolean)">
            <summary>Ensure we have a tab for IChatReceiver and if not - try to create this tab</summary>
            <param name="activateTab">Should we set the tab as active ?</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.CreateNotificationTab(Eco.Gameplay.Players.Player,Eco.Shared.Services.NotificationCategory)">
            <summary>Create a chat tab for notifications from  <param name="category">category</param></summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase">
            <summary>
            Chat tab represents current chat 'window' and user always has at least on active tab. Tab settings tells chat which message are visible within that tab.
            Settings for chat tabs are stored on server in ChatManager. Name should not be empty and can have collisions with other tabs. Tab names are not localized.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon">
            <summary>
            Represent the common tabs that are created manually by the player (or in some cases automatically) and that can be modified.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon.EditSystemSourcesSettings(Eco.Gameplay.Players.Player)">
            <summary>Opens multi-selector popup on client. This is needed to allow pick from general picker without using registrars</summary>
            NOTE: on the client UI we change notifications to systems to prevent any confusion with the <see cref="F:Eco.Shared.Services.NotificationCategory.Notifications" /> cetegory.
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon.Valid">
            <summary>Choose whether to make the submit button interactable or not depending on whether there's at least one channel or notification source.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsWhisper">
            <summary>Represent the private tabs that are created automatically when the whisperMode is active and the player send or receive a message from another player. Player cannot modify this tab.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.Messaging.Chat.Commands.AdminCommands.animalMovementTestSize">
            <summary>Each animal movement test takes place in enclosed area of this size.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.AdminCommands.SpawnDebugAnimalAtPos(Eco.Gameplay.Players.User,System.String,Eco.Shared.Math.Vector3i)">
            <summary>Spwans animal at specified position and sets it barin to debug mode, making it idle all the time, unlesss other states are forced by commands.</summary>
            <returns>Spawned animal or null if spawning failed.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.AdminCommands.MakeCutWall(Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>Make a wall that cuts into the landscape at the given height</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand">
            <summary> Class holding information about chat command (built from <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> and <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatSubCommandAttribute" />). </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.FullName">
            <summary> Returns fully qualified command name (including parent name if it is sub command). </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.Matches(System.String)">
            <summary> Checks if <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> matches searchString. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.WithLanguage(Eco.Shared.Localization.SupportedLanguage)">
            <summary> Returns <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> localized for <paramref name="language" />. It will only correctly work if original command is in English locale. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.LocalizeCommandName(System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary> Localizes command name. It applies some transformations to ensure command name is valid and properly formatted. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.CommandRequiresUser">
            <summary>Checks if this command requires a user object to be executed.</summary>
            <returns>True if the command requres a user</returns>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandHandlerAttribute">
            <summary>Marks a class as chat commands handler. Class with that attribute will be scanned for chat commands with <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> and <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatSubCommandAttribute" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService">
            <summary> Service responsible for <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> registration and processing.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetAllCommands">
            <summary> Returns all registered commands (including sub commands). </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetAllHeadlessCommands">
            <summary> Returns all registered commands (including sub commands) that can be used by a headless <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> such as RCON. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryParseAndIdentifyCommand(System.String@,Eco.Shared.Localization.SupportedLanguage,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>
            Tries to parse <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> from <paramref name="unparsed" /> string.
            It has following outputs:
            <list type="bullet">
            <item>if string is empty then <paramref name="chatCommand" /> is <c>null</c> and failed without message;</item>
            <item>if no matching command then <paramref name="chatCommand" /> is <c>null</c> and failed with message about unknown command, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command without sub commands then <paramref name="chatCommand" /> set to command and result is succeed, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and sub command name is empty then <paramref name="chatCommand" /> set to command and result is failed without message, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and no matching sub command then <paramref name="chatCommand" /> set to command and result is failed with message about unknown sub command, command name and sub command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and matching sub command then <paramref name="chatCommand" /> set to sub command and result is succeed, command name and sub command name removed from <paramref name="unparsed" />;</item>
            </list>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryGetCommand(Eco.Shared.Localization.SupportedLanguage,System.String,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>Tries to get <paramref name="command" /> either by english <paramref name="name" /> or by localized name. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryParseCommandName(System.String@,System.String@)">
            <summary>
            Tries to parse <paramref name="commandName" /> from <paramref name="unparsed" />. If succeed then it removes <paramref name="commandName" /> from <paramref name="unparsed" /> and returns <c>true</c>.
            Returns <c>false</c> otherwise and <paramref name="unparsed" /> stays untouched.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.HandleCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.HandleCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)">
            <summary>Tries to handle command from <paramref name="text" /> (it should start with '/'). If it isn't a valid command string then it returns false. </summary>
            <param name="chatClient">Chat client used to execute the command</param>
            <param name="text">Full command string to execute</param>
            <param name="language">Language to execute the command under</param>
            <returns>True if a valid command starting with a forward slash was supplied.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.CanRunCommand(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary>Checks if a <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> can run the requested <seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" />.</summary>
            <param name="chatClient"><seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance to check.</param>
            <param name="command"><seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> instance to check if the <paramref name="chatClient" /> can run.</param>
            <returns>True if the <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance can run the command.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetCommandMapping(Eco.Shared.Localization.SupportedLanguage)">
            <summary> Returns command mapping for <paramref name="language" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.InvokeCommand(Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,System.String,Eco.Gameplay.Systems.Chat.IChatClient,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <summary> Invokes <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> with unparsed <paramref name="args" /> string. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ShowHelp(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary> Shows help for <paramref name="command" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ShowHelpByQuery(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Shared.Localization.SupportedLanguage,System.String,System.Boolean)">
            <summary>
            Shows help for <paramref name="query" />. It depends on <paramref name="query" /> content:
            <list type="bullet">
            <item>`command[ subCommand]` - will show help for command/sub command/shortcut</item>
            <item>`command unknownSubCommand` - will show help for command</item>
            <item>`unknownCommand` - show all commands matching `unknownCommand` substring</item>
            <item>`` - will show all commands</item>
            </list>
            If <paramref name="full" /> is set then will expand sub commands for all commands.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetFilteredCommands(Eco.Shared.Localization.SupportedLanguage,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel,System.Boolean,System.Boolean,System.String)">
            <summary> Returns commands matching filter parameters. </summary>
            <param name="language"></param>
            <param name="authLevel">Will only return commands with auth level less or equal to this level.</param>
            <param name="expandSubCommands">If set then will expand sub commands for matched commands.</param>
            <param name="headless">If set to false then the commands will be filtered to only those that can be invoked by <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instances that are not a <seealso cref="T:Eco.Gameplay.Players.User" /></param>
            <param name="searchString">Optional filter string for command names.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.SendHelpReport(Eco.Gameplay.Systems.Chat.IChatClient,System.Text.StringBuilder)">
            <summary> Sends help in <paramref name="sb" /> to the <paramref name="chatClient" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandsSummary(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand},System.Boolean)">
            <summary> Appends only summary for <paramref name="commands" />. If <paramref name="nameOnly" /> set then will use command name only instead of fully qualified name with '/' prefix. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandUsage(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary> Appends command usage info including all parameters with types and hints. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandHelp(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel,System.Boolean)">
            <summary>
            Appends <paramref name="command" /> help (only if it allowed by <paramref name="authLevel" />). Output will depend on command type.
            If it is root command then it will show command summary and all sub commands. Otherwise it will show usage for the command.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandSummary(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,System.Boolean)">
            <summary> Appends <paramref name="command" /> summary (name with help text). It <paramref name="nameOnly" /> set then will use command name instead of fully qualified name with '/' prefix. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GroupByAuthLevel(System.Collections.Generic.IEnumerable{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand})">
            <summary> Groups commands by their auth level and sorts by auth level name. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ParamFormat(System.String)">
            <summary> Formats parameter with own style. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetPrettyCommandParameterTypeName(System.Type)">
            <summary> Returns "pretty" name for parameter type. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.LogAdminCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String)">
            <summary> Adds info about admin command executed by <paramref name="chatClient" /> to special admin commands log. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryMakeChatCommand(System.Reflection.MethodInfo,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>Tries to make <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> for <paramref name="method" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddTypeCommands(System.Type,System.Collections.Generic.Dictionary{System.String,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand},System.Collections.Generic.List{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand})">
            <summary>Scans <paramref name="handlerType" /> for methods which may be used as chat commands and adds them to collections.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddCommandHandlers(System.Collections.Generic.IEnumerable{System.Type})">
            <summary> Collects all chat commands for <paramref name="handlerTypes" /> and registers them in <see cref="F:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.commandsByLanguage" /> dictionary for English language.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddHandlersByReflection">
            <summary> Collects all chat commands by reflection and registers them in <see cref="F:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.commandsByLanguage" /> dictionary for English language.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ValidParameterType(System.Type)">
            <summary> Checks if <paramref name="type" /> is valid type for chat command parameter. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.CheckCommandsAuthLevel">
            <summary> Tell with warning if any command has AuthLevel lower than any of it's subcommands. That can lead to the wrong /help for commands.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ReplaceCommandProcessor">
            <summary> Checks if a mod contains a custom method for handling command processing logic. Only accepts the first method that meets the requirements. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.MessagingCommands">
            <summary>Messaging commands related to chat itself, also mail and notification commands</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.MessagingCommands.ChatInteraction(Eco.Gameplay.Players.User,System.Boolean,System.Single,System.Boolean)">
            <param name="enableGeneralMessages">Enable sending messages from a test user to the general channel periodically.</param>
            <param name="timeBtwMessages">Specify the delay time between messages.</param>
            <param name="enableWhisperMessages">Enable sending messages from a test user to the current user periodically.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.GetReg(Eco.Gameplay.Systems.Chat.IChatClient,System.String,System.String,System.Boolean)">
            <summary> Gets the named Registrar, sending an error response to the client if it could not be found. </summary>
            <param name="client"></param>
            <param name="name"></param>
            <param name="exampleDescription"> A textual example showing the format this command should take. </param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.ValidEntryToRemove(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Core.Systems.IHasID)">
            <summary> Check if the IHasID object is valid to be removed. Messages User in case of failure </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.GetIdHolder(Eco.Gameplay.Systems.Chat.IChatClient,System.Int32)">
            <summary> Get the IHasID with the specified Universal ID. Messages User in case of failure </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.GetEntry(Eco.Gameplay.Systems.Chat.IChatClient,System.String,System.String,System.String)">
            <summary>
             Gets the named Entry (object) specified by the client, sending an error response to the client if it could not be found. 
            </summary>
            <param name="client"></param>
            <param name="exampleDescription">A textual example showing the format this command should take. </param>
            <param name="partialTypeName"></param>
            <param name="partialObjectNameOrId"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.Send(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.String)">
            <summary></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.AddCommandHandler(System.Type)">
            <summary>Adds command handler type which should contains one or more methods with <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> or <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatSubCommandAttribute" />. This method should be called before ChatManager initialization finished.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.GetAllCommands">
            <summary>Get list of all chat commands (from all IChatCommandHandler classes)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.SetChatReceiver(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.Boolean)">
            <summary>Set client's current chat receiver (user or channel) (instead previous OutputTag), it also can include activation of the chat log</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary>Executes command (starting from slash), commands are defined in IChatCommandHandler classes</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.GetSettingsForUser(Eco.Gameplay.Players.User)">
            <summary>Get chat settings and chat tabs for user, which are stored on server</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver">
            <summary>Chat can only be sent to entities tagged as IChatReceiver.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.ChatRecipients">
            <summary>The underlying users that the receiving target represents.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.ChatTag">
            <summary>Chat tag this chat receiver associated with.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.MarkedUpChatTag">
            <summary>Marked up name used to display in chat message</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.NotificationMessageSource">
            <summary>
            Notification sources are managed in chat manager.
            They are read only channels that allow the player to choose what notification category to see or to show whispers in tab.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.NotificationSource">
            <summary>
            This class is specific for notifications, it derives from NotificationMessageSource and adds NotificationCategory
            it allows to choose NotificationCategories in ChatTabSettings to show in chat tab
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications.AddAggregatedMessage(Eco.Gameplay.Players.User,System.String,System.Object,System.Double,System.Func{System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Collections.Generic.IEnumerable{System.Object},Eco.Shared.Localization.LocString},System.Boolean,Eco.Gameplay.Settlements.Settlement)">
            <summary>Begin an aggregated message that appends the passed data to the list, updates the time of send, and assigns
            the instructions to how to build the final data.  The notification will be identified as a key of user+handle string.</summary>
            <param name="accumulateSeparateMessagesPerUser">If true, each user will have their own separate notification. Otherwise, users will be accumulated into a single notification.</param>
            TODO: When settlement set, only send to citizens of that.
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications.GetAndClearReadyAggregatedMessages">
            <summary>Get any aggregated messages from the queue, and clear them from the list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications.SetDelayOverride(System.Nullable{System.Int32})">
            <summary> Override all aggregated notification delay, used for testing. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.BroadcastNotification">
            <summary>Broadcast notification to all users.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.DirectNotification">
            <summary>Direct notification to one or more users.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.INotificationManager.Send(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},Eco.Shared.Services.NotificationCategory,Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationStyle,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Boolean)">
            <summary>
            Sends <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" /> to users from <paramref name="to" /> enumerable. If <paramref name="to" /> is <c>null</c> then sends to all users, but if <paramref name="to" /> is empty then doesn't send notification to any user.
            This way you may distinguish between empty user set (i.e. from Demographic) and broadcast message.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification">
            <summary>Notification for use in server side and for storage. Client side uses manually created NotificationView representation</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.GetReceivers">
            <summary>Returns all receivers as enumerable for the <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.GetOnlineReceivers">
            <summary>Returns only online receivers as enumerable for the <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.HasReceiver(Eco.Gameplay.Players.User)">
            <summary>Checks if the notification has <paramref name="receiver" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.NotificationDataPartition">
            <summary>Persistent Notification Data. May be used as stand-alone notification storage or as a partition of <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> (as used in <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager" />).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationDataPartition.RemoveAll(System.Predicate{Eco.Gameplay.Systems.Messaging.Notifications.Notification})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager">
            <summary>
            NotificationManager is the central hub for dispatching notifications of all sorts to the players.
            This class exposes static API for easier usage, but internally uses ServiceHolder instance which is needed for tests with DummyNotificationManager.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.TemporaryServerMessageToPlayer(Eco.Shared.Localization.LocString,Eco.Gameplay.Players.User,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary> Send chat message to player, it's temporary won't be stored on server storage </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.ServerMessageToPlayer(Eco.Shared.Localization.LocString,Eco.Gameplay.Players.User,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle,System.Boolean)">
            <summary> Send chat message to player </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.ProcessNotification(Eco.Gameplay.Systems.Messaging.Notifications.Notification,System.Boolean)">
            <summary>Process notification (displays to users and adds to notification log).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.SendInstantNotification(Eco.Gameplay.Players.User,Eco.Shared.Localization.LocString,Eco.Shared.Services.InstantNotificationPosition)">
            <summary>Send RPC with <param name="notificationMessage"></param> notification message and <param name="position"></param> position to <param name="user"></param>user</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.SendImportantMessage(Eco.Gameplay.Systems.Messaging.Notifications.Notification,System.Boolean)">
            <summary> Create a new wrapped mail for users list, because we dont save references to mail messages (perhaps we change this later to save space on serializing duplicated mail) </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage">
            <summary>
            We use this struct to store all the data about our tooltips subscriptions (Keep track of what part is subscribed to which user and instance).
            Important : this is just storing and not actually doing the caching, to see how we're actually caching each tooltip part you can start by checking <see cref="T:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase" />.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.UserAndTooltipPartName">
            <summary>We store the user and the tooltip part name.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.TooltipPartTypeAndInstance">
            <summary>We store the tooltip part type and the instance that's using it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.Add(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.NewTooltip.TooltipPartBase,Eco.Core.Controller.IController)">
            <summary>Add a tooltip reference for the specified part to all our collections.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.TryGetTooltipPartRef(Eco.Gameplay.Players.User,System.String,System.Type,Eco.Core.Controller.IController,Eco.Shared.Items.TooltipPartRef@)">
            <summary>We try to get the tooltip part reference with the specified user, tooltip name, type and controller.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.GetAllPartsRefs">
            <summary>We get all the cached parts refs with the user that they are related to.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.GetPartsRefs(System.String,System.Type)">
            <summary>Using the specified tooltip name and type, we get a list of all the related parts with their users.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.GetTypeAndInstanceToPartRef(Eco.Gameplay.Players.User,System.String)">
            <summary>We get all the tooltip parts with their type and controller that are named "tooltipName" and cached for the specified user.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.AllUsersWithCachedTooltips">
            <summary>We get all the users that have any cached tooltip.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.RemovePartRef(Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipPartRef)">
            <summary>We remove a tooltip reference to the specified tooltip part from our collections.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionStorage.ClearAllTooltipsRefsForUser(Eco.Gameplay.Players.User)">
            <summary>Remove all the tooltip parts references that are connected to the specified user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionHelper.CreateTooltipInvalidationAction(System.Type,System.Reflection.MethodInfo)">
            <summary>Create tooltip invalidation action for tooltip part generated with <paramref name="method" /> marked with <see cref="T:Eco.Core.PropertyHandling.TooltipAffectedByAttribute" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.Internal.TooltipSubscriptionHelper.CreateTooltipInvalidationActionByAttribute(System.Reflection.MethodInfo,Eco.Gameplay.Systems.NewTooltip.NewTooltipAttribute)">
            <summary>Returns handler which called when tooltip part invalidated by property change.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.NewTooltipAttributeBase.CreatePartInstance(System.Reflection.MemberInfo,System.Type)">
            <summary>Creates tooltip part instance that represents tooltip part defined by this attribute and member it's applied to.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.NewTooltipAttributeBase.IsIgnoredType(System.Type)">
            <summary>Chech whether the specified type is ignored and doesn't really have this tooltip.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipChildrenAttribute">
            <summary>
            Use on properties returning one or more objects of type that implements IController interface.
            Objects returned by this member will have their tooltip members included along with
            this object's tooltip.  Adding a <see cref="F:Eco.Gameplay.Systems.NewTooltip.NewTooltipChildrenAttribute.ExcludeCategories" /> as a parameter
            to the attribute will filter tooltips of that type from the child(ren) for this object's tooltip.
            </summary>
            <remarks>If the child value is going to be updated during runtime and we want the child tooltip to reflect that, the parent class should implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" />.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions">
            <summary>
            Class created to profile lookup performance using benchmarks. For testing purposes only. 
            </summary>
            <remarks>See original 'TooltipSubscriptions.cs' for more info.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.Subscribe(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.NewTooltip.TooltipPartBase,Eco.Core.Controller.IController)">
            <summary>Marks a user as having received the tooltip part, so we know to inform them if it gets invalidated.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkTooltipPartDirty(System.String,System.Type,Eco.Core.Controller.IController,Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Marks tooltip part as dirty. All parameters required by this part's CacheMode must be provided.</summary>
            <param name="includeDerivedTypes">If set to true, all types that derive from passed type will also have this tooltip part marked as dirty. Should only be used with <see cref="F:Eco.Shared.Items.CacheAs.SubType" />.</param>
            <remarks>If the tooltip is only using <see cref="F:Eco.Shared.Items.CacheAs.User" /> then we still need to specify a type when invoking this method.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirtyForAll(System.Type,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users and all instances of <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirtyForUser(Eco.Gameplay.Players.User,System.Type,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" /> for all instances of <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkPartRefsDirty(Eco.Gameplay.Players.User,ConcurrentCollections.ConcurrentHashSet{Eco.Shared.Items.TooltipPartRef},System.Type,System.String)">
            <summary>Marks every tooltip part referenced by <see cref="T:Eco.Shared.Items.TooltipPartRef" /> in <paramref name="partRefs" /> that matches <paramref name="tooltipName" /> and <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirtyForInstance(Eco.Core.Controller.IController,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users, but only for <paramref name="controller" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirtyForType(System.Type,System.String,System.Boolean)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users, but only for instances of <paramref name="type" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" />, but only for <paramref name="controller" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,System.Type,System.String,System.Boolean)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" />, but only for instances of <paramref name="type" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,Eco.Gameplay.Systems.NewTooltip.TooltipPartBase)">
            <summary>Marks <paramref name="part" /> as dirty for <paramref name="user" /> for <paramref name="controller" />.</summary>
            <param name="controller">Controller for which part will be marked as dirty. If controller is irrelevant for taht part null should be passed.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.QueueDirty(Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipPartRef)">
            <summary>Adds tooltip part referenced by <paramref name="partRef" /> to the queue of dirty parts for <paramref name="user" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.RemoveDeadEntries">
            <summary>Scans entire tooltip cache for entries referencing objects that were alread ygarbage collected and removes them on server and clients by marking them as dirty.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.ApplyDirtyTooltips">
            <summary>Go through all the dirty tooltips and tell whoever subscribes to each one that they're gonna need to refresh next time they need it.
            Also clear the server cache for these dirty tooltips.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.ClearCacheForUser(Eco.Gameplay.Players.User)">
            <summary>Clears the record of parts that this user is subscribed to. Since we dont store user-specific data on the server-side cache, we
            dont need to remove any cached data otherwise.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.OldTooltipSubscriptions.ClearCache">
            <summary>Clear the cache and list of dirty things.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.ParamExplanation">
            <summary>Lists params relevant to the player, optionally showing currently assigned values of passed in instances, along with descriptions of each.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.ParamExplanation.GetDescriptionRowForProperty(System.Type,System.Reflection.PropertyInfo,System.Object[])">
            <summary> Forms the list containing the display text of a row that describes a type's property. <para> Currently holds 'Icon + Name' on first index, and 'Description' (if any) on second index. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.ParamExplanation.DescribeObject(System.Object)">
            <summary> Determines the type of the object passed as parameter and describes it. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipAttribute">
            <summary>Marks a method, property, or field as a 'TooltipPart'. Tooltip parts will be composed to form the tooltip for a type.</summary>
            <remarks>See tootlip.md for the full picture.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.NewTooltipAttribute.#ctor(Eco.Shared.Items.CacheAs,System.Int32,Eco.Shared.Items.TTCat,Eco.Gameplay.Systems.NewTooltip.TTFlags,System.Type,System.Type[])">
            <summary>Declares a tooltip part, along with how it is cached.  Tooltip parts must be marked 'dirty' when they're updated, so the clients that are caching them can be informed of the change.</summary>
            <param name="cacheMode">How many cache entries should be created? One per instance, user, type, subytpe, etc</param>
            <param name="priority">What order is the tooltip part displayed to the client among other tooltip parts (lower value means higher priority)</param>
            <param name="categories">Allows defining categories, so certain types of tooltip parts can be excluded in certain situations (IE, we dont want to show 'controls' tooltip parts when showing items in the ecopedia, becasue its not an item you can control)</param>
            <param name="flags">Extra flags to control cache-clearing and other behavior</param>
            <param name="overrideType">Defining this will set the type that the tooltip part displays on.  By setting this, you can make a tooltip part appear on all objects of a given type.  The tooltip part function can accept a 'Type' param that will send in the type its being executed on.</param>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipTitle">
            <summary>Marks a method, property, or field as a tooltip title. Title with highest priority will be displayed as title for object's tooltip.</summary>
            <remarks>See tootlip.md for the full picture.</remarks>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.NewTooltipTitle.CustomEcopediaPage">
            <summary>Overrides default ecopedia page</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipCacheErrorDetection.TypeToTooltips">
            <summary>Contains all parts for a given type.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipCacheErrorDetection.debugCachedUserTootips">
            <summary>
            We don't cache tooltips that are per-user normally, because each user will cache that on their client.
            But we do track them here for debug purposes: so we can detect when a tooltip changes, but its never marked 'dirty' to allow clients to requery it.
            </summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipCacheErrorDetection.controllerLastUsedToQueryCachePerPart">
            <summary>
            For tooltips that are 'constant per type', the instance used to query them doesnt get stored in the cache.
            However, to re-query the tooltip text when audited the cache, we need to have that instance.
            So, we store a reference to the controller that was originally used to query it.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.TooltipCacheErrorDetection.AllCache">
            <summary>Go through all parts in the cache.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.cache">
            <summary>Contains all cache entries for tooltip part children. Values are collections of tooltip parts that are children represented by particular TooltipChildrenPart.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.ClearAllCache">
            <summary>Clear the cache of all tooltip children parts.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.Attribute">
            <summary>The attribute from which this part was created.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.childControllerGetter">
            <summary>Function that may take various parameters and returns all child controllers from member marked with the attribute.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.GetChildren(System.Type,Eco.Core.Controller.IController,Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipOrigin)">
            <summary>Returns all child controllers.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.ClearCache(System.Int32)">
            <summary>Clear cache for object with given id.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipChildrenPart.SetGenerator(Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.GetValueFromMember)">
            <summary>Takes delegate generated by base class and after adding necessary casts sets it as child controller getter.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.CivicsTooltipLibrary.contractClauseHelpText">
            <summary>Dictionary matching types deriving from <see cref="T:Eco.Gameplay.Economy.Contracts.ContractClause" /> to their help texts displayed in tooltips.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.ComponentTooltipLibrary.StatusTooltip(Eco.Gameplay.Components.OnOffComponent)">
            <summary>Add a note about current state to the tooltip.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.EconomyTooltipLibrary">
            <summary>Tooltips related to the economy. This class both sets up the needed subdscription that will 'dirty' the tooltip as needed, and defines the actual tooltip parts related to it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.ItemTooltipLibrary.DataTooltip(Eco.Gameplay.Items.ItemPersistentData)">
            <summary>Tooltip section with information that this object has been used previously. Contains a clickable link to reset object's persistent data. When hovered, the button shows tooltips of stored entries.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary">
            <summary>Tooltip library for all tooltips related to skills and their levels</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary.skillUnlocksTooltips">
            <summary>Cached data for <see cref="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary.UnlocksDescription(System.Type)" /> tooltip part</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary.TalentBenefitsForItemOrTag(Eco.Gameplay.Items.Recipes.IngredientElement,Eco.Gameplay.Players.User)">
            <summary>Creates a tooltip section for talent benefits of a specific item.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer">
            <summary>
            Handles constructing tooltips from a set of tooltip parts for controllers, using caching to prevent duplicate
            queries, and error detection to detect non-dirted parts, etc. See Tooltip.md for a full description.
            </summary>
            <remarks>See 'Tooltip.md' for more info.</remarks>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.CacheRefreshRate">
            <summary>Number of seconds between applying cache updates from <see cref="F:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.queuedDirty" />.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.CacheCleanupRate">
            <summary>Number of seconds between scans of tooltip cache taht remove entries that reference objects that were already garbage collected.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.#ctor">
            <summary> Using reflection in default constructor to find all the members tagged with the NewTooltipAttribute and register them for the types that they apply to. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.#ctor(System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Type})">
            <param name="controllerClasses">Represents collection of classes that derived from IController. This collection will be scanned for tooltip parts to register. </param>
            <param name="tooltipLibraries">Represents collection of tooltip libraries (classes with 'TooltipLibrary' attribute). This collection will be scanned for tooltip parts to register. </param>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.AddClientTypes``1(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{``0}},System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{``0}})">
            <summary>Adds only client types (having associated view) to <paramref name="clientTypeToParts" /> filtered from <paramref name="typeToParts" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.ClearCache">
            <summary>Removes all cached data in ourselves and children support classes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.GetTooltipParts(System.Type,System.Boolean,Eco.Shared.Items.TTCat)">
            <summary>Returns all tooltip parts</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.GetTooltipPartsByLinkId(Eco.Gameplay.Players.Player,System.String,Eco.Shared.Items.TooltipOrigin,Eco.Shared.Items.TTCat)">
            <summary>
            Returns tooltip parts for controller referenced by passed link. May be used for late bounded links for objects which isn't persistent or doesn't have serialized universal ID.
            When requested returns <see cref="T:Eco.Shared.Items.TooltipServerResponse" /> with all necessary information for tooltip rendering and caching on client side.
            Client then will have resolved Universal ID and type info for that link id and will use <see cref="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.GetTooltipParts(Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipServerRequest,Eco.Shared.Items.TooltipOrigin,Eco.Shared.Items.TTCat)" /> for further requests using link id only for initial tooltip content request.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipPart">
            <summary>
            Server side implmentation of the tooltip part, built from members with NewTooltip attributes on them.
            It stores all the relevant data about the part and shares it with the client.
            It also contains the actual cached data for each tooltip part, which is used to get the text
            when a user queries a tooltip.
            </summary>
            <remarks>See 'Tooltip.md' for more info.</remarks>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipPart.cache">
            <summary>Contains all cache entries for tooltip part content.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.ClearAllCache">
            <summary>Clear the cache of all tooltip parts.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.TooltipPart.Attribute">
            <summary>The attribute from which this part was created.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.#ctor(System.Reflection.MemberInfo,Eco.Gameplay.Systems.NewTooltip.NewTooltipAttribute,System.Type)">
            <summary>
            Create the tooltip part for the given member, passing in the attribute (to avoid a requery) and the root type (which may be different
            than the member declared type, in the case of TooltipLibraries that specify an override type).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.SetGenerator(Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.GetValueFromMember)">
            <summary>Takes delegate generated by base class and after adding necessary casts sets it as tooltip generator.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.GetText(System.Type,Eco.Core.Controller.IController,Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Players.User)">
            <summary>Main cache querying function. Get thes type + obj + origin + user and returns the cache for that combo, or builds it if it doesnt exist</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.ClearCache(System.Int32)">
            <summary>Clear cache for object with given id.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.GenerateText(System.Type,Eco.Core.Controller.IController,Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Players.User)">
            <summary>Helper to execute the generator function to create the tooltip's text, passing only the properties the type wants (some parts dont want a user and/or origin).</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.Attribute">
            <summary>The attribute from which this part was created.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.GetValueFromMember">
            <summary>Delegate that defines what parameters can members defining tooltip parts take.</summary>
            <returns>Returned object can be cast to proper type by derived classes that can pu constraints on what can be returned by specific tooltip members.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.SetGenerator(Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.GetValueFromMember)">
            <summary>Method that receives a delegate that can call the member marked with the attribute and return object returned by that member. Class overriding this should implement that method to internaly set up it's own generator delegate.</summary>
            <param name="generator">Delegate that can call member marked with the attribute and return object returned by that member.</param>
            <remarks>This method is called from the base constructor, so it can't rely on any data set in derived class's constructor.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.GenerateDebugText(Eco.Core.Controller.IController,Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Players.User)">
            <summary>Generates text that represnets contents of this part for given context.</summary>
            <remarks>Generated string can be used to compare contents of parts and spot differences.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.MakeRef(Eco.Core.Controller.IController,System.Int32)">
            <summary>Create a reference to this part, omitting the controller and user ID if we dont care about them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPartBase.ClearCache">
            <summary>Clear the cache of all tooltip parts and children parts.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipSection">
            <summary>A single section for a tooltip that contains a title and some content, can be wrapped by line or foldable.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSection.Cast(System.Object)">
            <summary>Casts <paramref name="value" /> to <see cref="T:Eco.Gameplay.Systems.NewTooltip.TooltipSection" /> (if possible).</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipClickContext">
            <summary>Tracks the context of how the tooltip was clicked.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions">
            <summary>
            Helper class to manage the subscriptions to tooltips by users.
            Tracks which parts are dirty, informs users of them on an interval, and clears
            the cache. They are recached the next time they are queried (ie, lazily).
            </summary>
            <remarks>See 'Tooltip.md' for more info.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.Subscribe(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.NewTooltip.TooltipPartBase,Eco.Core.Controller.IController)">
            <summary>Marks a user as having received the tooltip part, so we know to inform them if it gets invalidated.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkTooltipPartDirty(System.String,System.Type,Eco.Core.Controller.IController,Eco.Gameplay.Players.User,System.Boolean)">
            <summary>Marks tooltip part as dirty. All parameters required by this part's CacheMode must be provided.</summary>
            <param name="includeDerivedTypes">If set to true, all types that derive from passed type will also have this tooltip part marked as dirty. Should only be used with <see cref="F:Eco.Shared.Items.CacheAs.SubType" />.</param>
            <remarks>If the tooltip is only using <see cref="F:Eco.Shared.Items.CacheAs.User" /> then we still need to specify a type when invoking this method.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForAll(System.Type,System.String)">
            <summary>
            Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users and all instances of of the specified type. 
            iInstance that are of a derived type are also marked dirty.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForUser(Eco.Gameplay.Players.User,System.Type,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" /> for all instances of <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkPartRefsDirty(Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipPartRef)">
            <summary>Marks tooltip part referenced by <see cref="T:Eco.Shared.Items.TooltipPartRef" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForInstance(Eco.Core.Controller.IController,System.String,System.Type)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users, but only for <paramref name="controller" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForType(System.Type,System.String,System.Boolean)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users, but only for instances of <paramref name="type" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,System.String,System.Type)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" />, but only for <paramref name="controller" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,System.Type,System.String,System.Boolean)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" />, but only for instances of <paramref name="type" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,Eco.Gameplay.Systems.NewTooltip.TooltipPartBase)">
            <summary>Marks <paramref name="part" /> as dirty for <paramref name="user" /> for <paramref name="controller" />.</summary>
            <param name="controller">Controller for which part will be marked as dirty. If controller is irrelevant for taht part null should be passed.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.QueueDirty(Eco.Gameplay.Players.User,Eco.Shared.Items.TooltipPartRef)">
            <summary>Adds tooltip part referenced by <paramref name="partRef" /> to the queue of dirty parts for <paramref name="user" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.RemoveDeadEntries">
            <summary>Scans entire tooltip cache for entries referencing objects that were alread ygarbage collected and removes them on server and clients by marking them as dirty.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ApplyDirtyTooltips">
            <summary>Go through all the dirty tooltips and tell whoever subscribes to each one that they're gonna need to refresh next time they need it.
            Also clear the server cache for these dirty tooltips.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ClearCacheForUser(Eco.Gameplay.Players.User)">
            <summary>
            Clears the record of parts that this user is subscribed to. Since we dont store user-specific data on the server-side cache, we
            dont need to remove any cached data otherwise.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ClearCache">
            <summary>Clear the cache and list of dirty things.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubExtensions.GetPart(Eco.Shared.Items.TooltipPartRef)">
            <summary>Get the tooltip part this ref struct refers to.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.ClearCacheForAllUsers">
            <summary>Use this flag for tooltip parts that need to be cached per user, but need to be marked as dirty for all users at once in some cases. If a specific user gets passed when marking a tooltip as dirty then this flag will be ignored.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.ClearCacheForAllInstances">
            <summary>Use this flag for tooltip parts that need to be cached per instance, but need to be marked as dirty for all instances at once in some cases. If a specific instance gets passed when marking a tooltip as dirty then this flag will be ignored.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.ForceInstantUpdate">
            <summary>Setting this flag for a tooltip part will cause server to notify clients and server's cache that it was marked as dirty instantly. Normally this happens in intervals defined by <see cref="F:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.CacheRefreshRate" />.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.AllowNonControllerTypeForChildren">
            <summary>Allow <see cref="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipChildrenAttribute" /> to be used with types that doesn't inherit from IController, if you're not sure about what you're doing don't use this.
            For example this is used in <see cref="T:Eco.Gameplay.Items.IPersistentData" /> where the type is object but we still want to use this because we are making sure manually that non IController types aren't assigned this attribute.</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.AllowSubTypeCacheForGenericTypes">
            <summary>
            Setting this type will allow the use of the SubType cache mode with generic classes.
            When SubType cache mode is used, all instances of a generic type with a generic argument before runtime will be treated as a single subType meaning :
            -&gt; tooltip with "OverrideType: typeof(GenericType'')" and SubType cache mode will have the same cache for all the types (GenericType'int', GenericType'float', etc.)
            meaning only the derived types of GenericType'' will have their own caches.
            </summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TTFlags.AllowInstanceForSubTypeCache">
            <summary>
            Use this flag to allow operating with instance data for SubType cache mode (can be used for instance members or extension methods).
            <br>Even though tooltips cached as SubType should never depend on instance data (since it may differ for each instance), sometimes we can be sure that all instances of one type have the same data (e.g. static property).</br>
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.ISpecialRegistrarEntry.SpecialType">
            <summary>An identifier specifying what kind of special instance it is. -1 for 'not special just a regular old instance'</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.IRegistrarManager">
            <summary>
            Provides features for untyped registrar management:
            - Maintains a set of 'special' entries that are always there.
            You should prefer to use parameterized types interface instead for implementation, but this interface may be used for type-unaware processing.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.ServerLogHandler">
            <summary>A Handler to help propagating Log messages from client to server. Can be used when client error need to be duplicated in server log for easier issue investigation.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.SleepManager.WakeUserUp(Eco.Gameplay.Players.User)">
            <summary>If the bed that player's sleeping on is destroyed, we need to wake the player up</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.SystemCultureInfoManager">
            <summary>A manager for global culture info, like number formats and such, nothing to do with Eco Culture (that's in 'CultureManager')</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.WordMatchExtensions.Overlaps(Ganss.Text.WordMatch,Ganss.Text.WordMatch)">
            <summary>
            Checks if two <see cref="T:Ganss.Text.WordMatch" /> overlap. Two <see cref="T:Ganss.Text.WordMatch" /> overlap when their intervals [<see cref="P:Ganss.Text.WordMatch.Index" />, <see cref="P:Ganss.Text.WordMatch.Index" /> + <see cref="P:Ganss.Text.WordMatch.Word" />.length] in the query string overlap.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.WordMatchExtensions.MergeWith(Ganss.Text.WordMatch,Ganss.Text.WordMatch)">
            <summary>
            Merges two <see cref="T:Ganss.Text.WordMatch" /> and keeps the longest <see cref="P:Ganss.Text.WordMatch.Word" />
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.WordMatchExtensions.ValidNeighbors(Ganss.Text.WordMatch,System.String)">
            <summary>
            Checks if a <see cref="T:Ganss.Text.WordMatch" /> has valid neighbors in the query test. To be valid the <see cref="T:Ganss.Text.WordMatch" /> must not be encompassed by <see cref="M:System.Char.IsLetterOrDigit(System.Char)" /> on either side
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.AhoCorasickExtensions.CombineOverlappingMatches(System.Collections.Generic.IEnumerable{Ganss.Text.WordMatch})">
            <summary>
            Combines the overlapping <see cref="T:Ganss.Text.WordMatch" /> of a collection. See <see cref="M:Eco.Gameplay.Systems.TextLinks.WordMatchExtensions.Overlaps(Ganss.Text.WordMatch,Ganss.Text.WordMatch)" />
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.AhoCorasickExtensions.WholeSearch``1(Ganss.Text.AhoCorasick,System.String,System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>
            Performs Aho-Corasick search on a query and applies post-processing steps:
            <list type="bullet">
            <item><description>Remove matches with invalid neighbors. See <see cref="M:Eco.Gameplay.Systems.TextLinks.WordMatchExtensions.ValidNeighbors(Ganss.Text.WordMatch,System.String)" /> </description></item>
            <item><description>Remove matches that aren't in <paramref name="valid" />. Aho-Corasick doesn't allow keyword removal so this <see cref="T:System.Collections.Generic.IDictionary`2" /> must keep track of the valid keywords </description></item>
            <item><description>Combine overlapping matches, keeping the longest one. </description></item>
            </list>
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.TextLinks.MappedLinkedIdTranslator`1">
            <summary>
            <see cref="T:Eco.Gameplay.Systems.TextLinks.ObjectLinkIdTranslator`1" /> implementation with mapping between link id and object implementing <see cref="T:Eco.Core.Systems.IHasUniversalID" /> for not-entity objects (without own identity).
            This mapping required for ensuring that link id is always mapped to same object for tooltip caching.
            I.e. <see cref="T:Eco.Gameplay.Systems.TextLinks.Vector3Tooltip" /> may be created from link id string and doesn't have own identity, fully defined by content in the link id, but client may want to cache the tooltip by universal id.
            So instead of creating new <see cref="T:Eco.Gameplay.Systems.TextLinks.Vector3Tooltip" /> object every time it will create it on demand (if not yet exists)
            and then just return same object with same universal id every time when same link id requested.
            </summary>
            <remarks>
            This mapping will never clear once mapped objects, because those may be remembered on client. Also the objects will be saved in <see cref="T:Eco.Core.Systems.UniversalIDs" /> mapping anyway.
            It may lead to memory leaks, but as it only creates mapping on demand which starts as empty on every server restart and we assuming daily restart for big servers it shouldn't become an issue.
            There potential optimizations which may be applied if problem starts being serious:
            - Server may make regular clean ups for Mapping, removing oldest records, clients will be notified about released IDs and will just invalidate cache and re-request by link id if required;
            - Don't use universal IDs for such objects and add support for tooltips for custom link ids.
            But until we have real issue we decided to use simplest approach.
            </remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.MappedLinkedIdTranslator`1.GetTypedLinkTarget(System.String)">
            <summary>Returns mapped <see cref="T:Eco.Core.Systems.IHasUniversalID" /> for <paramref name="linkId" /> or creates new if not yet mapped.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.MappedLinkedIdTranslator`1.CreateTypedLinkTarget(System.String)">
            <summary>Creates new <typeparamref name="T" /> object by content of <paramref name="linkId" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.ObjectFinderUtils.ToWordRegex(System.String)">
            <summary>
            Create a regex that searches for an occurrence of 'regex' that is not adjacent to word characters
            on either side (if regex="axe", match "axe" or "axe?" but not "axer").
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.ObjectFinderUtils.ToWordRegex(System.Linq.IOrderedEnumerable{System.String})">
            <summary>
            Create a regex that searches for an occurrence of any word in 'words' that is not adjacent to word characters
            on either side (if regex="axe", match "axe" or "axe?" but not "axer").
            </summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.TextLinks.RegistrarFinder.keywords">
            <summary> Track Aho-Corasick keywords. Doesnt need to be thread-safe type as it will be read on ReadLock and written to on WriteLock </summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.TextLinks.RegistrarFinder.linkableNameByObject">
            <summary> Map linkable names by objects so we can find an object if it was renamed and take an old linkable name from it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.RegistrarFinder.Add(Eco.Core.Systems.IHasID)">
            <summary> Adds new <see cref="T:Eco.Core.Systems.IHasID" /> instance to <see cref="T:Eco.Gameplay.Systems.TextLinks.RegistrarFinder" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.TextLinks.TextLinkButton">
            <summary> Clickable UI link that can be used in tooltips. For a demo see <see cref="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.CraftingComponentTooltipLibrary.OwnershipTooltip(Eco.Gameplay.Items.WorkOrder,Eco.Gameplay.Players.User)" /> or <see cref="T:Eco.Gameplay.Items.ItemPersistentData" />.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.TextLinks.TextLinkButton.HoveredHint">
            <summary>This string will be at the bottom of the tooltip when the button is hovered.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.UILinkExtensions.UILinkPlural(Eco.Gameplay.Systems.TextLinks.ILinkableParameterized{Eco.Gameplay.Systems.TextLinks.LinkConfig},System.Int32)">
            <summary>Helper for showing plural if count != 1, and regular otherwise.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TextLinkManager.OnButtonClicked(System.String,System.String,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient)">
            <summary>Handles button link presses, invokes the give rpc name onto the controller with the given link ID.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TextLinkManager.MarkUpText(System.String)">
            <summary>
            Adds tooltip links to the text as appropriate.  This is an expensive operation.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TypeTooltipExtensions.UILinkGeneric(System.Object)">
            <summary> Generates a UILink for target object. </summary>
            <remarks> Automatically determines the way it should be linked based on its type and implemented interfaces. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TypeTooltipExtensions.UILink(System.Type,System.Int32,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Generates a UILink for target type. </summary>
            <remarks> Assign the ID of the controller if linking an object of the type, or leave empty if linking the type itself. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Systems.TextLinks.Vector2Tooltip">
            <summary>Used as link target for Vector2 links. Tooltips for this class are contained in <see cref="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.VectorTooltipLibrary" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.TextLinks.Vector3Tooltip">
            <summary>Used as link target for Vector3 links. Tooltips for this class are contained in <see cref="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.VectorTooltipLibrary" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.UserTextures.UserTexture">
            <summary>Holds the texture bytes for saving and displaying user textures, used by ViewTextureToImage on the client to display texture on UI.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.UserTextures.UserTexture.CachedArtworkValue">
            <summary>The value when placed in its current settlement. If no settlement is assigned, it stays at zero.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTexture.Reset">
            <summary>Resets texture bytes and approval state, useful for replacing portrait images without creating a new texture.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTexture.ComputeArtworkValue(Eco.Gameplay.Players.Player,Eco.Gameplay.Settlements.Settlement)">
            <summary>Do a query to see what the value of this texture would be in the given settlement, since value depends on citizenship of the reputation givers.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.UserTextures.UserTextureConfig">
            <summary>Holds UserTexture related options that can be edited from server config window.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer">
            <summary>Holds user texture registrar and texture saving/conversion logic.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.GetFolderPath(System.Boolean)">
            <summary>Returns folder path to save UserTexture in.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.SaveTextureToStorage(Eco.Gameplay.Systems.UserTextures.UserTexture)">
            <summary>Saves texture data as a file on the given path inside the storage folder.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.MoveApprovedTexture(Eco.Gameplay.Systems.UserTextures.UserTexture)">
            <summary>Moves texture from unreviewed folder to reviewed folder.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.SavePortraitTextureToStorage(Eco.Gameplay.Systems.UserTextures.UserTexture,System.Byte[])">
            <summary>Handles modifications to UserTexture as setting a new avatar portrait doesn't replace the old one, it only modifies the data.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.CreateUserTexture(System.Byte[],Eco.Gameplay.Players.User,Eco.Gameplay.Systems.UserTextures.UserTextureType,System.Boolean)">
            <summary>Creates a new <see cref="T:Eco.Gameplay.Systems.UserTextures.UserTexture" />, adds it to registrar and returns it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.GetTexturesToReview(Eco.Gameplay.Players.User,Eco.Shared.Items.TextureReviewState)">
            <summary>If this user is a reviewer - returns list of unreviewed usertextures, called from the client</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.AddReviewer(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User)">
            <summary>Gives the right to review textures to a non admin user.</summary>
            <param name="authorizer">Person that is giving the right to review textures.</param>
            <param name="recipient">User that will become a reviewer.</param>
            <remarks> Only Admins or Devs can do this action.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.RemoveReviewer(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User)">
            <summary>Removes the right to review textures from a non admin user.</summary>
            <param name="authorizer">User that is removing the right to review textures.</param>
            <param name="recipient">User that will stop being a reviewer.</param>
            <remarks> Only Admins or Devs can do this action.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.SetReviewers(Eco.Gameplay.Players.User,System.Collections.Generic.List{System.Object})">
            <summary>Directly sets additional reviewers from provided list, used by MultiSelectorPopup on the client.</summary>
            <param name="users">List of users that will become reviewers, Empty if removing all reviewers.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.ApproveOrBlock(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.UserTextures.UserTexture,System.Boolean)">
            <summary>Approves or blocks the usertexture.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.SetupFileWatcher">
            <summary>Creates directories for textures and sets up a file watcher to watch changes in the directories. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureManagerServer.CheckChangedFiles">
            <summary>Checks the reviewed folder and usertextures registrar to fix any inconsistencies</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureUtil.CreateRandomUserTexture(System.Int32,System.String,Eco.Gameplay.Players.User)">
            <summary>Make a user texture created by a given user (or new test user, if not set) and fill it with random bytes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureUtil.GenerateUserTextureWithSpecificSize(System.Int32,System.Int32,System.String,Eco.Gameplay.Players.User)">
            <summary>Make a user texture created by a given user (or new test user, if not set) and fill it with random bytes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureUtil.CreateRandomPictureItem(System.Int32,System.String,Eco.Gameplay.Players.User)">
            <summary>Get a picture item filled with a randomly generated image from the given user (or a new test user if null is passed)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureUtil.CreateSpecificSizePictureItem(System.Int32,System.Int32,System.String,Eco.Gameplay.Players.User)">
            <summary>Get a picture item filled with a randomly generated image from the given user (or a new test user if null is passed)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.UserTextures.UserTextureUtil.ResizeJPGTexture(System.Byte[],System.Int32)">
            <summary> Resizes picture in jpeg format up to maxDimension x maxDimension pixels. It will respect existing ratio by lowering one of two dimensions.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.INotifyRecursiveChanged">
            <summary>An interface that will be notified whenever a property that have a property scanner on it is changed using a client side view interface (Ie. an AutoGenSelector).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditor.CloseForUser(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.ViewEditor.WindowType)">
            <summary>Tell the user to close an open editor.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditor.Close(Eco.Gameplay.Players.Player)">
            <summary>When the view get closed, we invoke the onClose event.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditor.Apply(Eco.Gameplay.Players.Player)">
            <summary>On apply button pressed - try to save current changes and then close the view.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditor.Back(Eco.Gameplay.Players.Player)">
            <summary>On apply button pressed - try to save current changes and then close the view.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditorUtils.PopupUserEditValue(Eco.Gameplay.Players.User,System.Type,Eco.Shared.Localization.LocString,System.Object,Eco.Core.Utils.PropertyScanning.IProvidesContext,System.Action{System.Object})">
            <summary>Static function to retrieve a GameValue of type T from the player via a dialog box.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditorUtils.PopupUserEditValueNoHolder(Eco.Gameplay.Players.User,System.Type,System.Nullable{Eco.Shared.Localization.LocString},Eco.Core.Controller.IController,System.Action{System.Object},Eco.Gameplay.Systems.ViewEditor.WindowType,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Static function to edit entry itself, without holder.
            Note: rename of simple entry within this editor will rename existing object (because this will cause Registrar.Rename)</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.AuthUtils">
            <summary>Static utility methods for working with the authorization component.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.AuthUtils.CheckBankAccountAndToggle(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Components.OnOffComponent,Eco.Gameplay.Economy.BankAccount,System.Action)">
            <summary>Checks if the player has the required permissions to use the bank account. If not disable the WorldObject instance via its <see cref="T:Eco.Gameplay.Components.OnOffComponent" />.</summary>
            <param name="owner">Owner(s) to check for <see cref="T:Eco.Gameplay.Economy.BankAccount" /> access/ownership.</param>
            <param name="onOff"><see cref="T:Eco.Gameplay.Components.OnOffComponent" /> instance to toggle off when authorization fails.</param>
            <param name="account">The <see cref="T:Eco.Gameplay.Economy.BankAccount" /> to verify owner acesss.</param>
            <param name="handleCheckFail">Optional Action for running custom logic when the auth check fails.</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.AuthUtils.CheckBankAccountAndToggle(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Components.OnOffComponent,Eco.Gameplay.Components.CreditComponent,System.Action)">
            <inheritdoc cref="M:Eco.Gameplay.Utils.AuthUtils.CheckBankAccountAndToggle(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Components.OnOffComponent,Eco.Gameplay.Economy.BankAccount,System.Action)" />
            <param name="credit">CreditComponent instance to operate on as our bank account instance.</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.BlockUtils.GetItem(Eco.World.Blocks.Block)">
            <summary> Tries to convert object into an item. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.BlockUtils.GetLookAtTooltip(System.Type)">
            <summary> Returns text for Look At tooltip for specified <paramref name="blockType" />. The tooltip appear on the client when player is looking on a block. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.BlockUtils.GetBlockTooltipItem(System.Type)">
            <summary> Returns most suitable <see cref="T:Eco.Gameplay.Items.Item" /> for <see cref="T:Eco.World.Blocks.BlockType" /> to be displayed in Look At tooltip. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.ClosestMatchingItem``1(Eco.Gameplay.Systems.Chat.IChatClient,System.String)">
            <summary> Get a matching item of the given type. If null is passed, get a random one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.ClosestMatchingEntity``1(Eco.Gameplay.Systems.Chat.IChatClient,System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Predicate{``0})">
            <summary> Returns closest matching entities by <paramref name="entityName" /> from <paramref name="entityList" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CheckPlayerOnline(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User)">
            <summary>Check if a player is online before applying action and tell if not</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CollectClosestMatchingEntries``1(System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Predicate{``0},System.Boolean)">
            <summary> Collects closest matching entries by <paramref name="entityName" /> from <paramref name="entityList" />. 
            If 'preferExactMatch' is set, return exact match if it exists instead of list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CollectMatches``1(System.Collections.Generic.List{``0},System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Func{System.String,System.String,System.Boolean})">
            <summary> Collects to <paramref name="container" /> all matches by <paramref name="entityName" /> from <paramref name="entityList" /> using <paramref name="matcher" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IRemovableEntry">
            <summary> Any entry that implement that should be able to remove it from its collection. By example can be used to remove directly entries from some registrar. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.HasContainerAccess(Eco.Gameplay.Players.Player,System.String)">
            <summary>Checks if <paramref name="player" /> has access to modify the <paramref name="listName" /> container.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.VerifyAndSet(Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{System.Object},Eco.Core.Utils.IClientControlledContainer)">
            <summary> Verifies if the given list is valid and if so it will be set. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Add(Eco.Gameplay.Players.Player,System.String)">
            <summary> Adds entry from registrar.
            The container and the entries are gotten from <paramref name="listName"></paramref>, then the container adds the <paramref name="player"></paramref> and each entry. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.RemoveAt(Eco.Gameplay.Players.Player,System.String,System.Int32)">
            <summary> Removes index from registrar.
            The container is gotten from <paramref name="listName"></paramref>, then the container removes the selected <paramref name="index"></paramref>  </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Remove(Eco.Gameplay.Players.Player,System.String,Eco.Core.Controller.IController)">
            <summary> Removes entry from registrar. The container is gotten from <paramref name="listName"></paramref>,
            then the container removes the selected <paramref name="entry"></paramref>  </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.RemoveInternal(Eco.Gameplay.Players.Player,System.String,System.Object,Eco.Core.Utils.IClientControlledContainer,System.Reflection.PropertyInfo,System.Func{Eco.Core.Utils.Result})">
            <summary> Removes entry from registrar (shared logic). The container is gotten from <paramref name="listName"></paramref>,
            then the container removes the selected <paramref name="entry"></paramref>  </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.MoveRelative(Eco.Gameplay.Players.Player,System.String,Eco.Core.Controller.IController,System.Int32)">
            <summary> Moves entry. The container is gotten from <paramref name="listName"></paramref>, then the <paramref name="entry"></paramref> is shifted in the container
            <paramref name="iDeltaMove"></paramref> positions </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Move(Eco.Gameplay.Players.Player,System.String,System.Int32,System.Int32)">
            <summary> Move entry. The container is gotten from <paramref name="listName"></paramref>, then the container Moves the selected <paramref name="iEntry"></paramref>
            to the <paramref name="newIndex"></paramref></summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.SetAt(Eco.Gameplay.Players.Player,System.String,System.Int32,Eco.Core.Controller.IController)">
            <summary> Replaces the existing entry of a list at given index. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.ControllerUtils.TypeID(Eco.Core.Controller.IController)">
            <summary>Given a controller, return the type ID that is stored in ViewClassInfo. The client can use this type id too.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.CountdownExtensions">
            <summary> Functions that modify immutable countdowns to return a new countdown. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CountdownExtensions.ResetAndPause(Eco.Shared.Utils.ImmutableCountdown)">
            <summary> Returns a new countdown with the same duration as the referenced one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DateTimeUtils.DateTimeFromString(System.String)">
            <summary>Take number from string as minutes and count a new date from current time.</summary>
            <param name="time">String should follow the template: 1m || 1h || 1d || 1w</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.DateTimeExtensions.TotalSeconds(System.DateTime)">
            <summary>Gets the number of seconds that represents the date and time of this instance.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DateTimeExtensions.LastWholeSecond(System.DateTime)">
            <summary>Creates a new DateTime object with the same date as the given DateTime object, but with all values smaller then a second set to zero.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.DeltaControllerHashSet`1">
            <summary>
            Set of controllers supporting delta updates.
            It need to register all consumers (clients) who work with set (i.e. when Player login/logout) and then regular call<see cref="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.SyncDeltas" /> to sync updates and initial states for new consumers.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.Add(`0)">
            <summary>Adds new item.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.Remove(`0)">
            <summary>Removes item.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.AddConsumer(Eco.Shared.Networking.INetClient)">
            <summary>Adds a consumer (client) for items sync.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.RemoveConsumer(Eco.Shared.Networking.INetClient)">
            <summary>Removes a consumer (client) previously added with <see cref="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.AddConsumer(Eco.Shared.Networking.INetClient)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.SyncDeltas">
            <summary>Syncs deltas for all consumers.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.SendUpdate(Eco.Shared.Networking.INetClient,System.Collections.Generic.List{Eco.Shared.Utils.ViewListDeltaChange})">
            <summary>Send delta update to <paramref name="consumer" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.SendInitialState(Eco.Shared.Networking.INetClient,System.Collections.Generic.List{Eco.Shared.Utils.ViewListDeltaChange})">
            <summary>Send initial state to <paramref name="consumer" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DeltaControllerHashSet`1.GetInitialItems(System.UInt32)">
            <summary>Returns initial items up to <paramref name="syncVersion" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.PopupEditAttribute">
            <summary>Tag properties with this to allow clients to call an 'EditProperty' RPC to open a popup that edits them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.Invitations.AcceptIfNotMember(Eco.Gameplay.Players.User)">
            <summary>Accept incoming invitation and handle different states.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.Invitations.TryRemoveInvitation(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>Remove invitation and delete mail in the process (if it's a demographics its not gonna be removed from the list so just remove the users mail).</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IPlayerUseTracking">
            <summary>Interface for things that get callbacks *and* track the using players (world objects).</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.ISingleEditingUser">
            <summary>This is used when we want an object to be edited by only one user at one time (but can be viewed by multiple users concurrently which we add to the <see cref="P:Eco.Gameplay.Utils.IPlayerUseTracking.UsingPlayers" /> list).</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PlayerUseTracking.ClearAllPlayers(Eco.Gameplay.Utils.IPlayerUseTracking)">
            <summary>Clear the object from all the players that are currently using it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PlayerUseTracking.IsBeingUsed(Eco.Gameplay.Utils.IPlayerUseTracking)">
            <summary>Check whether the current object is being used by a player.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.SingleEditingUser.AssignEditingUser(Eco.Gameplay.Utils.ISingleEditingUser,Eco.Gameplay.Players.User)">
            <summary>If no one is currently editing this object, allow the specified user to edit it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.SingleEditingUser.UnassignEditingUser(Eco.Gameplay.Utils.ISingleEditingUser)">
            <summary>Remove any user that's currently editing this object.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.ItemTracker.ReduceRemainingStacks``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Reduces remaining stacks using <paramref name="maxRemainingStacks" />. After this call remaining stacks will only have items from <paramref name="maxRemainingStacks" /> and all quantities
            will be less or equal to quantities in <paramref name="maxRemainingStacks" />. If current quantity less than in <paramref name="maxRemainingStacks" /> then it will stay untouched.
            </summary>
            <returns>True if any of remaining stacks was modified.</returns>
        </member>
        <member name="M:Eco.Gameplay.Utils.ItemTracker.ContributedItem(System.Int32,Eco.Gameplay.Items.Item,Eco.Shared.Items.WorkOrderContributionType)">
            <summary>Calculate contributed item amount base on contribution type to prevent re-counting when AutoContributed contribution </summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IUserAuthorizer">
            <summary><see cref="T:Eco.Gameplay.Utils.IUserAuthorizer" /> adapts <see cref="T:Eco.Shared.Networking.IWorldObserverAuthorizer" /> for <see cref="T:Eco.Gameplay.Players.User" /> checks and reduces boilerplate.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IUserAuthorizer.IsAuthorized(Eco.Gameplay.Players.User,Eco.Shared.Items.AccessType)">
            <summary>Checks if <paramref name="user" /> authorized for access of type <paramref name="accessType" /> on an object implementing the interface.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.MessagingUtils.NotifyError(Eco.Shared.Networking.INetClient,Eco.Shared.Localization.LocString)">
            <summary>Message the user with the given message in error format.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IDataPartition`1">
            <summary>This interface provides a minimalistic list interface and acts as a unified base for both the partitioned data and each individual data partition.</summary>
            <remarks>Used exclusively by <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" />. See <see cref="T:Eco.Gameplay.Utils.IStoredDataPartition`1" /> when looking to implement a data partition.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})">
            <summary>Removes all entries matching <paramref name="predicate" /> and returns number of removed entries.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IStoredDataPartition`1">
            <summary>A minimalistic list interface with thread safe entries list for storage purposes.</summary>
            <remarks>Use this when implementing actual data partition for use with <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" />.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.IHasCreationTime">
            <summary>When creating an entity to be used with <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> it needs to have a creation time entry
            to determine if a new data partition should be created alongside a new entry.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.PartitionedData`2">
            <summary>Partitioned data is used for high update frequency data such as Chat and Notifications. For each new day, a new data partition will be created and since each individual data partition
            is <see cref="T:Eco.Core.Serialization.IStorage" />, they are saved separately and that heavily enhances serialization speed, because only the active partition needs to be saved on updates as the previous ones are locked.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.LoadOrCreate(System.String)">
            <summary>Loads data from storage or creates new.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.GetOrAddPartition(System.Double)">
            <summary>Gets current partition if time within same day as last partition or creates new partition.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.AddNewPartition(System.Int64)">
            <summary>Adds new partition to end of <see cref="F:Eco.Gameplay.Utils.PartitionedData`2.partitionList" /> and sets it as <see cref="F:Eco.Gameplay.Utils.PartitionedData`2.activePartition" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.RemoveAll(System.Predicate{`1})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
            <remarks>Removes entries from actual partitions by recursing the RemoveAll call into them.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.PhysicsDebugCommands">
            <summary> Commands that are related to debugging physics and making failure tests. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PhysicsDebugCommands.SpawnCars(Eco.Gameplay.Players.User)">
            <summary> Spawn 20 cars on a line so some of them are inside terrains and others aren't.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PhysicsDebugCommands.MakeUnderGround(Eco.Gameplay.Players.User,Eco.Shared.Networking.INetObject)">
            <summary> Make the vehicle the player is looking at underground to do physics failure tests. </summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.PickerObject">
            <summary> A picker that targets objects. Contract clauses use this to determine the target of their operation.</summary>
            <remarks> e.g.: "Put 10 Advanced Upgrade 2 to SomeUsers's Storage Chest". This is what's used to select "SomeUser's Storage Chest". </remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.PickerProperty">
            <summary> A picker that targets a property. Contract clauses use this to determine the target of their operation.</summary>
            <remarks> e.g.: "Gather 10 Tomatoes from SomeUserFarm". This is what's used to select "SomeUserFarm". </remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.ProfanityUtils">
            <summary>Utility functions for interacting with Eco's profanity check system.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.ProfanityUtils.ReplaceIfNotClear(System.String@,System.String,Eco.Gameplay.Players.Player)">
            <summary>Replaces text in case it contains profanity and informs the player with a warning</summary>
            <param name="text">Text <see cref="T:System.String" /> to profanity check</param>
            <param name="replaceText">Text <see cref="T:System.String" /> to replace profanity with.</param>
            <param name="player"><see cref="T:Eco.Gameplay.Players.Player" /> this profanity originated from.</param>
            <returns>True if profanity was detected</returns>
        </member>
        <member name="M:Eco.Gameplay.Utils.ProfanityUtils.WarnPlayer(Eco.Gameplay.Players.Player,System.String,System.String)">
            <summary>Informs a <see cref="T:Eco.Gameplay.Players.Player" /> instance about inappropriate text found in a profanity check.</summary>
            <param name="player"><see cref="T:Eco.Gameplay.Players.Player" /> to inform about the detected profanity.</param>
            <param name="newText">Original uncensored text <see cref="T:System.String" /> to inform the user about.</param>
            <param name="oldText">The new filtered text <see cref="T:System.String" /> the profanity was replaced with.</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.ProfanityUtils.WarnPlayer(Eco.Shared.Networking.INetClient,System.String,System.String)">
            <inheritdoc cref="M:Eco.Gameplay.Utils.ProfanityUtils.WarnPlayer(Eco.Gameplay.Players.Player,System.String,System.String)" />
            <param name="client"><see cref="T:Eco.Shared.Networking.INetClient" /> instance to inform about the detected profanity.</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.ResultExtensions.NotifyIfFailed(Eco.Core.Utils.Result,Eco.Gameplay.Players.User)">
            <summary> If result is failed, notifies <paramref name="notifyUser" /> with failure message and with message style <see cref="F:Eco.Shared.Services.NotificationStyle.Error" />. Returns <c>true</c> if result failed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.RouteManagerUtil">
            <summary>Route Manager helper methods specific to Eco.Gameplay.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.TryGetNearestWalkableAreaWithoutFoliage(Eco.Shared.Math.WrappedPosition3i,Eco.Shared.Math.WorldPosition3i@,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Eco.Simulation.Agents.Plant,System.Boolean},System.Boolean)">
            <summary>
            Finds the nearest walkable area near startPos. Looks for an area without any adjacent foliage (Use predicate to add plants to skip).
            <para>If still no suitable area was found then pick a new spot and destroy all adjacent foliage if destroyPlants or destroyTrees is true.</para>
            </summary>
            <param name="startPos">The starting world position. If <see cref="M:Eco.Gameplay.Utils.RouteManagerUtil.TryGetNearestWalkableAreaWithoutFoliage(Eco.Shared.Math.WrappedPosition3i,Eco.Shared.Math.WorldPosition3i@,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Eco.Simulation.Agents.Plant,System.Boolean},System.Boolean)" /> returns false then walkable will default to startPos.</param>
            <param name="walkable"></param>
            <param name="searchRadius">The radius in meters to search outwards from startPos.</param>
            <param name="safeRadius">The radius in meters required for a spawn point to be considered "suitable". Ie. Size of area with no foliage.</param>
            <param name="destroyPlantsRadius"></param>
            <param name="destroyTreesRadius"></param>
            <param name="plantPredicate">Condition to meet when comparing plants. Ie. Plants to skip when pathfinding. Ex. Add "plant.Species.Name.Equals("CommonGrass")" to skip grass when checking for plants.</param>
            <param name="clearTerrain">clears terrain around spawn point, won't destroy world objects</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.DestroyPlantsWithinRadius(Eco.Shared.Math.WorldPosition3i,System.Int32)">
            <summary>
            Destroys all plants at position within radius with a top down projection.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.DestroyTreesWithinRadius(Eco.Shared.Math.WorldPosition3i,System.Int32)">
            <summary>
            Destroys all trees at position within radius with a top down projection.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Eco.Gameplay.Utils.TestUtils.UserOrTestUser(Eco.Gameplay.Systems.Chat.IChatClient)">
            <summary>If the chat client is already a user, use that. Otherwise, return a test user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.TestUtils.NewTwitchUser">
            <summary>Return a name for a new twitch user.  Note that this doesnt persist after server restarts, it will go back to 1.</summary>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Utils.TestUtils.GetOrCreateOtherUsers(System.Int32,System.Boolean)">
            <summary>Get an enumerable of test users, creating new ones as needed (or forcing only new ones if set to true)</summary>
        </member>
        <member name="T:Eco.Gameplay.Types.EcoTypes">
            <summary>Provides data about all the different kinds of things avaialble through the eco codebase: Items, Blocks, and NetObjects.
            Todo: migrate ItemInfo and BlockInfo into here.</summary>
        </member>
        <member name="T:Eco.Gameplay.Types.NetObjectInfo">
            <summary>Stores type data about a netobject that is shared with the client.</summary>
        </member>
        <member name="P:Eco.Gameplay.Types.NetObjectInfo.HasData">
            <summary>Return false if there's no data we need to store/sync to client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Types.WorldObjectInfo">
            <summary>Stores type data about a <see cref="T:Eco.Gameplay.Objects.WorldObject" /> that gets shared with the client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.Internal.UserSubTaskCarvePath">
            <summary> Task for following player's progress towards carving path around (as example, learning machete) </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.Internal.UserSubTaskCarvePath.IsComplete(Eco.Simulation.Agents.Plant,System.Object,System.Boolean)">
            <summary> Decrement plants count until zero and pass when selected required tool </summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.Internal.UserSubTaskTooltipOpened">
            <summary> Completes once the player opens a tooltip that derived from ItemType /// </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialFood.GetDistinctedFoodInPosition(System.Numerics.Vector3)">
            <summary>Gets unique and alive closest to position</summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.TutorialStatus">
            <summary> Watching system for the tutorial. The flags indicate the client what RPCs are needed </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialStatus.Add(Eco.Shared.Items.TutorialFlag)">
            <summary> Adds <paramref name="flag" /> to the current flags and update the client information </summary>
            <param name="flag">Flag to include</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialStatus.Remove(Eco.Shared.Items.TutorialFlag)">
            <summary> Removes <paramref name="flag" /> from the current flags and update the client information </summary>
            <param name="flag">Flag to remove</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialTasks.EnsureUIState(Eco.Gameplay.Players.User,System.String,System.String)">
            <summary>
            For some unknown reason sometimes tutorial sequence fails and user may be left with incorrect UI state.
            Until we be 100% sure it works stable we have to check UIState and re-add these tasks to avoid breaking the game.
            https://github.com/StrangeLoopGames/EcoIssues/issues/9020.
            </summary>
            <param name="user">user.</param>
            <param name="taskTitle">corresponding task title.</param>
            <param name="uiStateName">state name to check.</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialTasks.TrySubscribeTutorials(Eco.Gameplay.Players.User)">
            <summary>Setup tutorials to trigger activation on specific events.</summary>
            <param name="user"></param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTask.SetUIStates">
            <summary>Turn on states that this task enables, like showing the food panel when the food ui starts.</summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.UserTaskManager">
            <summary>Class for handling the tasks (so far just tutorials) that an individual user is given. Manages the creation, tracking,
            ordering, etc of them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.SetTaskDisplayPosition(Eco.Gameplay.Tutorial.UserTask)">
            <summary> sets task order display by discovery order </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.ActivateChainedTasks(Eco.Gameplay.Tutorial.UserTask)">
            <summary>When a task completes, call this to activate everything its chained to.</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.ResetTutorial(Eco.Gameplay.Players.Player)">
            <summary>Called from the escape menu on the client, resets all tutorials and clears tutorial cache on the client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.SetCompletedTasks(System.Collections.Generic.List{System.String})">
            <summary>Refreshes tutorial and skips tasks that are provided, completed tasks are retrieved from client PlayerPrefs.</summary>
        </member>
        <member name="T:Eco.Gameplay.UI.ButtonList">
            <summary>Display a list of entries with a custom titled and colored button optionally displayed for each.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.PlayerPopups.OptionBox(Eco.Gameplay.Players.Player,Eco.Shared.Localization.LocString,System.Collections.Generic.List{System.String})">
            <summary>Shows a dialog with a dropdown.</summary>
            <param name="player"></param>
            <param name="message">The text to be shown.</param>
            <param name="options">Options to be added to the dropdown.</param>
            <returns>Index of the selected item. -1 if the player cancells the dialog.</returns>
        </member>
        <member name="T:Eco.Gameplay.UI.UserRoster">
            <summary>A roster maintains a list of users in which both the owner of the list and the user being added need to approve.  It tracks
            a set of members (externally defined), a set of applicants, and a set of invitees.
            This is used for membership requirements like residency, classrooms, and citizenship.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.UserRoster.SetDescriptions(Eco.Shared.Localization.LocString,Eco.Shared.Localization.LocString)">
            <summary>Updates the names of the memberships.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarker.SetVisiblity(Eco.Gameplay.UI.WorldMarker.WorldMarkerVisibility)">
            <summary> Use the given <see cref="T:Eco.Gameplay.UI.WorldMarker.WorldMarkerVisibility" /> value to determine if the <see cref="T:Eco.Gameplay.UI.WorldMarker.WorldMarker" /> should be shown on the minimap or not, can be extended to provide options to show in World or not too.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarker.UpdateFolders">
            <summary>Updates the folder structure so that it prepends the settlement if one is assigned.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarker.SetSettlement(Eco.Gameplay.Players.User,Eco.Gameplay.Settlements.Settlement)">
            <summary>Set the new settlement and return true if it succeeded and was changed.</summary>
        </member>
        <member name="T:Eco.Gameplay.UI.WorldMarker.MarkerFolderName">
            <summary> Predefined names of the folders of the autogenerated markers. </summary>
        </member>
        <member name="T:Eco.Gameplay.UI.WorldMarker.WorldMarkerManager">
            <summary>World marker list and management for a single user. Global ones are held elsewhere.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarkerManager.InternalEnableMarker(System.Boolean,Eco.Gameplay.UI.WorldMarker.WorldMarker)">
            <summary>Enable or disable markers. If the markerID is null, this function will run through all the markers</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarkerManager.AddOrRemoveMakersFromDisabledList(Eco.Gameplay.UI.WorldMarker.WorldMarker,System.Boolean)">
            <summary>If a marker is added to <see cref="P:Eco.Gameplay.UI.WorldMarker.WorldMarkerManager.DisabledMarkers" />, it will be hidden. 
            That means if we want to disable a marker, just add it into to the list.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarkerUtils.MakeMarkerGlobal(Eco.Gameplay.Players.User,Eco.Gameplay.UI.WorldMarker.WorldMarker)">
            <summary> Removes a marker from the user's list and adds it to the global list. </summary>
        </member>
        <member name="M:Eco.Gameplay.UI.WorldMarker.WorldMarkerUtils.MakeMarkerPersonal(Eco.Gameplay.Players.User,Eco.Gameplay.UI.WorldMarker.WorldMarker)">
            <summary> Removes a marker from the global list and adds it to the user's list. </summary>
        </member>
        <member name="T:Eco.Gameplay.UI.WorldMarker.WorldMarkerVisibility">
            <summary> Controls the visibility of the world marker in the minimap and the world. </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnSignAtPos(Eco.Gameplay.Players.User,System.Numerics.Vector3,System.String,System.String,Eco.Shared.Math.Direction)">
            <summary> Spawns a sign at specified position, optionally with custom material and look direction. </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.ClearPlace(System.Type,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Clears place for world object of type <paramref name="worldObjectType" /> at specified position an rotation.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.ReplaceTerrain(System.Type,Eco.Shared.Math.WorldPosition3i,System.Int32,System.Type,System.Boolean)">
            <summary> Replace terrain blocks on a certain block type. Works only for top blocks </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.LevelTerrain(Eco.Shared.Math.Vector2i,Eco.Shared.Math.WrappedWorldPosition3i,Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Level ground with grass block</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.LevelTerrain(Eco.Shared.Math.Vector2i,Eco.Shared.Math.WrappedWorldPosition3i,System.Type,Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Level ground with defined block.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.LevelTerrainAsync(Eco.Shared.Math.Vector2i,Eco.Shared.Math.WrappedWorldPosition3i,System.Type,Eco.Gameplay.Players.Player,System.Int32)">
            <summary>
            Levels the terrain using given parameters.
            </summary>
            <param name="size">The size at which the terrain should be levelled.</param>
            <param name="position">the position at which the iteration starts, the leveling starts at the position and increments both x and z values.</param>
            <param name="blockType">the type of the block to use while levelling, this need to be not solid.</param>
            <param name="player">the player who started the command.</param>
            <param name="replaceUnderground">should leveling replace underground to and to what levels, this is for clearing things such as pipes.</param>
            <returns>A task that the caller can wait for it or not.</returns>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.RemoveBlock(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>Smart block remove function which is aware of plants and world objects.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnOnFlattenedGround(System.Type,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i)">
            <summary>Spawn the world object on flattened ground.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnOnFlattenedGround(System.Type,Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Spawn the world object on flattened ground.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnList(Eco.Gameplay.Players.User,System.Collections.Generic.List{System.String},Eco.Gameplay.WorldObjectDebugUtil.DeluxeSpawnFlags,System.Int32)">
            <summary> Function for spawning a list of WorldObjects on User's position. </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnList(Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,System.Collections.Generic.List{System.String},Eco.Gameplay.WorldObjectDebugUtil.DeluxeSpawnFlags,System.Int32)">
            <summary> Function for spawning a list of WorldObjects in a custom position.</summary>
            <remarks> Calculates size first, and returns it together with a Func that confirms the spawning. </remarks>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.EnsureWorldObjectEnabled(Eco.Gameplay.Objects.WorldObject,System.String,System.Threading.CancellationToken)">
            <summary>Ensures world object enabled and throws exception if it not enabled after default timeout.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.EnsureWorldObjectEnabled(Eco.Gameplay.Objects.WorldObject,System.TimeSpan,System.TimeSpan,System.String,System.Threading.CancellationToken)">
            <summary>Ensures world object enabled and throws exception if it not enabled after timeout.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.EnsureComponentEnabled(Eco.Gameplay.Objects.WorldObjectComponent,System.String,System.Threading.CancellationToken)">
            <summary>Ensures component enabled and throws exception if it not enabled after default timeout.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.EnsureComponentEnabled(Eco.Gameplay.Objects.WorldObjectComponent,System.TimeSpan,System.TimeSpan,System.String,System.Threading.CancellationToken)">
            <summary>Ensures component enabled and throws exception if it not enabled after timeout.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.ThrowNotEnabledAfterTimeoutError(Eco.Gameplay.Objects.WorldObject,System.TimeSpan,System.String)">
            <summary>Helper function for Ensure* methods.</summary>
        </member>
        <member name="T:Eco.Gameplay.Voice.VivoxAccessToken">
            <summary>
            Class used to serialise the vivox access token.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Voice.VoiceAudioFadeModel">
            <summary>
            Vivox audio fade model for 3D audio channels (positional voice). Default is InverseByDistance.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Voice.VoiceManager.UpdateClusters">
            <summary>
            This function works the fact that game world space loops but Vivox does not. It creates clusters of players
            that can possibly hear each other, which then get offset by the client.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.CalculateMaximumWeatherSystemCapacity">
            <summary>
            Calculates the maximum number of weather systems that can be active at once.
            This calculation is based on the size of the world, the minimum distance between storms, and the configured
            maximum size of a weather system.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.GetRainfallAtLocation(Eco.Shared.Math.Vector2i)">
            <summary>
            Retrieves the rainfall value at the given position. If the position is in a desert, 
            the result will always be 0.
            </summary>
            <param name="position">Position to check</param>
            <returns>Rainfall value at the given location.</returns>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.GetTemperatureAtLocation(Eco.Shared.Math.Vector2i)">
            <summary>Retrieves the temperature value at the given position.</summary>
            <param name="position">Position to check</param>
            <returns>Temperature value at the given location.</returns>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.PickWeatherEventTypeForLocation(Eco.Shared.Math.Vector2i)">
            <summary>Attempts to pick the best weather event type for the given location.</summary>
            <param name="position">Position to pick for.</param>
            <returns>The appropriate weather event for the given location.</returns>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.CreateWeatherSystem(Eco.Shared.Weather.WeatherEventType,Eco.Shared.Math.Vector3i)">
            <summary>Creates a new weather system at the given location with the given weather event.</summary>
            <param name="weatherEvent">Type of event the system represents.</param>
            <param name="location">Location of the weather system.</param>
            <returns>Newly created weather event</returns>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.ForceAddWeatherSystem(Eco.Shared.Weather.WeatherEventType,Eco.Shared.Math.Vector3i)">
            <summary>Force adds a weather system to the list of active weather systems. </summary>
            <param name="weatherEvent">Type of weather event to add</param>
            <param name="location">Location of the weather event.</param>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.AttemptSpawnWeatherSystem">
            <summary>Attempts to spawn a new weather system at a random location.</summary>
            <returns>True if a weather event was succesfully spawned.</returns>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.PerformWeatherTick">
            <summary>
            Performs a single tick of the weather manager. This tick will
            attempt to spawn a new weather system, and will expire any
            systems who's end time has been reached.
            </summary>
            <remarks>Runs every 10 seconds as defined by the worker in the initialization step.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Weather.WeatherManager.GetWeatherStatus">
            <summary>
            Creates a string that displays the current weather status. This is generally used by the GUI status page and the status 
            helper admin command.
            </summary>
            <returns>String with details about the current weather status on the planet.</returns>
        </member>
        <member name="T:Eco.Gameplay.Weather.WeatherPlugin">
            <summary>Use for manage weather. WeatherEffectsManager in client will receive the data</summary>
        </member>
        <member name="T:Eco.Gameplay.Weather.WeatherConfig">
            <summary>
            Configuration model for the <see cref="T:Eco.Gameplay.Weather.WeatherPlugin" />.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldGeneratorPlugin.WorldChatCommands.Species(Eco.Gameplay.Players.User,System.String)">
            <summary>
            Calls the specified species type and visualizes the groupings and clusters with a 2d map within the client.
            Only usable after initial world generation and does not work after a server restart.
            </summary>
            <param name="user"></param>
            <param name="species"></param>
        </member>
        <member name="T:Eco.Mods.TechTree.PictureItem">
            <summary>Holds the UserTexture for displaying it on PictureFrameItem, created by CameraItem</summary>
        </member>
        <member name="M:Eco.Core.Systems.UnserializedNamedEntry`1.Clear">
            <summary> Clears all entries. It isn't thread-safe for same entity type, but thread safe with other <see cref="T:Eco.Core.Systems.UnserializedNamedEntry" />.</summary>
        </member>
        <member name="P:Eco.Core.Utils.PropertyScanning.ICustomValidity.SkipPropertyValidation">
            <summary>If true, only the implementing objects Validity will be checked. If false, all properties will be validated and report added to result (default behavior).
            Is used in Demographics to ignore validity of props for Special Demographics as they are statically set up and cannot change.</summary>
        </member>
        <member name="T:Eco.Core.Utils.PropertyScanning.IReferrerDependentValidity">
            <summary>Defines a validity to be used when item is referenced by something else.</summary>
        </member>
        <member name="M:Eco.Core.Utils.PropertyScanning.IReferrerDependentValidity.Valid(System.Type,System.Type)">
            <summary>
            Check if valid for types that refer to this item.  IE, some references to a given object may be valid while others invalid, depending on who's referring to it.
            </summary>
            <param name="referrerType">The immediate parent of the item.</param>
            <param name="referrerRootType">The root object this item belongs to.</param>
        </member>
        <member name="T:Eco.Core.Utils.PropertyScanning.PropertyScanner">
            <summary>PropertyScanner that does a scan on an object, using reflection to examine and update its properties.  It can do the following things:
            - Detect if the object is valid, using attributes like [AllowNull] and others to help it determine what is valid or not. 
            - Caches validity if has the ICachesValidity interface. Returns the Result.
            - Returns paths of all the properties that were invalid, which allows the client to display markers and text on them. 
            - Updates tracked references and referenced-by, which are stored in  ker.
            - Fixes parameters referencing bad context 
            - Can apply reference updating (when an object gets swapped for another, modified through election for example).
            - Sets up any instances of IParentedController it finds, configuring the hierarchy.
            </summary>
        </member>
        <member name="F:Eco.Core.Utils.PropertyScanning.PropertyScanner.FirstFullScanInitializer">
            <summary>Can be subscribed to in order to perform an action after full scan is complete. </summary>
        </member>
        <member name="T:Eco.Shared.Weather.WeatherSystem">
            <summary>
            Represents a weather system currently in the world. This object is managed by
            the Weather Manager and is synced to the client.
            </summary>
        </member>
    </members>
</doc>
